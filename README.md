# بدهی فنی (Technical Debt)

پیش می‌آید که می بایست مابین «انجام اصولی یک پروژه» و «انجام سریع یک پروژه» یکی را انتخاب کنیم و در ابتدای کار سرعت بخشیدن به فرایند طراحی یک پروژه جذاب‌تر به نظر می‌رسد با این استدلال که بعداً هم می‌شود مجدد به کدها سر زد و اگر مشکلی داشت آن ها را از بین برد! اما تجربه نشان داده است زمانی که در بر گیرنده واژه ی بعداً است، خود حاوی بسیاری باگ ها و مشکلات خواهد بود که برنامه نویس مجبور است بیشتر تمرکز خود را روی آن‌ها بگذارد و از توجه به مشکلات -هرچند جزئی- گذشته باز می ماند.

چنین سیاستی در برنامه نویسی اصطلاحاً Technical Debt گفته می‌شود که به صورت تحت الفظی می‌توان آن را به «بدهی فنی» ترجمه کرد (توجه داشته باشید که در واژه انگلیسی Debt حرف b تلفظ نمی شود!) این بدهی فنی اصلاً چیز خوبی نیست و گاهی اوقات منجر به بوجود آمدن فجایعی در تولید نرم افزار می شود. برای روشن شدن این مسأله مثالی می زنیم. بدهی فنی همچون وام گرفتن است که در کوتاه مدت کار ما را راه می‌اندازد اما غافل از این که در آینده می بایست با بهره ای که روی آن می‌آید -مثلا 30 درصد بیشتر- قرض خود را پرداخت کنیم (راستی می گن در برخی کشورهایی که مسلمان نیستند بهره بانکی چیزی در حدود یکی دو درصد است در حالی که در ایران اسلامی ما گاها تا پنجاه درصد می رسد. آن‌ها مسلمانند یا ما. بگذریم!)

در برنامه نویسی هم قضیه دقیقاً به همین صورت است. اگرچه گاهی اوقات می‌توان از راه کارهایی استفاده کرد که به کدنویسی ما سرعت بخشند اما این در حالی است که در آینده اضافه کردن ویژگی‌های جدیدی به پروژه را دشوار می‌سازد و به اصطلاح نمی‌توان به سادگی کدهای خود را Refactor کرد. جالب اینجا است که هرچه از زمان ایجاد این دست مشکلات بیشتر می گذرد، یافتن راه‌کار هم برای آن‌ها دشوارتر خواهد شد. اما اگر ما از زمان بندی پروژه عقب باشیم و مجبور باشیم سرعت عمل را بر کیفیت ترجیح دهیم چطور؟ توصیه ما این است که هرگز سیاست فدا کردن کیفیت کار به خاطر سرعت بخشیدن به آن را دنبال نکنید اما اگر واقعاً مجبور هستید، پس این کار را انجام دهید اما حتماً به خاطر داشته باشید که شما با این کار یک بدهی فنی برای خود ایجاد کرده‌اید که می بایست در اولین فرصت این بدهی خود را صاف کنید. برای این منظور هم، حتماً در مستندات پروژه این قضیه را ذکر کنید تا فراموش نشود که در غیر این صورت ممکن است مجبور شوید بهای گزافی بابت آن پرداخت کنید.






# برنامه نویسی تابعی یا Functional Programming

برنامه نویسی تابعی یا Functional Programming در چند سال گذشته طرفداران بسیاری پیدا کرده است. این پارادایم عبارت است از روشی که در آن منطق به کار گرفته شده در برنامه به صورت توابع ریاضیاتی در نظر گرفته می شوند. درک صحیح این نوع پارادایم به طرز قابل توجهی کمک به ارتقاء کیفیت کدی که نوشته می‌شود خواهد کرد و چنانچه شما -به عنوان یک برنامه نویس- از اصول برنامه نویسی تابعی استفاده کنید، کیفیت برنامه‌ای که می نویسید دوچندان خواهد شد که در نهایت با تعداد خطوط کدی کمتری، نتیجه ای که نیاز دارید را به دست خواهید آورد.

زمانی که در پروژه های خود از توابع استفاده می کنیم، مسئولیت های خاصی را می‌توان به هر تابع اختصاص داد و توابع با استفاده از آرگومان هایی که می گیرند، می‌توانند خروجی های مختلفی را در اختیار سایر بخش های برنامه قرار دهند. برنامه‌هایی که در آن‌ها از توابع به درستی استفاده شده باشد، نسبت به روش‌های سنتی برنامه نویسی به سادگی قابل Debug کردن هستند. برنامه نویسی تابعی در برنامه نویسی شیئ گرایی به خوبی جواب داده است اما این در حالی است که در تمامی موقعیت ها نمی‌توان از این پارادایم استفاده کرد.






# نیاز کاربر چیست؟

همه کسانی که برنامه نویسی می‌کنند فکر می‌کنند که کاربران برنامه یا اپلیکیشنی که توسعه می دهند مثل ایشان فکر می‌کنند و بر این باورند که همان ارتباطی که خود ایشان با برنامه شان دارند را کاربران دیگر هم خواهند داشت که این ایده بس اشتباه است. چنین باوری از دید روانشناسی اصطلاحاً False Consensus Bias نامیده می شود. جالب است بدانیم وقتی کاربران به طرزی با برنامه نوشته شده توسط ما تعامل برقرار می‌سازند که بر خلاف انتظار ما است،‌ روی ایشان برچسب «یک کاربر غیر حرفه ای» را می زنیم! اما این در صورتی است که ما یک برنامه نویس غیر حرفه ای هستیم که نیازهای جامعه ی هدف خود را به خوبی تشخیص نداده ایم!

آنچه مسلم است این که کاربران هرگز مثل برنامه نویسان فکر نمی‌کنند چرا که ایشان برخلاف توسعه دهندگان زمان کمتری را پای کامپیوتر می نشینند،‌ با نحوه کار کردن سیستم‌ها خیلی آشنایی ندارند، فاقد مهارت های حل مسأله هستند که اکثر برنامه نویسان از آن‌ها برخوردارند، با الگوهایی که برنامه نویسان برای طراحی و کدنویسی مورد استفاده قرار می‌دهند آشنا نیستند و غیره. به عبارت دیگر، ارتباطی که یک End User با یک برنامه یا اپلیکیشن دارد همچون ارتباطی است که یک برنامه نویس با یک خودرو دارد. درست است که برنامه نویس می‌داند که چگونه سوار خودرو شود، کمربند خود را ببندد و ...، اما این آقا یا خانم برنامه نویس هرگز نمی‌داند که سازوکار سیستم این خودرو به چه شکل است.

برای رفع این مشکل، می بایست از یک کاربر عادی بخواهیم که به تعامل با برنامه، سایت یا اپلیکیشن ما بپردازد و نحوه ارتباط برقرار ساختن وی با نرم‌افزار را به دقت مورد بررسی قرار دهیم. در‌واقع می بایست ببینیم که نیازهای این کاربر چیست، کجاها به مشکل بر می خورد، در کدام بخش‌ها سردرگم می‌شود و … برای روشن شدن این مسأله مثالی می زنیم. زمانی که یک برنامه نویس به عنوان مثال سایتی را کدنویسی می کند، زمانی که در ناحیه کاربری به مشکلی برخورد می‌کند به طور حتم می‌داند که از چه طریق می بایست آن مشکل را رفع کرد اما این مسأله در مورد کابران عادی صدق نمی‌کند و ایشان ممکن است به محض برخورد با کوچک‌ترین مشکل، از هدف خود دست بکشند. نکته دیگری که می بایست همواره مد نظر قرار دهیم این است که در اکثر مواقع مابین آنچه کاربران واقعاً به آن نیاز دارند و آنچه بیان می‌کنند یک شکاف وجود دارد. به عبارت دیگر و به قول مرحوم استیو جابز، این کاربران نیستند که می‌گویند چه می‌خواهند بلکه این شما به عنوان یک طراح هستید که می بایست به نیاز کاربران پی برده و نیاز ایشان را به بهترین شکل به ایشان عرضه کنید.

برای رفع این مشکل، به جای گوش کردن به صحبت‌های کاربران، می بایست به تعامل ایشان با سایت، نرم‌افزار یا اپلیکیشن نگاه کرده و از روی رفتار ایشان با برنامهٔ‌مان، وی را نیاز سنجی کنیم. در یک کلام، اگر چند دقیقه به رفتار یک کاربر با برنامه خود نگاه کنیم، به مراتب مثمرالثمر تر از انجام یک مصاحبه چند ساعتی با چندین مخاطب بالقوه در مورد نیازهای ایشان خواهد بود.






#  استاندارهای کدنویسی

استاندارهای کدنویسی یا Coding Standards یکی از چیزهایی است که هر برنامه نویسی که قصد دارد لیبل حرفه‌ای رویش بخورد می بایست دنبال کند. پیروی از استانداردهای کدنویسی کار خیلی آسانی هم نیست و گاهی اوقات خیلی خسته‌کننده می‌شود اما واقعیت امر این است که در پروژه های نسبتاً بزرگ اعضای تیم نیاز دارند تا از یکسری قوانین تبعیت کنند.

توجه داشته باشیم زمانی که یک سری قوانین کدنویسی -مثلا تعداد اسپیس هایی که می بایست در کدها استفاده کرد- را وضع می کنیم، تمامی اعضای تیم می بایست قبول کنند که از آن قوانین تبعیت کنند که در غیر این صورت، یک برنامه نویس خاطی می‌تواند هر چه سایر برنامه نویسان رشته کرده‌اند را پنبه کند! برای اعمال استانداردهای کدنویسی می‌توان از یکسری ابزارها هم استفاده کرد که فرایند استاندارد سازی را تا حد قابل توجهی برای برنامه نویس سهل و آسان می سازند که این ابزارها بسته به IDEیی که استفاده می کنیم می توانند از خصوصیات مختلفی برخوردار باشند.

به عنوان نمونه، می‌توان زبان برنامه نویسی پی اچ پی را مثال زد. سایتی تحت عنوان php-fig.org استانداردی تحت عنوان PSR که مخفف واژگان PHP Standard Recommendation است را برای برنامه نویسان پی اچ پی طراحی کرده که علاقمندان با استفاده از این استانداردها می توانند از کدهایی برخوردار شوند که سایر برنامه نویسان پی اچ پی با نگاه کردن به کدهای ایشان کمتر دچار سردرگمی شوند.

به طور مثال، کدی که در زیر مشاهده می کنید بر اساس استاندارد PSR نوشته شده است:

```php
<?php
namespace Vendor\Package;

use FooInterface;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class Foo extends Bar implements FooInterface
{
    public function sampleFunction($a, $b = null)
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // method body
    }
}
```
در واقع، در کد بالا پس از namespace و دستورات use یک اینتر قرار گرفته است و یا این که علامت } مرتبط با کلاس Foo در خط بعد نوشته شده است. به عنوان مثالی دیگر، آرگومان های متد sampleFunction با یک کاما و اسپیس از یکدیگر مجزا شده اند و این در حالی است که کاما به آرگومان اول چسبیده، سپس یک فاصله قرار گرفته و در نهایت آرگومان دوم نوشته شده است.






# ساده زیباست

جمله‌ای از افلاطون وجود دارد با این مضمون که «هارمونی، زیبایی ظاهری، ظرافت و موزون بودن همه و همه به سادگی بستگی دارند.» و این جمله اگر توسط برنامه نویسان به کار گرفته شود، مزایای بسیار زیادی برای ایشان در بر خواهد داشت که از آن جمله می‌توان به خوانایی بیشتر کدها، نگهداری راحت‌تر اسکریپت ها، افزایش سرعت کدنویسی و در نهایت کیفیت بالاتر کدهای نوشته شده اشاره کرد و تمامی این موارد -و حتی موارد بیشتر- جز با به کارگیری این دیدگاه افلاطون یعنی همان سادگی امکان‌پذیر نیست.

حال می بایست به این سؤال پاسخ دهیم که به چه نوع کدی صفت زیبا اطلاق می گردد. این سؤال بسیار انتزاعی است چرا که مفهوم زیبایی چیزی کاملاً نسبی است. درکی که هنرمندان از زیبایی دارند به مراتب متفاوت تر از مهندسان یا برنامه نویسان است. لذا نیاز است تا مسئله ی زیبایی در برنامه نویسی را کمی بشکافیم!

برای درک بهتر این موضوع، بهتر است سری به گیت هاب زده و برخی اسکریپت های نوشته شده توسط برنامه نویسان از نقاط مختلف جهان را مشاهده کنید. با مقایسه کدهای مختلف متوجه خواهید شد که برخی برنامه نویسان هستند که یکسری قوانین را به خوبی رعایت می‌کنند و همین مسأله منجر می‌گردد تا کدهای نوشته شده توسط ایشان زیبا‌تر به نظر برسد. جالب است بدانیم که هرچه کدی ساده‌تر باشد، در عین حال زیبا‌تر هم به نظر می رسد. اگرچه برخی برنامه‌ها هستند که بسیار پیچیده هستند و کارهای عجیب و غریبی انجام می‌دهند که آدمی را به شگفتی وا می دارند، اما اگر همین برنامه‌ها را به بخش‌های کوچک‌تری تقسیم‌بندی کنیم، خواهیم دید که اگر برنامه نویس آن برنامه مد نظر حرفه‌ای بوده باشد و به سادگی در کدنویسی ایمان داشته باشد، بخش‌های کوچک برنامه کاملاً ساده و قابل درک هستند، هر ماژول وظیفه ی مشخصی دارد، بخش‌های مختلف مثل کلاس ها، متدها و متغیرها به خوبی نامگذاری شده‌اند به طوری که اگر سایر برنامه نویسان هم به سورس کد نگاه کنند، به راحتی متوجه وظیفه هر بخش از کد خواهند شد. به طور خلاصه، کد زیبا کدی است که ساده باشد. بخش‌های مختلف نرم‌افزار می بایست دارای روابط ساده‌ای با سایر بخش‌ها بوده و به سادگی قابل درک باشند.






# آشنایی با مفهوم ریفکتورینگ در کدنویسی

یکی از چیزهایی که اکثر برنامه نویسان با آن رو به رو می‌شوند مفهومی است تحت عنوان Refactor که به معنی بازنویسی کدهایی است که پیش از این نوشته شده اند. نیاز به توضیح نیست تجربیاتی که یک برنامه نویس پس از چند سال کدنویسی کسب می‌کند قابل مقایسه با زمانی نیست که وی تازه شروع به کار کرده و مسلماً پس از چند صباحی که به کدهای خود نگاه کند، حالش از سبک کدنویسی خود به هم خواهد خورد و تصمیم می‌گیرد تا کدهای نوشته شده ی خود را اصطلاحاً Refactor کند. در این قسمت از آموزش، قصد داریم ببینیم که زمان مناسب برای بازنویسی کدهای پیشین چه موقع است و این در حالی است که اگر بدانیم چرا و چگونه این کار را انجام دهیم، در زمان ما به طرز قابل توجهی صرفه جویی خواهد شد.

پیش از آن که اقدام به بازنویسی کدهای خود کنید، حتماً موارد زیر را مد نظر قرار دهید: همواره یکی از بهترین رویکردها نسبت به این که کدهای خود را بازنویسی کنیم یا نکنیم این است که کدها را با استفاده از تست هایی که برای آن‌ها می نویسیم تست کنیم چرا که با این کار به نقاط ضعف و قوت برنامه خود به خوبی پی برده و زمانی که بخواهیم کدها را Refactor کنیم، بخش‌هایی از کد که دارند به خوبی کار می‌کنند را دست کاری نخواهیم کرد اما در عین حال نقاط ضعف را برطرف خواهیم نمود. برنامه نویس ها همواره فکر می‌کنند که می‌توانند کدی بنویسند که بهتر از کد فعلی کار کند و این همان اشتباهی است که می بایست تا حد ممکن از آن اجتناب کرد.

هشدار علاوه بر این، حتماً بایستی مقابل وسوسه بازنویسی هر سورس کدی ایستادگی کرد. همواره به خاطر داشته باشیم که بایستی تا حد ممکن از کدهای قبلی استفاده کنیم حتی اگر کدها تمیز نوشته نشده اند! زمانی که کدهای قبلی را پاک می کنیم، این بدان معنا است که ما ماه ها و یا سال‌ها تلاش و کدنویسی را هدر می دهیم.

در فرایند بازنویسی کد، اعمال چندین تغییر ساختاری کوچک به مراتب بهتر از یک تغییر عمده است. به عبارت دیگر، تغییرات کوچک این امکان را به شما می‌دهند تا تأثیر آن تغییرات را روی برنامه خود راحت‌تر تست کرده و بازخورد آن‌ها را مشاهده نمایید.

پس از تکمیل هر ماژول -یا بهتر بگوییم هر بخش از برنامه- سورس کد ما حتماً بایستی از سد چندین تست عبور کند. به محض این که یک تغییر جدید در کد خود ایجاد می کنید، حتماً تست آن تغییرات را هم بنویسید. در‌ واقع این تست ها عملکردی همچون End User دارند که گویی دارد با برنامه ما کار می‌کند و این اطمینان را حاصل می‌کنند نرم افزاری که به دست مشتری خواهد رسید بدون باگ است. در ضمن، هرگز تست های نرم افزاری قدیمی را پاک نکنید چرا که ممکن است در ماه های گذشته ایده خاصی مد نظر شما بوده که برای تست کردن آن یک Unit Test نوشته‌اید اما اکنون که دارید به بازنویسی کدها می پردازید، فکر شما اصلاً به سمت و سوی آن ایده خاص نرفته است.

سعی کنید تا حد ممکن سلایق شخصی را وارد کدنویسی نکنید. اگر بخشی از کد دارد به درستی کار می کند، اصلاً نیازی به بازنویسی آن نیست. اگر کدهایی که نوشته‌اید تمیز نیستند، این اصلاً دلیل خوبی برای بازنویسی آن‌ها نیست. اگر هم کدهای پیش روی شما از برنامه نویس دیگری به شما به ارث رسیده، احتمال این که فکر کنید کدهای شما به مراتب بهتر از برنامه نویسی قبلی خواهد بود زیاد است که این هم اصلاً دلیل موجهی نیست!

استفاده از فناوری های جدید هم اصلاً دلیل مناسبی برای Refactoring نیست. یکی از بدترین دلایلی که یک برنامه نویس برای بازنویسی کدها می‌تواند بیاورد این است که کدهای برنامه مربوط به فناوری های چندین سال پیش هستند و در حال حاضر نسخه نرم‌افزارها و زبان‌های برنامه نویسی استفاده شده در آن برنامه ی به‌ خصوص خیلی ارتقاء یافته اند. در چنین مواقعی حتماً می بایست به بررسی دقیق فریم ورک یا زبان برنامه نویسی مد نظر پرداخته تا ببینیم که آیا نسخه های جدید آن واقعاً بهبود یافته‌اند یا خیر. اگر واقعاً کمکی به بهبود عملکرد، نگهداری و راندمان نرم‌افزار می‌کردند که بایستی به بازنویسی کدها پرداخت و در غیر این صورت می بایست کدها را همان‌طور که هستند رها کرد. در پایان هم همواره به خاطر داشته باشید که آدم‌ها همیشه در معرض ارتکاب خطا هستند. بازنویسی کدها اصلاً بدان معنا نیست که کدهای جدید بهتر از کدهای قبلی یا به همان خوبی کدهای قبلی کار خواهند کرد!






# نظافت را رعایت کنید!

برخی از آدم‌های متشخص هستند که وقتی زباله ای را روی زمین مشاهده می کنند، بدون توجه به این که چه کسی آن را روی زمین انداخته، زباله را برداشته و در جایگاه مخصوص به آن می اندازند (البته این قضیه بیشتر در کشورهای جهان اول مشاهده می گردد!) به عبارت دیگر، چنین افراد خیر خواهی، فضایی تمیز برای سایر افرادی که در آن محیط حضور خواهند داشت آماده می سازند. جمله‌ای وجود دارد با این مضمون که «دنیا را برای نسل ها آتی به مکان بهتری نسبت به آنچه تحویل شما داده شده مبدل سازید.»

یک برنامه نویس خوب کسی است که وقتی کدهای یک برنامه نویس دیگر را تحویل می‌گیرد -فارغ از این که برنامه نویس قبلی چه کسی بوده- تمام تلاش خود را به کار خواهد بست تا کدها را بهبود بخشد و این در حالی است که این بهبود کار می‌تواند هم در زمینه بهبود راندمان کدها بوده و یا حتی در زمینه کامنت گذاری باشد. به نظر شما در چنین شرایطی نتیجه نهایی چه خواهد شد؟

به نظر می‌رسد که اگر برنامه نویسان دنباله روی چنین رویکردی باشند، روز به روز کیفیت کدهایی که نوشته می‌شوند بیشتر خواهد شد تا جایی که وجود باگ در کدها به یک امر انتزاعی مبدل خواهد شد. حال ممکن است این سؤال برای شما پیش بیاید که اگر برنامه نویس قبلی به جای کدنویس، … بود چه؟ در پاسخ به چنین سؤالی بایستی گفت که اصلاً نیاز نیست تا شما تمامی بخش‌های کد را بهبود ببخشید بلکه صرفاً نیاز است تا هر آنچه که از دست شما بر می‌آید را انجام دهید و یا حداقل کدهایی که به ماژول قبلی می افزایید را سعی کنید تمیز و مرتب بنویسید. این تمیز نویسی کدها می‌تواند به نام گذاری صحیح توابع و متغیرها، رعایت فاصله ها و … ختم گردد.

در تیم های برنامه نویسی می بایست پس از اتخاذ رویکردی همچون آنچه در بالا به آن اشاره شد، فضایی ایجاد گردد که حتی اگر یکی از اعضای تیم خواست تا کدنویسی نامرتبی انجام دهد از سایر اعضای تیم خجالت کشیده و خود را اصلاح کند دقیقاً شبیه به شرایطی که در یک مهمانی مجلل اتفاق می افتد: آیا کسی رویش می‌شود که پس از خوردن خیار، پوست آن را روی پارکت پرتاب کند؟ هرگز!






# پیش از آن که دیگران را متهم کنید، کد خود را چک کنید!

رفتاری رایج در میان اکثر برنامه نویسان دنیا این است که وقتی اسکریپتی می‌نویسند که کار نمی کند، پیش از هر چیز تقصیر را به گردن کامپایلر، وب سرویس و یا حتی سایر برنامه نویسان می‌اندازند که چنین رویکردی در اکثر مواقع نادرست است. اگرچه گاهی اوقات پیش می‌آید که مثلاً باگی در یک وب سرور مثل آپاچی به وجود می‌آید و همین مسأله منجر به بوجود آمدن مشکلی برای ما می‌شود، اما از آنجا که چنین نرم افزارهایی جهانی هستند و عدم وجود باگ در آن‌ها از اهمیت ویژه ای برخوردار است، توسعه دهندگان چنین نرم افزارهایی در اسرع وقت آن باگ را رفع خواهند کرد. لذا وقتی کد ما کار نمی کند، پیش از هر چیز و هر کس، می بایست انگشت اتهام را به سمت خودمان نگاه داریم …

گاهی اوقات هم برای برنامه نویسان پیش می‌آید که با مشکلی مواجه می‌شوند و این در حالی است که ایشان از یک برنامه جدید متن باز که نسخه آن هم 0.1 است استفاده می کنند. در چنین شرایطی ایشان می‌توانند به عدم کارکرد صحیح نرم‌افزار یا سرویس مورد نظر خود شک کنند اما وقتی پای سرویس های با قدمت زیاد به میان می آید که گاها چندین میلیون کاربر در سرتاسر دنیا دارند، می بایست شکی به خود راه ندهیم که مشکل از خود ما است!






# انتخاب ابزار مناسب

بسیاری از نرم‌افزارها و اپلیکیشن هایی که ما امروزه می‌بینیم و به موفقیت‌های نسبتاً خوبی هم دست پیدا کرده‌اند هرگز کدنویسی آن‌ها از صفر شروع نشده است بلکه این دست نرم‌افزارها با استفاده از ابزارهای موجود -در اینجا منظور از ابزار کامپوننت ها، کتابخانه ها، فریم ورک ها و … است- ساخته شده اند. در همین راستا، زمانی که قصد شروع پروژه ای را داریم حتماً می بایست مناسب‌ترین ابزارها را برای پروژه خود انتخاب کنیم و هرچه پروژه ما بزرگ‌تر باشد، لزوم تحقیق در این زمینه نیز بیشتر خواهد شد.

در ارتباط با دلایلی که چرا برخی از پروژه ها از صفر کدنویسی نمی‌شوند و در آن‌ها از کامپوننت ها و کتابخانه‌های موجود استفاده می شود، می‌توان موارد زیر اشاره کرد:

1- نرم‌افزارها و اپلیکیشن ها در طول زمان رشد می کنند، پیچیده‌تر می‌شود و در نهایت نسبت به نسخه بتای خود به مراتب حرفه‌ای تر می‌شوند و این در حالی است که زمان اختصاص یافته برای توسعه این دست نرم‌افزارها و اپلیکیشن ها محدود و محدودتر می گردد. منطقی‌تر به نظر می‌رسد اگر برنامه نویسان بیشتر از آن که روی کدنویسی زیرساخت پروژه زمان صرف کنند (که در اکثر پروژه ها این زیرساخت تاحدودی مشابه است)، تمرکز خود را روی کدنویسی بخش‌های اختصاصی پروژه شان متمرکز سازند.

2- کامپوننت ها و فریم ورک هایی که در سرتاسر دنیا مورد استفاده قرار می‌گیرند به مراتب دارای باگ های کمتری نسبت به کدهایی هستند که یک برنامه نویس فریلنسر در اتاق کارش می نویسد!

3- بسیاری از فریم ورک های موجود در بازار به صورت رایگان در اختیار توسعه دهندگان قرار می‌گیرد و همین مسأله حاکی از آن است که هزینه‌های مرتبط با توسعه یک پروژه به مراتب کاهش خواهد یافت.

4- توسعه زیرساخت پروژه در زمینه‌های مختلف مثل امنیت، راندمان و … کاری حساس، دقیق، زمان بر و پرهزینه است اما اگر شما از کامپوننت های متن باز و رایگان استفاده کنید، می توانید از به روزرسانی به هنگام و ساختاری پروژه خود اطمینان حاصل کنید.

به خاطر داشته باشید
توجه داشته باشیم که شرکت فیسبوک ابتدا برای برنامه نویسی این شبکه ی اجتماعی از زبان برنامه نویسی PHP استفاده کرد اما پس از آن که این شبکه جای خود را در میان کاربران باز کرد و به درآمدزایی هنگفتی دست یافت، مدیران این شرکت تصمیم گرفتند زبان اختصاصی این شرکت تحت عنوان Hack را توسعه داده و شبکه ی اجتماعی فیسبوک را روی آن بنا کنند.

آنچه مسلم است این که انتخاب ترکیبی از ابزارهای موجود برای توسعه اپلیکیشن خود کاری حساس بوده و نیازمند برخورداری از تجربه در این زمینه است. برای همین منظور، راه کارهایی را در ادامه برای شما آورده‌ایم که می‌تواند به شما در انتخاب ابزار مد نظرتان کمک شایانی کند:

*- هر ابزاری در یک بستر خاص بهترین اثربخشی را خواهد داشت. منظور ما در اینجا از بستر عبارت است از ساختار دیتابیس، پروتوکل های ارتباطی، سرور،‌ وب سرویس، ای پی آی و … پس این احتمال وجود دارد ابزاری که شما انتخاب کرده‌اید با بستر توسعه نرم افزاری تان همخوانی نداشته باشد و همین مسأله منجر به پیچیده‌تر شدن پروژه شما خواهد شد.

*- ابزارهایی که امروزه مشاهده می‌کنیم از عمر مشخصی برخوردارند و زمانی که آپدیتی برای آن‌ها به بازار عرضه می‌شود و یا نسخه جدیدی از آن‌ها در دسترس توسعه دهندگان قرار می گیرد، ممکن است -اگر نگوییم حتماً همین‌طور است- شاهد تغییرات بسیاری نسبت به نسخه قدیمی باشیم که گاهی اوقات نسخه های جدید از یک ابزار خاص -مثلا یک فریم ورک برنامه نویسی- دارای تغییرات ساختاری زیادی نسبت به نسخه قبلی است که آن ها را اصلا غیر قابل مقایسه می کند. به طور مثال، فریم ورک برنامه نویسی تحت وب لاراول، در نسخه ۵ خود کاملاً ساختار این فریم ورک را تغییر داده و این در حالی است که اگر شما از نسخه ۴ این فریم ورک استفاده می‌کرده اید و حال قصد مهاجرت به آخرین نسخه را دارید، کل پروژه شما دستخوش تغییر خواهد شد (توجه داشته باشیم که هرچه تعداد فریم ورک ها و ابزارهای استفاده شده در پروژه ما بیشتر باشد، عمق این فاجعه هم بیشتر خواهد شد!)

*- برخی از ابزارهای موجود نیازمند کانفیگ یا تنظیم کردن هستند که مسأله تنظیم کردن آن‌ها شاید نیازمند صرف وقت و هزینه قابل توجهی باشد.

*- برخی از ابزارهای به اصطلاح رایگان آن طور که باید و شاید Free نیستند. در ابتدا ما تصور می‌کنیم که ابزار مد نظر ما کاملاً رایگان است و شروع به استفاده از آن می‌کنیم اما وقتی پروژه به جاهای حساس خود می‌رسد و نیازمند استفاده از کامپوننت های خاصی است، کاشف به عمل خواهد آمد که می بایست بخشی از سورس کد را از توسعه‌دهنده اصلی خریداری کنیم و همین مسأله می‌تواند آینده نرم‌افزار ما را تحت الشعاع قرار دهد.

*- برخی از ابزارها پس از توسعه نرم‌افزار با آن‌ها برای ما محدودیت ایجاد می کنند. به طور مثال، برخی از لایسنس های نرم افزاری هستند که توسعه دهندگانی که از آن‌ها استفاده می‌کنند را ملزم به انتشار نرم افزارشان به علاوه سورس کد آن به صورت کاملا باز و رایگان می‌کنند که چنین محدودیتی مسلما برای خیلی از توسعه دهندگان خوشایند نخواهد بود!

آنچه مسلم است این که تصمیم گیرنده نهایی خود شما خواهید بود لذا می بایست تا حد ممکن کدهایی که مرتبط با زیرساخت پروژه می‌شوند را با استفاده از بهترین ابزار یا فریم ورک موجود توسعه داده و کدهای مرتبط با ماژول اختصاصی پروژه خود را شخصاً کدنویسی کنید.









# برنامه های خود را به زبان مشتریان بنویسید!

به عنوان یک برنامه نویس احتمالاً صاحبان صنایع و مشاغل مختلف به شما مراجعه می کنند و به شما سفارش کار می دهند. برای انجام این سفارشات که مربوط به فرآیند های کاری مشتریان می باشند، شما می توانید با استفاده از قابلیت های زبان های برنامه نویسی مختلف، آن فرآیند ها را مدل سازی کنید. به طور مثال ممکن است صاحب یک فروشگاه به شما سفارش برنامه ای برای کنترل کالاهای موجود در انبار فروشگاه بدهد. بنابراین شما باید یک انبار را مدل سازی کنید که کالاهای خریداری و ذخیره شده در آن ثبت شوند و بتوان وضعیت آن ها را تا زمانی که در انبار موجود باشند پیگیری کرد. توصیه ای که ما به شما داریم این است که در این موارد برنامه ی خود را به زبان مشتری سفارش دهنده بنویسید.

منظور از این که برنامه ی سفارشی خود را به زبان مشتری بنویسید این است که در کدهای برنامه از اصطلاحات کسب و کار مشتری استفاده کنید و روابط و رویه های کاری او را در برنامه پیاده سازی کنید. بگذارید با مثال هایی موضوع را شفاف تر سازیم. مثال فروشگاه را در نظر بگیرید. برای مدل سازی کالاهای خریداری شده، باید متغیری تعریف کنیم که نام کالای جدید را در آن ذخیره کنیم تا بعداً در بخش های دیگر برنامه از آن استفاده شود. می دانیم که برای تعریف هر متغیر یا Variable در برنامه نویسی، نیاز به یک اسم داریم. بهترین کار این است که به جای استفاده از یک نام بی معنی، مثلاً x، نامی را انتخاب کنیم که معرف این باشد که قرار است چه چیزی در متغیر مد نظرمان ذخیره شده و در عین حال برای مشتری هم شناخته شده باشد. به طور مثال این متغیر را new_product_name نام گذاری کنیم و با ورود هر کالای جدید آن را در این متغیر ذخیره کنیم،
```
new_product_name = "Icecream"
// or
new_product_name = "Pen"
```
در مورد رویه ها نیز به همین ترتیب عمل کنیم. مثلاً این طور نیست که کارکنان انبار تمام اجناس خریداری شده را در یک قسمت نگه داری کنند، بلکه متناسب با نوع محصول، آن ها را در بخش های مختلف انبار می کنند. مواد غذایی فاسد شدنی را در سردخانه، کرم ها را در بخش لوازم بهداشتی، پارچه ها را در بخش منسوجات و  . . .  وقتی نوبت به شما می رسد تا این رویه را مدل سازی کنید، شاید با خود فکر کنید در این مدل مجازی کنار هم قرار دادن کالاهایی مثل مواد غذایی، لوازم بهداشتی، و غیره تأثیری روی آن ها نمی گذارد. بنابراین به جای آن که با صرف زمان بیش تر و نوشتن کدهای بیش تر، نام این محصولات را در جداول جداگانه ای در دیتابیس قرار دهید، تصمیم می گیرید تمام آن ها را در یک جدول قرار داده تا در زمانی که بخواهید وضعیت یک محصول را بررسی کنید، کدهای برنامه به جای چند جدول دیتابیس، یک جدول را بیش تر در دیتابیس نگردند. شاید این کار برای شما راحت باشد، اما این نکته را در نظر داشته باشید که این برنامه برای صاحب فروشگاه است، نه شما!

بهتر است که کدهای شما صریحاً رویه های ذخیره سازی در انبار را شبیه سازی کنند. مزیت این نوع کدنویسی صریح و مطابق با روال های کاری مشتری آن است که اولاً، تصحیح خطاها و تغییرات مورد نیاز در برنامه را برای شما راحت تر می کند (حتی اگر فراموش کنید هر قطعه از کد شما چه طور و برای چه منظوری کار می کند، می توانید به رویه های کاری مشتری رجوع کنید و الگوریتم آن را رمز گشایی کنید) ثانیاً، اگر برنامه نویس دیگری جایگزین شما شود تا سیستم موجود را به روز رسانی کند، از طریق آشنایی با این رویه های کاری، منظور کدهای شما را به راحتی درک می کند و نیازی نیست که به شما مراجعه کند تا آن ها را تفسیر کنید یا این که بخواهد برنامه ی جدیدی که برای خودش قابل فهم باشد را بازنویسی کند!






# طرح‌های خود را بی‌نقص کنید

در این مطلب قصد داریم در مورد یکی از بحران های کنونی در دنیای برنامه نویسی و طراحی نرم افزار صحبت کنیم. با پیشرفت تکنولوژی و افزایش وابستگی افراد و صنایع به کامپیوترها، جامعه ی برنامه نویسان با تقاضای فزاینده ای برای طراحی نرم افزارهای کاربردی مواجه شده اند. به طور طبیعی برنامه نویسی که بتواند کدهای خود را سریع تر بنویسند و نیازهای مشتریان بیش تری را پاسخگو باشد، بهره ی بیش تری از این بازار خواهد برد؛ اما همین موضوع سرعت انجام کارها مسئله ساز شده است و باید ببینیم این افزایش سرعت به چه قیمتی است.

به خاطر داشته باشید که کدنویسی یک کار خلاقانه است و برنامه نویس در هر پروژه، طرحی نو خلق می کند. بنابراین برای خلق یک طرح باکیفیت و معتبر باید از قبل برنامه ریزی انجام شود، تمام جنبه های طرح به دقت بررسی شود، بهترین ابزارهایی که می توان برای اجرای طرح از آن ها استفاده کرد فراهم شوند، و در نهایت به دقت از تمام قابلیت ها و امکانات استفاده شود و پس از اتمام کار، نرم افزار طراحی شده را از جنبه های مختلف آزمود تا تمام باگ ها و نقص های آن برطرف شود. اما بحرانی که دنیای طراحی نرم افزارها با آن مواجه است این است که بسیاری از برنامه نویسان به دلیلی که در بالا به آن اشاره شد برای افزایش سرعت، این رویه ها را نادیده می گیرند.

برخی از برنامه نویسان پس از قبول هر پروژه بلافاصله شروع به کدنویسی می کنند، بدون آن که طرح خاصی را در ذهن داشته باشند. در نوشتن هر قطعه از برنامه در لحظه به آن فکر می کنند که کدام دستور می تواند کار را پیش ببرد. بدون توجه به این که آیا کدهای نوشته شده از کیفیت و زیبایی لازم برخوردارند، و در صورتی که بتوانند تا حدودی به خواسته ی مد نظر مشتری دست یابند، کار را ادامه می دهند و تنها وقتی که به مشکلی برخورد کنند به تغییر کدها فکر می کنند.

در واقع در این موارد برنامه نویس از قابل دسترس ترین امکانات زبان برنامه نویسی مد نظر خود استفاده می کند تا کارش را سرهم بندی کند و به سرعت تحویل مشتری دهد. مشتری ها هم که غالباً چیزی از طراحی نرم افزار نمی دانند تنها به سرعت کار توجه می کنند، و در انتهای کار ناگزیر متحمل نتایجی ناقص و ناکامل می شوند!

شاید این نوع فعالیت ها در کوتاه مدت بتوانند بهره ای برای برنامه نویسان داشته باشند، اما باید بدانید که در بلند مدت برنامه نویسان حرفه ای را از برنامه نویسان غیر حرفه ای متمایز می سازند. بنابراین سعی کنید طرح های ماندگار و بااعتباری خلق کنید. ممکن است مشتری شما تا مدتی بعضی از قابلیت های نرم افزار را به کار نگیرد و درنتیجه متوجه نقایص احتمالی آن نشود، اما این وظیفه ی شما است که نرم افزار خود را به دقت بررسی کنید.

باید بدانید که طراحی یک نرم افزار کامل نمی شود مگر آن که از جنبه های مختلف کیفیت آن را تست کنید و کارایی آن را زمانی که منتشر می شود کنترل کنید. زبان ها و تکنیک های پیشرفته ی طراحی کمک بزرگی به شما می کنند تا طرح های کامل و بدون نقصی خلق کنید و این حقیقت را بدانید که صرف نظر از کدها، طرح های بزرگ و عالی توسط برنامه نویسان بزرگی ایجاد می شوند که خود را وقف خبرگی در حرفه ی خود کرده اند!






# به چیدمان کدها توجه کنید!

اگر تجربه ی کدنویسی برنامه های نسبتاً بزرگ را داشته باشید حتماً متوجه شده اید که بیش تر وقت خود را به جای نوشتن کدهای جدید صرف مرور کدهای قبلی کرده اید تا تغییراتی را که لازم است در آن ها اعمال کنید و اشکالات آن ها را رفع نمایید. یکی از فاکتورهای مهمی که سرعت و کارایی شما را در مرور کدها تعیین می کند چیدمان کدها (Code Layout) است. یک چیدمان خوب با تورفتگی های صحیح و قرار دادن میزان فضای سفید مناسب، تفاوت چشمگیری را در مدت زمانی که طول می کشد تا دستورات یک کد را بررسی کنید و منظور آن ها را بفهمید ایجاد می کند. در این آموزش قصد داریم راه کارهایی را برای بهینه سازی نحوه ی چیدمان و آرایش کدها مطرح کنیم.

پویش کدها را ساده تر کنید:
فرض کنید تیم شما برنامه ای نوشته است که چندین کلاس مختلف دارد. در هنگام اجرای کلاس های برنامه، برای کامپایلر تفاوتی ندارد که در بدنه ی کلاس ابتدا عناصر public تعریف شده اند یا عناصر private، یا این که ابتدا ثابت ها تعریف شوند یا فیلدها و یا متد ها؛ به عبارت دیگر، ترتیب قرار گرفتن اجزای یک کلاس برای کامپایلر تفاوتی ندارد، اما برای شما چه طور؟

باید بدانید که افراد غالباً در تطبیق الگوهای بصری خوب هستند، بنابراین یکی از رویکردهایی که می توانید با دنبال کردن آن، مرور کدهای خود را آسان تر کنید این است که الگویی برای قرار دادن عناصر برنامه در کدهای خود تعریف کنید و تمام اعضای تیم در زمان کدنویسی بخش های مختلف برنامه از آن الگو پیروی کنند. به عنوان نمونه، می‌توان زبان برنامه نویسی پی اچ پی را مثال زد. سایتی تحت عنوان php-fig.org استانداردی تحت عنوان PSR که مخفف واژگان PHP Standard Recommendation است را برای برنامه نویسان پی اچ پی طراحی کرده که علاقمندان با استفاده از این استانداردها می توانند از کدهایی برخوردار شوند که سایر برنامه نویسان پی اچ پی با نگاه کردن به کدهای ایشان کمتر دچار سردرگمی شوند

برای روشن تر شدن این مسئله، از سایر زبان های برنامه نویسی هم چند مثال می زنیم. اکثر برنامه نویسان ++C ابتدا تعریف متدهای public را در بدنه ی کدهای خود قرار می دهند و در زیر آن ها متدهای private را، در حالی که این رویه در کدنویسی به زبان #C کاملاً برعکس است. البته توجه کنید که ما این الگوها را به طور تجربی در زمان یادگیری هر زبان از منابع آموزش دهنده دریافت کرده و ناخواسته از آن ها تبعیت می کنیم و پیروی از آن ها باعث می شود سایر برنامه نویسان هم به راحتی کدهای ما را بخوانند، با این  حال شما می توانید استاندارد مخصوصی برای خود تعریف کنید تا تمام اعضای تیم از آن تبعیت کنند.

چیدمان کدها را طوری تنظیم کنید که منظور کدها را برساند:
یکی از توصیه هایی که همیشه به برنامه نویسان می شود این است که در زمان نام گذاری کلاس ها، متغیرها، متدها، و سایر عناصر برنامه از اسامی با معنا استفاده کنند که تا حد ممکن نشان دهد که هر عنصر برنامه چه کاری انجام می دهد. باید بدانید که چیدمان کدها نیز باید به گونه ای باشد که تا جای ممکن منظور کدها را به روشنی مشخص کند. اگر شما کدهای خود را در یک ویرایش گر ساده ی متن بنویسید زحمت تنظیم چیدمان آن بر عهده ی خودتان است، اما امروزه بیش تر برنامه نویسان از محیط های توسعه ی یکپارچه (IDE) مثل اکلیپس استفاده می کنند که می توانند به صورت خودکار چیدمان کدها را تعیین می کنند. با این وجود توصیه ای که به شما داریم این است که همیشه در نظر داشته باشید که این ابزارها نمی توانند منظور شما را از کدهایی که نوشته اید بفهمند، بنابراین گاهی لازم است به صورت دستی تغییراتی را در چیدمان کدها ایجاد کنید تا منظور خود را شفاف سازید.

چیدمان خود را تا جای ممکن فشرده سازید:
اکثر برنامه نویسان زمانی که در یک محیط توسعه کد می زنند هر کامند یا دستوری را در یک خط جداگانه وارد می کنند، تا جایی که می بینیم بیش تر دستورات حتی تا پایان خط هم ادامه پیدا نمی کنند، بنابراین در پایان کار برنامه ای با خطوط زیادی کد و فضاهای خالی بی شمار دارند. با این حال باید بدانید که بهترین رویکرد این است که چیدمان خود را -تا جایی که به خوانایی کدها لطمه ای نزند- فشرده سازید. مزیت این کار آن است که حرکت میان کدها راحت تر و سریع تر می شود (به خصوص در برنامه های بزرگ)، یا به طور مثال در برنامه های تحت وب حجم داده هایی که از سمت سرور به کلاینت ها ارسال می شود و یا زمان لود شدن صفحات را کاهش می دهد.






# نقد و بررسی کدها

یکی از توصیه های مهمی که همواره به تیم های برنامه نویسی می شود برگزاری جلسات نقد و بررسی کدها است. بسیاری از سازمان ها و شرکت های نرم افزاری روی این موضوع تأکید ویژه ای دارند و برگزاری جلساتی از این دست در آیین نامه های فرآیند توسعه ی نرم افزاری آن ها آمده است و تبدیل به یک فرآیند رسمی اداری شده است، که تیم برنامه نویسی آن ها را ملزم به انجام این کار می کند. چنین تأکیدی دلالت بر اهمیت و کارایی این جلسات دارد. با این وجود، بیش تر تیم های برنامه نویسی به دلیل برخی مسائل تمایل زیادی به شرکت در این جلسات ندارند. در این آموزش قصد داریم به بررسی این مشکلات بپردازیم و راه کارهایی را برای برگزاری بهتر این جلسات ارائه دهیم. برنامه نویسانی که تجربه ی قبلی بدی در این زمینه داشته اند غالباً مسائلی از این دست را مطرح می کنند که:

1- برخی انتقادات و نظرات در مورد کدها این احساس را در برنامه نویس ایجاد می کند که منتقد تنها قصد خراب کردن وجهه ی او را دارد و فرصتی را پیدا کرده است تا به شخصیت او حمله کند و کار او را به باد انتقاد بگیرد.

2- برخی منتقدان به جای بررسی مسائل مهم و اساسی تنها روی ساختار و چیدمان کدها مثل نحوه ی تورفتگی ها تأکید می کنند.

3- در بسیاری از مواقع منتقدان قبلاً کدها را مرور نکرده اند و بدون آمادگی قبلی وارد جلسه می شوند.

4- گاهی تنها یک بخش نمونه از کدها بررسی شده و سایر بخش های مهم نادیده گرفته می شود.

5- در برخی مواقع، تیم بررسی کدها را تا زمانی که بخش اصلی کدها کامل شود به تأخیر می اندازد و پس از آن به دلیل حجم زیاد اطلاعات، مرور کدها دیگر نه امکان پذیر است و نه اثربخش خواهد بود.

6- در بعضی موارد چون اعضا با این دید وارد جلسه می شوند که قرار است تنها یک وظیفه ی اداری را به دستور مدیر انجام دهند، توجه چندانی به جریان جلسه ندارند و انرژی کافی را صرف پیش برد آن نمی کنند.

7- در برخی جلسات هم افرادی به جلسه دعوت می شوند که هیچ ارتباطی با پروژه ندارند و این موضوع کمی برای توسعه دهندگان نگران کننده است چرا که ممکن است نظرات خامی به زبان آورند!

مسائلی از این دست به علاوه خیلی موارد دیگر، موجب عدم تمایل توسعه دهندگان برای شرکت در این جلسات می شود. بنابراین تیم های برنامه نویسی باید به دنبال راه کارهایی برای برطرف کردن این مشکلات باشند تا بتوانند از مزایای آن بهره ببرند.

اولین نکته ای که در مورد جلسات نقد و بررسی باید مورد توجه قرار گیرد این است که هدف چنین جلساتی صرفاً پیدا کردن خطاهای موجود در کدها نیست، بلکه این جلسات باید با هدف به اشتراک گذاری دانش و آگاهی در میان اعضای تیم و برقراری راهبردهای مشترک کدنویسی برگزار شوند. به اشتراک گذاری کدها با سایر برنامه نویسان احساس مالکیت مشترک کدها را در افراد به وجود می آورد. به این ترتیب، هر کسی تلاش می کند در کنار سایرین روی کدها کار کند و به جای آن که صرفاً به دنبال خطاها و غلط گیری باشد سعی کند کدها را بفهمد و منظور و هدف آن ها را دریابد و در پیش برد و بهبود آن ها همکاری کند.

در طی جلسه نقد و بررسی سعی کنید آرام باشید و نظرات خود را با ملایمت بیان کنید و احترام سایرین را حفظ کنید. مطمئن شوید که نقدهای شما سازنده باشد، نه این که با زبان تلخ و صرفاً برای کنایه زدن به دیگران بیان شوند. نقش های متفاوت را در جلسه ی بازنگری بشناسید تا به این ترتیب اجازه ندهید مثلاً نظر مدیر گروه صرفاً به این دلیل که جایگاه سازمانی بالاتری نسبت به سایرین دارد نظرات دیگران را تحت تأثیر قرار دهد یا مانع بیان حقیقت شود. برای مثال یک نوع از تقسیم نقش ها می تواند به این صورت باشد که یکی از اعضا روی مستند سازی، دیگری روی استثنائات، و نفر سوم روی کارکردها و قابلیت استفاده ی کدها متمرکز شود. این شیوه کمک می کند تا مسئولیت نقد و بررسی بر عهده ی همه ی اعضای گروه باشد و همه ی شرکت کنندگان جلسه فعال باشند.

بازنگری کدها را به صورت مرتب در هر هفته انجام دهید. چند ساعت از وقت خود را صرف شرکت در این جلسات کنید. به صورت گردشی منتقدان را انتخاب کنید. به اعضای تازه وارد تیم هم اجازه دهید در این جلسات حضور فعال داشته باشند. شاید تجربه ی کاری آن ها کم باشد، با این حال چون این افراد غالباً به تازگی از دانشگاه فارغ التحصیل شده اند و دانش و آگاهی جدیدی دارند می توانند زاویه ی دید متفاوتی را در گروه ایجاد کنند. البته حضور اعضای حرفه ای و متخصص هم امری ضروری است تا از این طریق بتوانند دانش و تجربه منحصر به فرد خود را به سایرین منتقل کنند. چنین افرادی می توانند کدهای مستعد خطا را با سرعت و دقت بیش تری نسبت به سایرین پیدا کنند.

اگر همه ی کدهای نوشته شده توسط تیم برنامه نویسی از قراردادها و استانداردهای تعریف شده ای پیروی کنند که بتوان آن ها را با ابزارهای خاصی کنترل کرد، جریان بازنگری و مرور کدها راحت تر و سریع تر پیش می رود و از این طریق، تیم در جلسه ی بررسی وقت خود را برای شکل دهی و فرمت بندی کدها تلف نمی کند.

شاید مهم ترین چیزی که به تیم ها کمک می کند تا از مزایای چنین جلساتی بهره مند شوند تبدیل کردن یک جلسه ی خسته کننده و کسالت آور به یک جلسه ی پر نشاط و مفرح باشد. اگر اعضای جلسه احساس کنند که موقعیت آن ها تهدید می شود، به سختی می توان انگیزه ی شرکت در جلسات بعدی را در آن ها ایجاد کرد. جلسات بررسی کدها باید به صورت غیر رسمی و با هدف اصلی انتقال دانش و اطلاعات در میان اعضا برگزار شوند. هرکس باید سعی کند به جای اظهار نظر طعنه آمیز و تحریک کننده، جوی صمیمی و به دور از استرس را ایجاد کند. مطمئن باشید برگزاری جلسات در چنین فضایی کیفیت کدها را بهبود می بخشد، رعایت استانداردها را تضمین می کند، و به عنوان یک ابزار آموزشی ارزشمند دانش و تجربه ی توسعه دهندگان را بالاتر می برد. 






# کامنت‌گذاری را فراموش نکنید

یک برنامه ی کامپیوتری که به خوبی کدنویسی شده است باید این قابلیت را داشته باشد که خودش را به طور شفاف توضیح دهد که هر بخش اش چه کار می کند و رابطه ماژول های مختلف برنامه با یکدیگر به چه شکل است. به طور مثال، برنامه نویس می تواند با انتخاب اسامی مناسب و با معنا برای متغیرها، توابع، کلاس ها، و ...، و همچنین برای برقرار ساختن یک جریان منطقی در دستورات نوشته شده این امکان را فراهم سازد تا کدهای او برای سایر برنامه نویسان خوانا باشد. با این حال اگر مدتی از نوشتن کدها گذشته باشد خود برنامه نویس هم نمی تواند به راحتی و بلافاصله  تنها با خواندن کدهایش هدف آن ها و این موضوع که کدها چه کاری انجام می دهند را بفهمد؛ بنابراین سایر برنامه نویسان هم حتماً در بررسی کدهای ایشان به منظور توسعه یا رفع باگ ها به مشکل بر خواهند خورند. این جا است که نقش توضیحاتی که در بدنه ی کدها قرار می گیرند یا همان Comment ها پر رنگ می شود و اضافه کردن آن ها در میان خطوط کدهای برنامه اهمیت ویژه ای برای برنامه نویسان پیدا می کند. 

بیش تر زبان های برنامه نویسی جدید سطح بالا، ابزارهایی در خود دارند که به خوبی می توانند یک برنامه را مستند سازی کنند. اگرچه استفاده از آن ها یک شروع خوب برای شفاف کردن هدف برنامه است با این وجود قطعاً تمام نیازهای برنامه نویس را رفع نخواهند کرد. مستندسازی باید در سراسر خطوط نوشته شده انجام گیرد تا به وضوح نشان دهد هر قطعه کد چه کاری را انجام خواهد داد. برای آن که بتوانیم توضیحات مناسب را در برنامه ی خود بگنجانیم، باید با شیوه های استاندارد درج کامنت که مشخص می کنند آن ها باید در کدام قسمت از بدنه ی کدها قرار داده شوند و چه اطلاعاتی را در بر داشته باشند آشنا باشیم که در این جا به بعضی از این استایل های استاندارد اشاره می کنیم:

توضیحات سرآمد یا Header Comments:
هر برنامه باید با یک توضیح آغازین همراه باشد که به آن "توضیحات سرآمد" می گوییم. این توضیحات باید حاوی اطلاعاتی از این قبیل باشند: نام برنامه نویس، تاریخ، نام فایلی که برنامه در آن ذخیره می شود، توضیحی در مورد برنامه و نحوه ی اجرا و استفاده از آن. یکی از بهترین استراتژی ها برای نوشتن برنامه های بزرگ و پیچیده تقسیم کردن کدهای آن در مجموعه فایل های جداگانه ای به نام ماژول است که این کار بررسی و توسعه ی کدها را راحت تر می کند (به طور مثال، یک وبسایت میتواند از ماژول های Application, Tutorial, Blog, Wiki, Jobs, Forum و ... تشکیل شده باشد.) در این صورت هر فایل نیاز به توضیحات سرآمد دارد که شامل این اطلاعات می شود: نام برنامه نویس، تاریخ، نام فایلی که کدها در آن ذخیره می شوند. هم چنین در این توضیحات باید نام فایل های دیگری که کدهای ماژول کنونی به آن ها وابسته هستند، مثلاً کلاسی را از فایل دیگری به ارث می برند را هم بیاورید.

توضیحات مربوط به توابع:
هر کلاس پیچیده به بخش های کوچک تری تقسیم می شود که به آن ها توابع می گویند و هر تابع مسئول انجام یک وظیفه ی خاص در برنامه است. پیش از معرفی هر تابع، توضیحاتی مربوط به آن نوشته می شود که اطلاعاتی از این قبیل را شامل می شود: تابع قرار است چه کاری را در برنامه انجام دهد، چه ورودی هایی لازم است که به تابع داده شود تا عملیات خود را اجرا کند، و این که تابع در نهایت چه تغییراتی را ایجاد می کند و خروجی آن چه خواهد بود یا اصطلاحاً این تابع چه چیزی را return می کند یا برمی گرداند.

توضیحات بین خطوط یا Inline Comments:
به غیر از توضیحات سرآمد، لازم است که کامنت هایی را هم در بدنه ی کدهای خود وارد کنید تا به توسعه دهندگان دیگر امکان تصحیح خطاها یا توسعه ی کدها را در آینده بدهند. این گونه توضیحات به دو گروه تقسیم می شوند: توضیحات خطی که در کنار یک خط از سورس کد می آیند و توضیحاتی در مورد آن خط از کد می دهند -مثلاً در یک خط متغیری از جنس عددی تعریف می شود و در توضیح آن، دامنه ای که می تواند اختیار کند را می آوریم- و یا کامنت های بلوکی که شبیه به توضیحات سرآمد، به طور کامل کاری را که یک بخش یا بلوک از کدهای برنامه انجام می دهد را توضیح می دهند.

هشدار توجه داشته باشید که دقت کنید توضیحات شما تنها منظور کدهایتان را روشن کنند نه این که آن ها را تحت الشعاع قرار دهند. بسیاری از برنامه نویسان تازه کار حتی برای واضح ترین و ابتدایی ترین کدها هم کامنت می نویسند که این کاری بس اشتباه است! نوشتن توضیحات زیاد و مفصل می تواند به مانعی برای خوانایی کدهای شما در آینده تبدیل شود.






# تنها توضیحاتی را بنویسید که کدهایتان قادر به شرح آنها نباشند!

پیش از این در مورد "کامنت‌ گذاری را فراموش نکنید" در مورد لزوم افزودن کامنت به سورس کد برنامه ها و مستندسازی آن ها و برخی شیوه های استاندارد برای درج کامنت ها در برنامه ها صحبت کردیم. موضوع مهمی که در این میان وجود دارد توجه به این نکته است که با وجود تمام مزایایی که درج کامنت برای برنامه نویسان ایجاد می کند، گاهی استفاده ی نادرست از آن ها می تواند منجر به ناخوانایی کدها و حتی بروز برخی مشکلات شود. بنابراین آشنایی با نحوه ی کامنت گذاری صحیح اهمیت زیادی دارد و برنامه نویسان باید در کنار سایر مهارت های برنامه نویسی، مهارت نوشتن کامنت مناسب را هم کسب کنند. شاید بتوان گفت بخش عمده ای از این مهارت، آگاهی از این موضوع است که در کجا نباید از کامنت ها استفاده شود.

اگر در ساختار کدها ایرادات و خطاهایی وجود داشته باشد، کامپایلرها، مفسرها و ابزارهایی از این قبیل آن ها را پیدا خواهند کرد. باگ های نرم افزاری هم توسط بازبین ها، تست کننده های نرم افزار، تحلیل گران -و حتی گاهی هم در زمان استفاده توسط کاربران- شناسایی شده و رفع می شوند. بنابراین اغلب نگرانی چندانی در مورد کدهایی که اجرا می شوند وجود ندارد، اما در مورد کامنت ها چنین نیست و از آن جا که این موارد در زمان اجرا نادیده گرفته می شوند، ممکن است وجود یک کامنت اشتباه در میان کدها که می تواند منجر به حواس پرتی و یا حتی ارائه ی اطلاعات غلط به برنامه نویس شود هرگز تشخیص داده نشود.

بعضی از کامنت ها از نظر فنی مشکلی ندارند با این حال هیچ ارزشی برای برنامه نویس ایجاد نمی کنند. مثلاً کامنت هایی که دقیقاً اطلاعاتی را که از خود کد می توان به دست آورد را تکرار می کنند و تنها باعث شلوغی برنامه می شوند. یکی از کاربردهای کامنت قرار دادن در سورس کد این است که اگر بخواهیم قطعه کد خاصی در برنامه اجرا نشود آن را تبدیل به کامنت می کنیم تا در زمان اجرا نادیده گرفته شود. وجود چنین کدهایی نیز برنامه را شلوغ می کند و هیچ ارزشی برای برنامه نویس نخواهد داشت. به این موارد، باید کامنت های مربوط به نسخه و تاریخچه ی نرم افزار را هم افزود، چرا که این موارد به صورت دقیق تر توسط ابزارهای کنترل نسخه مشخص می شوند.

یکی از معایبی که وجود بیش از حد کامنت اشتباه یا بی ارزش دارد این است که باعث می شود برنامه نویس ترجیح دهد تمام کامنت ها را نادیده بگیرد و با استفاده از ابزارها و امکانات مختلف آن ها را بپوشاند یا از میان کدهای برنامه حذف کند تا درگیر خواندن توضیحات بی ارزش نشود. واضح است که این کار باعث از دست رفتن کامنت های ضروری و ارزشمند نیز می شود، بنابراین بهترین کار این است که در زمان درج کامنت، دقت کنیم که با آن ها مثل کدهای خود رفتار کنیم. تنها کامنت هایی را درج کنیم که ارزشی برای خواننده ی کدها داشته باشند و در غیر این صورت آن ها را حذف یا مجدداً اصلاح کنیم.

وقتی صحبت از کامنت ارزشمند می کنیم، باید بدانیم چه چیزی ارزش آفرین است. مفهوم کامنت ارزشمند -در کدنویسی- به چیزی اطلاق می شود که بیان کننده ی مواردی است که کدها قادر به بیان آن نباشند. درج توضیحات می تواند انگیزه ای باشد برای تغییر ساختار کد و قراردادهای کدگذاری به طوری که کدها بتوانند نحوه ی کار خودشان را تشریح کنند. به طور مثال، شاید خواندن توضیحات مربوط به عملکرد یک کلاس یا تابع باعث شود نام مناسب تری برای آن انتخاب کنید که این نام گویای تمام توضیحات باشد. یا به جای توضیح در مورد بخش های مختلف یک تابع تلاش کنید آن را به توابع کوچکتری تقسیم کنید که نام هر یک از این توابع تمام توضیحات بخش های قبلی را بیان کند. در نهایت این که باید تلاش کنیم در کامنت های خود تنها نکات لازمی را بگنجانیم که کدها نمی توانند آن ها را بیان کنند، نه نکاتی را که کدها آن ها را بیان نکرده اند، و تا حد ممکن باید از ظرفیت کدها استفاده شود، آن گاه به سراغ کامنت گذاری برویم.






# از کدهای قبلی خود در شرایط مناسب مجدداً استفاده کنید

بسیاری از توسعه دهندگان حرفه ای نرم افزارها عادت دارند کدهایی بنویسند که اصطلاحاً Reusable یا دارای قابلیت استفاده ی مجدد باشند. وجود قابلیت استفاده ی مجدد در یک قطعه کد باعث می شود که بتوانیم در کدنویسی چندین برنامه ی مختلف از آن استفاده کنیم. وقتی می گوییم برنامه نویسان حرفه ای چنین قابلیتی را در کدهای خود وارد می کنند به نحوی مثبت بودن چنین چیزی را عنوان می کنیم، با این حال باید این موضوع به دقت بررسی شود و ببینیم که آیا این کاری تحت هر شرایطی درست است یا خیر؟

آیا استفاده ی مجدد از کدها همواره و تحت هر شرایطی مورد تأیید است؟ برای پاسخ به این سؤال باید از مزایا و معایب چنین کاری اطلاع پیدا کنیم و آن گاه با سبک و سنگین کردن شرایط، بین استفاده مجدد از کدهای از قبل نوشته شده و نوشتن کدهای جدید یکی را انتخاب کنیم. از این رو در این آموزش قصد داریم در مورد مزایا و معایب استفاده ی مجدد از کدها صحبت کنیم.

مزایا
استفاده ی مجدد از کدها زمان کدنویسی را کاهش می دهد، که این امر موجب کاهش هزینه های یک پروژه ی برنامه نویسی خواهد شد. فرض کنید پیش از این خود شما یا تیم برنامه نویسی دیگری روی یک مسئله کار کرده و پاسخ بهینه ای برای آن یافته اید و اکنون این پاسخ در دسترس شما است. بنابراین دلیلی وجود ندارد که شما بخواهید مجدداً به دنبال جواب برای یک مسئله ی حل شده باشید.

استفاده ی مجدد از کدهایی که قبلاً نوشته و امتحان شده اند باعث می شود میزان باگ های احتمالی برنامه تا حد زیادی کاهش پیدا کند. به طور کلی هر چه در یک برنامه خطوط کد بیش تری نوشته شود، احتمال وجود خطا در میان آن کدها بیش تر می شود. وقتی از یک قطعه کد در چندین برنامه ی مختلف استفاده می شود به نوعی بارها و بارها آن بخش مشترک در تمام برنامه ها تست می شود و به مراتب احتمال وجود خطا در آن کاهش پیدا می کند.

معمولاً کدهایی که قابلیت استفاده ی مجدد دارند در قالب کتابخانه های نرم افزاری جداگانه تقسیم بندی می شوند، به نحوی که هر برنامه نویس می تواند بر اساس نیاز خود از این کتابخانه های آماده استفاده کند. مزیت این کار در آن است که هر برنامه نویس می تواند با توجه به نقاط قوت خود در یک زمینه ی خاص به صورت تخصصی کدنویسی کند. به طور مثال متخصصین بخش امنیت می توانند روی کدهای مربوط به این حوزه کار کنند و با تولید کتابخانه های قدرتمند نرم افزاری در زمینه ی امنیت آن ها را با دیگر برنامه نویسان به اشتراک بگذارند، این در حالی است که مثلاً متخصصان UI روی مسائل مربوط به طراحی و بهینه سازی واسط های کاربری متمرکز می شوند. استفاده ی مجدد از کدها به طور مناسب و کارآمد می تواند به جلوگیری از تکرارهای غیر ضروری و دستورات زائد کمک کند.

معایب
با وجود تمام مزیت هایی که استفاده ی مجدد از کدها برای ما دارد بسته به شرایط مختلف امکان دارد این کار نه تنها فایده ای برای ما نداشته باشد، بلکه ضررهایی را هم به برنامه وارد کند.

فرض کنید از یک کتابخانه از کدها در چند بخش مختلف از برنامه استفاده کنیم. این کار باعث می شود که وابستگی کدهای این بخش ها به هم زیاد شوند. اگر بخواهیم کدهای مشترک بعضی از این قسمت ها را تغییر دهیم یا اصلاح کنیم باید مراقب باشیم که این کار چه تأثیری روی سایر بخش ها می گذارد.

این احتمال وجود دارد که کتابخانه یا فریم ورکی که می خواهید از آن در برنامه ی خود مجدداً استفاده کنید سرعتی پایین تر از حد انتظار داشته باشد و این بستگی به زبان برنامه نویسی یا پلتفرمی دارد که شما روی آن کار می کنید.

اگر شما از کدهایی استفاده کنید که قبلاً توسط برنامه نویسان دیگر نوشته شده باشند مسائل مربوط به امنیت و میزان قابل اعتماد بودن آن ها و مسائل مربوط به مجوزهای استفاده مطرح می شود. به علاوه ارزیابی این کدها معمولاً زمان بر است و این امکان وجود دارد که شما بعد از گذشت یک زمان طولانی متوجه ضعف در طراحی و باگ های آن کدها شوید.

مدیریت کدهایی که بین برنامه های مختلف به اشتراک گذاشته می شوند می تواند هزینه ی اضافی برای برنامه ایجاد کند. علاوه بر این، گاهی اوقات پیاده سازی و همگام سازی این کدها با کدهای خودتان بیش از حد زمان بر است و کار زیادی را طلب می کند. به هر حال شما به عنوان یک برنامه نویس باید این مهارت را پیدا کنید که با در نظر گرفتن تمام جوانب انتخاب کنید که آیا می خواهید چرخ را دوباره اختراع کنید، یا با کمی اصلاح و تطبیق آن با سورس کد خود، مجدداً از آن استفاده کنید.






# همواره در حال یادگیری موضوعات جدید باشید

زندگی ما در عصر تکنولوژی بسیار هیجان انگیز و جالب است. فناوری ها به سرعت در حال رشد هستند و هر روز اخباری از ابتکارات و دستاوردهای جدید در عرصه ی علم و تکنولوژی منتشر می شود. از سوی دیگر، شاهد آن هستیم که رشد تکنولوژی تأثیر زیادی هم در فرآیندهای یادگیری داشته است؛ به طور مثال اینترنت بستری را فراهم کرده است که کاربران را قادر می سازد به شبکه ی عظیمی از اطلاعات دسترسی پیدا کنند و با نوآوری های جدید آشنا شوند.

این سرعت بالای رشد علمی و دسترسی آسان تر به منابع علمی سبب افزایش تعداد رقبای شغلی به ویژه در میان برنامه نویسان شده است. آن چه بیش از هر چیز دیگر اهمیت دارد آن است که ما متوجه این تغییرات و پیشرفت ها باشیم و بدانیم برای ادامه ی کار و رقابت با دیگر برنامه نویسانی که در بازار برنامه نویسی مشغول به فعالیت هستند، لازم است که دانسته های خود را دائماً به روز کنیم که در غیر این صورت روزی دانش ما آن قدر قدیمی می شود که عملاً در هیچ جا کاربرد نخواهد داشت.

اگر به این باور رسیدیم که امروز هر اندازه هم که ما در کار خود حرفه ای باشیم در آینده ای نزدیک این سطح از اطلاعات و مهارت بسیار اندک خواهد بود و نسبت به سایر برنامه نویسان برای ما مزیت رقابتی ایجاد نخواهد کرد، باید به دنبال راه کارهایی برای افزایش دانش و مهارت خود باشیم. خوشبختانه برخی از کارفرمایان برای حمایت از منابع انسانی و کمک به کسب و کار خود با صرف هزینه و زمان اقدام به برگزاری دوره های آموزشی و بالا بردن سطح علمی و مهارتی نیروهای کار خود می کنند. با این حال شاید شما شانس کار با چنین تیم هایی را نداشته باشید و مجبور باشید خود به دنبال راه کاری برای یادگیری موضوعات جدید باشید.

در این جا قصد داریم بعضی از روش های کاربردی و منابع مفید را به شما معرفی کنیم تا بتوانید با استفاده از آن ها سطح دانش و مهارت خود را به عنوان یک برنامه نویس افزایش دهید. لیست این پیشنهادات به قرار زیر است:

1- کتاب و مجله بخوانید، از پست های وبلاگی، سایت ها، و فیدهای توئیتر که اخبار و موضوعات جدید حوزه ی نرم افزار و آی تی را بررسی می کنند بازدید کنید. سعی کنید پیوسته با جامعه ای از برنامه نویسان در ارتباط باشید.
2- اگر واقعاً می خواهید با یک تکنولوژی جدید آشنا شوید، دست خود را به آن آلوده کنید! شروع به کدنویسی کنید. تلاش کنید با امتحان کردن نرم افزارهای جدید به آن ها مسلط شوید.

3- سعی کنید همیشه با کسانی کار کنید که چیزی بیش تر از شما بدانند، چون کار کردن در کنار افراد با هوش تر و با تجربه تر و نظارت آن ها بر کار شما هم انگیزه ی یادگیری را در شما ایجاد می کند و هم در تعامل با آن ها می توانید درس های زیادی بیاموزید و اطلاعات مفیدی به دست آورید. وقتی شما تنها در کنار افرادی باشید که سطحی پایین تر از شما دارند، هم انگیزه ی رقابتی خود را برای یادگیری از دست می دهید و هم این که احتمالاً تمام وقت خود را باید صرف آموزش به آن ها کنید که به نوعی مانع یادگیری موضوعات جدید خواهد بود.

4- از کمک منتورهای مجازی استفاده کنید. افراد شناخته شده ای در فضای وب فعالیت می کنند که نویسندگان و توسعه دهندگان بزرگی هستند. فعالیت ها و نوشته های آن ها را در وب سایت ها و وبلاگ های ایشان دنبال کنید. بسیاری از این افراد به سؤالات دیگران پاسخ می دهند و شما می توانید از راهنمایی چنین کسانی که شاید حتی در قاره ای دیگر زندگی کنند به صورت مجازی استفاده کنید.

5- شروع به یادگیری دقیق فریم ورک ها و کتابخانه هایی که از آن ها استفاده می کنید نمایید. آگاهی از روش دقیق کار یک چیز باعث می شود بفهمید که چگونه می توانید استفاده ی بهتری از آن داشته باشید. اگر آن ها متن باز باشند که بخت با شما یار است. به جستجو در سورس کد آن ها بپردازید، چون به هر حال توسط افرادی با هوش و با تجربه نوشته شده اند و خواندن آن ها دید بهتری به شما خواهد داد و الهام بخش ایده های جدیدی در ذهن شما خواهد بود. سعی کنید سورس کد سایت هایی را که طراحی خوبی دارند مشاهده کنید تا با نحوه ی طراحی آن ها نیز آشنا شوید.

6- زمانی که اشتباهی انجام می دهید، به باگی در میان کدهای خود برخورد می کنید، یا با مشکلی در کدنویسی برنامه ی خود مواجه می شوید سعی کنید بفهیمد واقعاً چه اتفاقی افتاده است. ممکن است قبل از شما کسی با چنین مشکلی رو به رو شده باشد و بعد از یافتن راه حل، آن را روی فضای اینترنت به اشتراک گذاشته باشد. در این موارد جستجو در گوگل -و همچنین جستجو در سایت Stack Overflow- به شما کمک زیادی خواهد کرد. به علاوه سعی کنید شما هم یافته های خود را در اختیار دیگران قرار دهید.

7- به گفته ی یک طنزپردازی: "کسانی که بر موضوعی تسلط کامل دارند از آن استفاده می کنند و با آن کار می کنند و کسانی که چیزی از آن نمی دانند همان موضوع را درس می دهند!" واقعیت این است که یکی از راه های یادگیری یک موضوع تدریس آن و صحبت کردن در مورد آن موضوع است. وقتی قرار باشد عده ای مخاطب شما باشند و از شما در مورد مطلبی سؤال بپرسند، انگیزه ی زیادی را برای یادگیری در شما ایجاد خواهد کرد. سعی کنید در مورد موضوعات و تکنولوژی های جدید اطلاعات به دست آورید و این اطلاعات را در جمع دوستان و همکاران به دیگران منتقل کنید.

8- موضوعی را که به آن علاقمند هستید انتخاب کنید و سعی کنید با گروهی از افراد به مطالعه ی جمعی آن موضوع بپردازید. مطمئن باشید بواسطه ی همکاری با دیگران و استفاده از نظرات و تجربیات آن ها تاثیر این یادگیری جمعی به مراتب بیش تر از یادگیری انفرادی است. خوشبختانه با ظهور شبکه های گسترده ی اجتماعی می توان این فعالیت ها را در قالب تیمی و به صورت مجازی انجام داد.

9- شرکت در کنفرانس ها هم گزینه ی مناسبی برای اطلاع از یافته ها و موضوعات علمی جدید است. حتی اگر امکان حضور فیزیکی در چنین کنفرانس ها و سمینارهایی را ندارید می توانید بسیاری از آن ها را به صورت آنلاین و بدون پرداخت هیچ هزینه ای دنبال کنید.

10- آیا تا به حال از ابزارهای تحلیل کدهای برنامه استفاده کرده اید، یا توجهی به پیغام های اخطار محیط توسعه ای که در آن کدنویسی می کنید داشته اید؟ یک راه مناسب برای یادگیری این است که بفهمید آن ها چه می گویند و چرا چنین تحلیل هایی را روی کدهای شما دارند.

11- به این توصیه ی برنامه نویسان حرفه ای عمل کنید که می گویند هر سال یک زبان برنامه نویسی جدید یاد بگیرید. حداقل با یک ابزار یا تکنولوژی جدید آشنا شوید و شیوه ی به کارگیری آن را بیاموزید. دانش در مورد تکنولوژی های جدید ایده های تازه ای را برای استفاده ی بهتر از تکنولوژی های کنونی به شما خواهد داد.

12- این روزها همه می دانند که صرف یادگیری زبان های برنامه نویسی یا دانش استفاده ازتکنولوژی های جدید برای شما مزیت رقابتی ایجاد نخواهد کرد. شما باید با حوزه ای که در آن کار می کنید آشنایی کامل داشته باشید تا بتوانید نیازهای مشتریان خود را بشناسید. آگاهی از این که چه طور کارکرد مؤثرتر و نقش سازنده تری در محیط کاری داشته باشید نیز مفید خواهد بود. برای مثال این روزها بیش تر شرکت ها به دنبال برنامه نویسانی هستند که در کنار مهارت های کدنویسی با روش های Agile یا چابک نیز آشنایی داشته باشند.

13- اگر شما هم جزء کسانی باشید که بخش زیادی از زمان خود را در رفت و آمد و ترافیک شهری از دست می دهند، می توانید با گوش کردن به فایل های صوتی و پادکست های آموزشی که به وفور روی اینترنت قابل دسترسی هستند این زمان های تلف شده را تبدیل به فرصت مناسبی برای یادگیری و کسب اطلاعات جدید نمایید.

14- شاید بد نباشد که به ادامه ی تحصیل در دانشگاه هم فکر کنید. گرچه بسیاری از افراد عقیده دارند دانشگاه های کشور بازدهی مطلوبی ندارند و خروجی آن ها برنامه نویسانی که آماده ی ورود به بازار کار باشند نیست، با این وجود باید بدانید که اولاً کلاس های دانشگاهی قطعاً یک پایه ی علمی مستحکم برای اطلاعات شما ایجاد می کنند، ثانیاً هر کدام از ما می توانیم با انگیزه و علاقه ی خود تا حد زیادی به پویایی محیط های دانشجویی و نزدیک کردن صنعت و دانشگاه کمک کنیم.

به هر حال تکنولوژی به سرعت در حال تغییر است و اگر بخواهیم از این قافله عقب نمانیم باید در کنار کار زمانی را هم به یادگیری دانش و اطلاعات جدید اختصاص دهیم. این زمان هر اندازه هم که کم باشد، حتی در حد چند ساعت در هفته، می تواند نتایج مفیدی را به بار آورد.






# ویژگی‌های یک API با طراحی مناسب

امروزه بعید به نظر می رسد که کسی در دنیای برنامه نویسی دستی بر آتش داشته باشد اما اصطلاح API به گوش او نخورده باشد! اگر شما به عنوان یک برنامه نویس با ای پی آی ها کار کرده باشید از اهمیت آن ها مطلع هستید، با این حال سایر افراد ممکن است بپرسند که «اصلاً ای پی آی ها چه هستند و چرا تا این حد مورد توجه قرار می گیرند؟» در این آموزش به دنبال پاسخ دادن به این پرسش ها هستیم و می خواهیم ببینیم یک API خوش ساخت از چه ویژگی هایی برخوردار است.

اگر بخواهیم تعریف ساده ای از API که مخفف عبارت Application Programming Interface ی «واسط برنامه نویسی اپلیکیشن»است داشته باشیم باید بگوییم که ای پی آی ها مجموعه مقرراتی هستند که مشخص می کنند چه طور یک اپلیکیشن می تواند با اپلیکیشن دیگری ارتباط برقرار کند. زمانی که از یک پی سی یا لپ تاپ استفاده می کنیم، ای پی آی ها همان چیزهایی هستند که انتقال اطلاعات را بین برنامه ها امکان پذیر می کنند، برای مثال ای پی آی های سیستمی، اجرای برنامه ای مانند آفیس ورد را روی سیستم عامل ویندوز امکان پذیر می سازند.

همان طور که از نام API مشخص است، آن ها مانند یک رابط بین برنامه نویسان و یک اپلیکیشن هستند؛ به این صورت که اگر برنامه نویس برای پیش برد برنامه ی خود نیاز به اطلاعاتی از اپلیکیشن دیگری داشت، این واسط ها به او می گویند که می تواند برای دریافت چه اطلاعاتی درخواست دهد، چگونه درخواست خود را مطرح کند، و چگونه اطلاعات خود را دریافت کنند. در واقع API هر اپلیکیشن درخواست های مجاز را از سایر برنامه ها تحویل می گیرد، به اپلیکیشن مورد نظر می فرستد، آن گاه اطلاعات را دریافت می کند و تحویل برنامه های دیگر می دهد.
دروافع API ها در فضای وب هم برای سرویس هایی مانند گوگل مپ یا فیسبوک این امکان را فراهم می کنند تا این برنامه ها به اپلیکیشن های دیگر اجازه دهند که آن ها را اجرا کنند. برای مثال یک اپلیکیشن Yelp با استفاده از ای پی آی ها می تواند نزدیک ترین رستوران در اطراف کاربر را روی نقشه های گوگل مپ نشان دهد. یا یک اپ بازی می تواند با سرویس ابری دراپ باکس ارتباط برقرار کند تا تاریخچه ای از نتایج بازی های کاربر روی حافظه ی ابری این سرویس ذخیره شود، بدون آن که توسعه دهنده مجبور باشد یک ذخیره ساز ابری مخصوص اپلیکیشن خود طراحی کند.

اکنون باید ببینیم که ای پی آی ها چگونه این ارتباطات را امکان پذیر می کنند. در حقیقت ای پی آی ها با استفاده از روشی محدود شده و در چارچوب قوانینی خاص با "افشای" برخی از توابع داخلی یک برنامه به محیط خارج از آن تمام این کارها را انجام می دهند. با این کار بدون آن که نیاز باشد توسعه دهنده ها تمام سورس کدهای برنامه ی خود را در اختیار دیگران قرار دهند، اپلیکیشن ها می توانند با به اشتراک گذاری بخشی از داده ها با هم ارتباط برقرار کرده و تعامل داشته باشند.

درواقع API ها با محدود کردن دسترسی برنامه های خارجی به بخش خاصی از قابلیت های یک برنامه -که اغلب هم این سطح از دسترسی کافی است- تمام اطلاعات مورد نیاز سایر اپلیکیشن ها برای ارتباط با نرم افزار مورد نظر را فراهم می کنند. در حقیقت می توان API ها را هم چون پنجره ای به داخل یک برنامه تصور کرد.

با توجه به تمام مثال هایی که از کاربرد API های مختلف بیان کردیم، به نظر می رسد که متوجه اهمیت آن ها در حوزه ی توسعه ی نرم افزار شده باشیم. همان طور که اعضای یک جامعه برای زندگی در کنار هم به یکدیگر نیاز دارند و باید با هم در تعامل باشند، هر چند که در بسیاری از موارد نیازی نیست یک شناخت عمیق از هم داشته باشند -مثلاً برای خرید سبزی، شما لازم نیست که در مورد زندگی خصوصی سبزی فروش محلتان اطلاعات داشته باشید، کافی است که بدانید چه کسی سبزی فروش است و مغازه ی او کجا است- این روزها اپلیکیشن های مختلف نیز به شدت نیاز به تعامل با هم دارند و برای این کار لازم است اطلاعاتی را در مورد هم داشته باشند. ای پی آی ها که تأمین کننده ی این اطلاعات هستند، علاوه بر حفظ امنیت اپلیکیشن ها، با فراهم کردن اطلاعات لازم و حذف داده های غیر ضروری، دقت و سرعت توسعه ی نرم افزارها را بالا می برند. حال باید ببینیم خصوصیات یک API خوب کدامند؟ می توان گفت که یک ای پی آی خوب، ای پی آی یی است که:

 - یادگیری آن آسان باشد؛
- کاربرد آن حتی بدون استفاده از اسناد، باز هم آسان باشد؛
- امکان استفاده ی نادرست از آن کم باشد؛
- خوانایی و امکان نگهداری و پشتیبانی از کدهایی که از آن استفاده می کنند بالا باشد؛
- برای رفع نیازهای ارتباطی نرم افزارهای دیگر با آن به اندازه ی کافی قدرتمند باشد؛
- توسعه و گسترش آن ساده باشد؛

برای این که چنین خصوصیاتی را در یک ای پی آی ایجاد کنیم لازم است در زمان طراحی آن قواعدی را رعایت کنیم. از جمله این قواعد می توان به موارد زیر اشاره کرد:

1- هر API یک وظیفه دارد و باید آن را به بهترین نحو ممکن انجام دهد. کارکرد یک API باید به گونه ای باشد که بتوان آن را به ساده ترین صورت ممکن بیان کرد. به طور مثال می گوییم وظیفه ی یک ای پی آی این است که امکان استفاده از شبکه ی اجتماعی یوتیوب را در داخل اپلیکیشن ها فراهم می کند. اگر نتوانید وظیفه ی یک API را به راحتی شرح دهید به این معنا است که مشکلی وجود دارد، و برای رفع آن می توانید طراحی ای پی آی را در قالب ماژول های کوچک تر پیاده سازی کنید، که هر کدام وظیفه ی خاصی داشته باشند.

2- باید API تا حد ممکن کوچک باشند؛ هر چه اطلاعات کمتری افشا شود بهتر است. با این حال باید دقت داشته باشیم که ای پی آی طراحی شده حاوی تمام اطلاعات ضروری باشد. تنها به خاطر داشته باشید که همیشه امکان اضافه کردن اطلاعات وجود دارد، اما حذف اطلاعات افشا شده غیر ممکن است!

3- این API ها نباید از پیاده سازی های مختلف تأثیر بگیرند. به عبارت دیگر، روش استفاده ی واحدی از آن API وجود داشته باشد.

4- دسترسی ها به هر چیز را در پایین ترین سطح ممکن قرار دهید. کلاس ها و آبجکت ها را تا جای ممکن private کنید. کلاس های public نباید فیلدهای public داشته باشند (به استثنای ثابت ها).

5- در زمان طراحی و ساخت API سعی کنید که از کاربران نهایی خود فیدبک بگیرید تا مطمئن شوید محصول نهایی شما تمام نیازهای معقول آن ها را برآورده می کند. به علاوه، باید بدانید که طراحی ای پی آی ها نیاز به یک کار تیمی دارد و به شدت پیشنهاد می شود که تمام اعضای تیم طراحی نرم افزار روی طراحی ای پی آی هم کار کنند.

6- در طراحی API از تکرارهای بیش از حد اجتناب کنید. برای مثال اگر دو متد یک کار را انجام می دهند، نباید از هر دوی آن ها استفاده کنیم. این کار باعث سردرگمی کاربران می شود.

7- از پروتکل امن SSL استفاده کنید. بیش تر کاربران از نقاط دسترسی غیر رمز گذاری شده برای دسترسی به اینترنت استفاده می کنند که امکان هک شدن آن ها را به راحتی فراهم می کند.

نکته SSL مخفف واژگان Secure Sockets Layer به معنی «لایه ی سوکت های ایمن» یکی از پروتوکل های رمزنگاری استاندارد است که به منظور تأمین امنیت ارتباطات اینترنتی توسط شرکت Netscape به منظور انتقال داده‌های خصوصی از طریق اینترنت توسعه داده شد. این پروتوکل امنیت انتقال داده‌ها را در اینترنت برای مقاصدی همچون درگاه های بانک، تصدیق اطلاعات کاربری، انتقال اطلاعات هویتی و دیگر داده‌های حساس امکان پذیر می سازد. به طور خلاصه، کارکرد پروتوکل اس اس ال به این شکل است که مابین کاربر و سایت -که به طور معمول نماینده ی کاربر مرورگری است همچون فایرفاکس یا گوگل کروم و نماینده ی سایت هم وب سرور است- یک لینک رمزنگاری شده ایجاد می‌گردد. در شرایط عادی، اطلاعاتی از این دست به صورت Plain Text یا «متن ساده» مابین مرورگرها و وب سرورها رد و بدل می‌شوند که بسیار آسیب‌پذیر است اما در اس اس ال، کلیه ی داده های رمزنگاری می شوند و به طور کلی، یو آر ال هایی که نیاز به ارتباط اس اس ال دارند، به جای http، با https شروع می شوند.

-از نوشتن مستندات غفلت نکنید. این موضوعی است که بسیاری از برنامه نویسان آن را نادیده می گیرند یا به درستی انجام نمی دهند. مستندات خود را به صورت دقیق و ساده تهیه کنید. بهترین تاکتیک برای این کار این است که فکر کنید می خواهید موضوع را برای یک کودک 10 ساله شرح دهید. از نوشتن در مورد هیچ مرحله ای اجتناب نکنید و هرگز این پیش فرض را نداشته باشید که چون موضوعی برای شما بدیهی است دیگران هم باید آن را بدانند. مستندسازی مناسب به ویژه در شرایطی که فرآیندها پیچیده اند کمک بزرگی به کاربران خواهد کرد.

-واقع گرا باشید. به هر حال با وجود رعایت تمامی قواعد و مشورت اعضای تیم با یکدیگر باز هم امکان اشتباه و نادیده گرفتن یک سری مسائل وجود دارد. اما آن چه باید بدانید این است که در نهایت شما نمی توانید رضایت همه ی افراد را به دست آورید.

در انتها باید این نکته را به شما یادآوری کنیم که هر چند API ها ابزارهایی سودمند در دست برنامه نویسان هستند اما استفاده از آن ها با چالش هایی همراه است. باید بدانید که اگر یک API امروز در دسترس کاربران قرار دارد دلیلی ندارد که این دسترسی برای همیشه وجود داشته باشد. برای مثال چند سال پیش شرکت توئیتر دسترسی کاربران را به ای پی آی های خود محدود کرد.

علاوه بر این، کمپانی هایی که API های خود را در دسترس کاربران قرار می دهند ممکن است بعد از مدتی به ارائه ی خدمات خود پایان دهند. در این صورت اگر اپلیکیشن شما وابسته به API های این شرکت ها باشند با مشکل مواجه خواهند شد. برای مثال فرض کنید شرکت گوگل تصمیم بگیرد ارائه ی خدمات سرویس گوگل مپ را متوقف کند، در این صورت کار اپلیکیشن Yelp نیز متوقف خواهد شد. به هر حال با وجود تمام چالش هایی از این دست، توسعه دهندگان علاقه ی زیادی به استفاده از API ها دارند و هر روز شاهد گسترش ای پی آی های مختلف هستیم.






# از ابتدای کار توسعهٔ اپلیکیشن خود روی فرآیند نصب و دیپلوی آن به طور پیوسته کار کنید

استقرار نرم افزار یا Software Deployment فرآیند آماده سازی یک برنامه برای نصب و پیکربندی آن روی سیستم های مشتریان است. یک اپلیکیشن جدید ممکن است روی سیستم شما که توسعه دهنده ی آن هستید به خوبی کار کند، اما این به معنای آن نیست که واقعا برای کار روی سایر سیستم ها آماده شده باشد. بسیاری از قابلیت ها وجود دارند که ممکن است شما اصلاً به آن ها احتیاج پیدا نکرده باید، با این حال سایر کاربران به آن ها نیاز دارند و شما مسئول ایجاد این قابلیت ها در نرم افزار خود هستید تا به نیاز مشتریانتان به خوبی پاسخ دهید. وجود این قابلیت ها از این نظر مهم است که نرم افزار شما را اصطلاحاً کاربر پسندتر می کند و به شما کمک خواهد کرد تا از سرقت نرم افزار خود جلوگیری کنید. در این آموزش به معرفی گام های فرآیند استقرار نرم افزار و برخی الزامات آن می پردازیم.

گفتیم فرآیند استقرار نرم افزار به تمام اقدامات لازمی اطلاق می شود که با انجام آن ها، کاربران می توانند به راحتی از یک نرم افزار استفاده کنند. از آن جا که هر سیستم نرم افزاری قابلیت های منحصر به فرد خود را دارا است، نمی توان در مورد پروسه ی دقیق هر فعالیت چیزی گفت. از این رو می توانیم دیپلویمنت نرم افزار را یک فرآیند کلی در نظر بگیریم که باید بر اساس خصوصیات و الزامات خاص هر سیستمی شخصی سازی شود. با این وجود می توانیم به طور خلاصه توضیحاتی کلی در مورد برخی از اقدامات این فرآیند به شرح زیر داشته باشیم:

توزیع یا Release:این فعالیت در حقیقت واسطی بین فرآیند توسعه و فرآیند دیپلویمنت نرم افزار است که شامل تمام عملیات مورد نیاز برای آماده سازی یک نرم افزار به منظور یکپارچه سازی و انتقال آن به سیستم کاربران می شود. بنابراین توزیع یک سیستم نرم افزاری باید تمام منابع لازم را به همراه داشته باشد تا نرم افزار به درستی روی سیستم کاربران اجرا شود. به طور کلی توزیع یک نرم افزار شامل پکیجی از اجزای مورد نیاز برای راه اندازی سیستم، توضیحات راهنما در مورد نحوه ی نصب سیستم، و اطلاعاتی در مورد خصوصیات، موارد استفاده و جامعه ی هدف سیستم نرم افزاری است.

 نصب یا Installation: این مرحله اولین اقدام برای دیپلویمنت نرم افزار روی سیستم مشتریان است. معمولاً این مرحله پیچیده ترین مرحله ی دیپلویمنت نرم افزار است، چرا که برای این کار باید تمام منابع مورد نیاز برای استفاده از سیستم به طور مناسب گردآوری شوند.

فعال سازی یا Activation : این فعالیت مربوط به راه اندازی اجزایی از سیستم می شود که برای اجرای نرم افزار مستقر شده ابتدا باید آن ها اجرا شوند. معمولاً فعال سازی با استفاده از پنجره های راهنما و آیکون ها و دکمه های گرافیکی طراحی شده صورت می گیرد. باید دقت داشته باشیم که در مرحله ی فعال سازی ممکن است نیاز به فعال بودن یک سری نرم افزارهای دیگر داشته باشیم. برای مثال اگر در این مرحله یک فایل فشرده ی زیپ داشته باشیم، برای باز کردن آن نیاز به یک نرم افزار نصب شده ی دیگر روی سیستم خواهیم داشت که فایل های زیپ را بخواند.

غیر فعال سازی یا De-Activation :اقدامی درست بر خلاف فعالیت قبلی که اجرای تمام اجزای نرم افزار را متوقف می کند. این عملیات معمولاً قبل از فعالیت های دیگر فرآیند دیپلویمنت مانند به روز رسانی سیستم اتفاق می افتد.

به روز رسانی یا Update: این فعالیت در حقیقت حالت خاصی از نصب نرم افزار است که معمولاً پیچیدگی کم تری نسبت به عملیات نصب دارد، چرا که نرم افزار قبلاً یک بار روی سیستم نصب شده است.

پاک کردن نرم افزار نصب شده یا De-Installation: زمانی پیش می آید که یک کاربر دیگر نیازی به یک نرم افزار ندارد و می خواهد آن را از سیستم خود پاک کند. در این شرایط باید تمام اجزای نصب شده به درستی غیر فعال شده، سپس از روی سیستم پاک شوند. در این مورد باید دقت لازم صورت بگیرد که آسیبی به سایر منابع و فایل های مشترک وارد نشود.

منسوخ شدن یا Obsolescence: در نهایت یک نرم افزار پس از مدتی منسوخ می شود و سازندگانش دیگر از آن پشتیبانی نخواهند کرد. دقیقاً مانند زمانی که نسخه ی نصب شده را غیر فعال می شود، باید مراقب باشیم که مشکلی برای سایر اجزای سیستم به وجود نیاید. یکی از الزامات این کار این است که به کاربران زمان منسوخ شدن نرم افزار از پیش اطلاع داده شده باشد.

به منظور استقرار یک اپلیکیشن در محیط سیستم مشتریان، مراحل بالا باید به طور دقیق طراحی و آزمایش شوند. از آن جا که تمام این اقدامات پس از توسعه ی یک نرم افزار روی سیستم کاربران صورت می گیرد، معمولاً طراحی و اشکال زدایی آن ها تا مراحل پایانی توسعه نرم افزار به تعویق می افتد. مسئولیت کدنویسی بخش مربوط به نصب نرم افزار در آخرین مرحله به یک مهندس توزیع محول می شود که به واسطه ی پیچیدگی های مربوط به آن، کار خود را با نارضایتی پیش می برد. نتیجه ی این کار این است که تیم نرم افزاری هیچ تجربه ای در مورد فرآیند دیپلویمنت نرم افزار یا محیط واقعی که نرم افزار در آن استقرار می یابد پیدا نمی کند، تا زمانی که بسیار دیر می شود و عملاً نمی توان تغییری را در سیستم اِعمال کرد یا نتیجه ی اِعمال تغییرات بسیار سنگین می شود.

از آن جا که فرآیند نصب و دیپلویمنت اولین چیزی است که مشتری با آن رو به رو می شود، هر اندازه این فرآیند ساده تر باشد، کاربر نهایی راحت تر و با خطای کم تر می تواند نرم افزار شما را روی سیستم خود به کار گیرد، در نتیجه به نرم افزار اعتماد پیدا می کند و راحت تر برای پذیرش آن قانع می شود.

زمانی که پروژه ی نرم افزاری خود را با کار روی عملیات نصب آغاز می کنید، فرصت بیش تری برای کار روی این فرآیند دارید، در نتیجه شانس این را دارید که هم زمان با توسعه ی نرم افزار بتوانید بخشی از کدهای برنامه را به منظور تسهیل فرآیند نصب تغییر دهید. اجرا و تست فرآیند نصب در یک محیط تمیز به صورت دوره ای خیال شما را از این بابت راحت خواهد کرد که فرآیند طراحی شده به قابلیت های منحصر به سیستم شما که روی آن نرم افزار را توسعه می دهید وابستگی ندارد، و روی هر سیستمی قابل راه اندازی و اجرا است.

به تأخیر انداختن طراحی و تست اقدامات فرآیند دیپلویمنت نرم افزار به این معنا است که در مراحل پایانی با پیچیدگی های بیش تری رو به رو خواهید بود. به این دلیل که مجموعه ای از کدهای نرم افزار عملاً قابل تغییر نیستند، یا این که گاهی کدنویسی برنامه با فرضیاتی در مورد سیستم صورت گرفته است که منحصر به سیستم خاص شما است و برای کار روی سایر سیستم ها نیازمند تغییر است.

اگرچه فکر کردن در مورد فرآیند دیپلویمنت نرم افزار و کار روی آن در همان آغاز پروژه توجیه اقتصادی ندارد و ارجحیت با این است که توسعه دهنده بتواند اپلیکیشنی را طراحی و توسعه دهد که در محیط توسعه، روی سیستم خودش به درستی اجرا شود؛ با این حال نکته ی اساسی در این است که شما نهایتاً زمانی می توانید از پروژه ی خود سود اقتصادی ببرید که بتوانید نسخه ی قابل نصب و اجرا را در اختیار مشتریان قرار دهید و آن ها بتوانند از نرم افزار کدنویسی شده به درستی روی سیستم خود استفاده کنند، در غیر این صورت هیچ کس برای اپلیکیشنی که کدهای آن تنها در یک IDE اجرا می شوند پولی پرداخت نخواهد کرد.

به عنوان نکته ی پایانی باید به این مورد اشاره داشته باشیم که فرآیند نصب و دیپلویمنت نرم افزار نقش مهمی در میزان بهره وری مشتریان و تیم خدمات تخصصی شما دارد، بنابراین به همان نسبت که برای تست و دیباگ کردن سورس کد نرم افزار خود وقت صرف می کنید، روی آزمایش، ارزیابی، و اشکال زدایی فرآیند نصب و دیپلویمنت نرم افزار نیز زمان بگذارید.







# مدیریت اکسپشن ها

یک Exception (اکسپشن یا استثناء) مشکلی است که در زمان اجرای برنامه رخ می دهد. زمانی که یک اکسپشن اتفاق می افتد جریان عادی برنامه مختل می شود و برنامه یا اپلیکیشن به طور غیر عادی پایان می یابد.

برای جلوگیری از چنین پایان ناخواسته ای باید اکسپشن ها مدیریت یا هَندل شوند و عملیات لازم برای رفع مشکل انجام شود. از این رو در زمان رخ دادن یک اکسپشن آبجکتی تحت عنوان Exception Object ایجاد می شود که حاوی اطلاعاتی در مورد نوع و زمان ایجاد خطا در برنامه یا اپلیکیشن است، سپس این آبجکت در اختیار سیستم قرار می گیرد. از این مرحله به بعد، سیستم سعی می کند تا راهی برای رفع خطا پیدا کند. اگر سیستم قطعه کدی پیدا کند که بتواند خطای ایجاد شده را رفع کند، استفاده ی مجدد از سیستم امکان پذیر خواهد بود. پس لازم است در بخش هایی از برنامه که احتمال بروز اکسپشن وجود دارد از قبل آینده نگری شود و برای مدیریت اکسپشن ها برنامه ریزی و کدنویسی شود. رخ دادن یک اکسپشن می تواند دلایل زیادی داشته باشد که برخی از مهم ترین آن ها عبارتند از:
- کاربر داده ی نامعتبری وارد کرده است.
- برنامه برای اجرا نیاز به فایلی دارد که نمی تواند آن را پیدا کند و محتوای آن را بخواند.
- ارتباط با شبکه قطع می شود و یا حافظه ی دستگاه از دسترس خارج می شود.

برخی از این سناریوها به دلیل خطای کاربر، برخی بواسطه ی خطای برنامه نویس و دسته ای دیگر به خاطر نبود ریسورس کافی یا بهتر بگوییم «منابع فیزیکی» اتفاق می افتند. با این حال تمام این اکسپشن ها در دسته ی "خطاهای فنی" قرار می گیرند. در کنار این خطاها گروهی دیگری از اکسپشن ها وجود دارند که به واسطه ی برآورده نشدن Business Logic اتفاق می افتند. برای مثال فرض کنیم اپلیکیشنی طراحی شده است که به کاربران امکان خرید آنلاین می دهد. حال یکی از کاربران این اپلیکیشن بخواهد خریدی انجام دهد، اما اعتبار پولی کافی در حساب خود نداشته باشد. در این صورت یک شرایط استثناء اتفاق می افتد که مربوط به جنبه های فنی برنامه نمی شود، بلکه «منطق تجاری» برنامه این اجازه را به کاربر نمی دهد که با اعتبار ناکافی تراکنش خود را انجام دهد.

نکته ای که باید در مورد اکسپشن ها رعایت شود این است که می بایست بین انواع فنی و عملی اکسپشن ها تمایز قائل شویم. با این کار، امکان این را خواهیم داشت که از مکانیزم های عمومی مدیریت اکسپشن ها در زبان های برنامه نویسی مختلف استفاده کرده و حتی برای مدیریت اکسپشن ها از برخی فریم ورک های نرم افزاری استفاده کنیم، اما در مورد اکسپشن های عملی باید کاربر حتما از شرایط استثنایی رخ داده شده آگاه شود و آماده ی مدیریت آن باشد، که در این موارد بهتر است یک اکسپشن جداگانه یا سلسله مراتب استثناء متمایز برای مدیریت اکسپشن ها در نظر گرفته شود تا کاربر بتواند بر اساس شرایط خود، آن ها را مدیریت کند.






# تمرین آگاهانه، لازمهٔ حرفه‌ای شدن است!

فرض کنید شما در یک کلاس برنامه نویسی شرکت کرده اید، یا یک دوره ی برنامه نویسی را گذرانده اید. مطمئناً در این دوره ها با مفاهیم زیادی مثل استفاده از شرط ها و حلقه ها، اصول شیء گرایی، مدیریت اکسپشن ها و بسیاری موارد پایه ای دیگر آشنا شده اید. به علاوه در هر کدام از این دوره ها با جزئیات عملی زیادی مثل این که در زبان پایتون برای بلوک بندی قطعه کدها به جای کروشه از تورفتگی استفاده می کنیم، یا این که زبان جاوا نسبت به حالت حروف حساس است آشنا شده اید.

با وجود آشنایی با تمام این مفاهیم و جزئیات عملی ممکن است شما باز هم نتوانید یک اپلیکیشن خوب توسعه دهید. دلیل این موضوع این است که دانش مفاهیم نظری پایه ی کار برای شروع برنامه نویسی است، با این حال تنها تمرین کردن و تمرین کردن و تمرین کردن در کدنویسی و کسب مهارت است که از شما یک برنامه نویس حرفه ای می سازد.

هیچ جایگزینی برای تمرین وجود ندارد. شما نمی توانید به خودتان بگویید که خب من یک منبع خوب برای یادگیری برنامه نویسی پیدا کردم و با مطالعه ی آن تا دو هفته ی دیگر تبدیل به یکی از خبرگان برنامه نویسی می شوم. بدون تمرین مفاهیم نظری هم به سرعت فراموش خواهند شد. با این حال همان طور که اگر برای یادگیری مفاهیم نظری استاد خوب و منابع درسی کاملی در دست داشته باشید می توانید با سرعت بیش تری مطالب را بفهمید و یاد بگیرید، در مورد یادگیری مهارت های عملی نیز راه هایی وجود دارد که می توانید با استفاده از آن ها سرعت خود را بیش تر کنید، یا اگر بخواهیم به طور دقیق تر صحبت کنیم با استفاده از این روش ها شما وقت خود را برای تمرین های بیهوده که تأثیری در مهارت آموزی شما نخواهند داشت تلف نخواهید کرد.

Deliberate Practice یا «تمرین آگاهانه» تکنیک قدرتمندی است که به شما این اطمینان را می دهد که از زمانی که برای تمرین کردن اختصاص داده اید، بیش ترین استفاده را کرده اید. تکنیک تمرین آگاهانه بر اساس تحقیقات کی. آندرس اریکسون طراحی شده است. این تکنیک چندین اصل پایه ای برای تمرین آگاهانه دارد، اما در این جا ما روی دو مورد از آن ها تمرکز می کنیم:

1- تمرین بر لبه ی توانایی ها و دانش کنونی:
تمرین بسیار ساده چیز تازه ای به شما یاد نمی دهد و تمرین بسیار سخت مانع پیشرفت شما خواهد شد. اولین نکته بسیار آشکار است. اگر سطح دشواری تمرین های شما بسیار پایین باشد، پیشرفت چندانی نخواهید داشت. اگر شما مدتی است که یادگیری برنامه نویسی را شروع کرده اید، نوشتن یک برنامه ی ساده ی HelloWorld هیچ کمکی به شما نخواهد کرد و چیز تازه ای به شما یاد نخواهد داد.

بنابراین حتی در پیاده سازی برنامه های ساده نیز خلاقیت به خرج دهید. اگر روی مثال های آموزشی خود کار می کنید، سعی کنید آن ها را به نحوی تغییر دهید و با دانش قبلی خود ترکیب کنید. مثلاً اگر یاد می گیرید که فانکشنی بنویسید که یک آرگومان استرینگ می گیرد، سعی کنید خودتان فانکشن های جدیدی بنویسید که تعداد آرگومان های بیش تر، با انواع متنوع تری داشته باشد. با این حال اگر سطح دشواری تمرین های شما بیش از حد بالا باشد، شانس زیادی برای موفقیت نخواهید داشت. اگر شما روی یک برنامه ی بسیار پیشرفته کار کنید که نتوانید بفهمید هر بخش آن چطور کار می کند، در این صورت تمرین کردن بی معنی خواهد بود. اگر شما همین دیروز شروع به یادگیری برنامه نویسی کرده اید، و امروز بخواهید روی کدنویسی یک پروژه ی بزرگ کار کنید قطعاً راه به جایی نخواهید برد.

2- بازخورد گرفتن:
کارهای خود را به دیگران ارائه کنید و از آن ها بخواهید نظر خود را در مورد نقاط ضعف و قوت برنامه هایتان اعلام کنند.
اصل دوم نیز بسیار مشهود است، با این حال بسیاری از افراد در زمان تمرین یک مهارت جدید آن را فراموش می کنند. بازخورد گرفتن به طور غیر قابل باوری اهمیت دارد، زیرا به شما این امکان را می دهد تا کار خود را تصحیح و تعدیل کنید. اگر هیچ کس به شما نگوید که چه اشتباهی کرده اید، چطور پی به خطای خود می برید و آن را اصلاح می کنید؟

مثلاً فرض کنید شما کدهای برنامه ی خود را روی یک برگه کاغذ بنویسید؛ این کار برای شما راحت تر خواهد بود، اما تا زمانی که آن ها را در محیط کامپیوتری کامپایل و اجرا نکرده باشید چطور مطمئن خواهید بود که برنامه ی درست و بدون باگی نوشته اید. به علاوه تمام تکنیک های کدنویسی را نمی توان تنها با اجرای کامپیوتری برنامه ها یاد گرفت. لازم است گاهی دیگران نگاهی به کار شما بیاندازند و نظر خود را در مورد آن بگویند.

تمرین کردن کدنویسی بدون آن که کار خود را به دیگران ارائه کنید و از آن ها بازخورد بگیرید، مثل این است که در تاریکی قدم برمی دارید. ممکن است به جلو پیش روید، ممکن است تنها دور خود بچرخید، اما نمی توانید تفاوت این دو را بفهمید.






# پشت هر خط از کد شما می‌بایست یک منطق وجود داشته باشد!
یکسری ابزارها در اختیار برنامه نویسان هستند که این امکان را به ایشان می‌دهند تا کدهایشان را به منظور عدم وجود هرگونه باگی چک کنند اما واقعیت امر آن است که این دست ابزارها همیشه کارآمد نیستند و نتیجه ی دلخواه را بوجود نمی آورند. در همین راستا، برنامه نویسان نیاز به رویکردی دارند تا از آن طریق بتوانند از درستی کدهای خود اطمینان حاصل کنند و این همان چیزی است که در این آموزش قصد داریم مورد بررسی قرار دهیم.

یک برنامه نویس حرفه‌ای کسی است که سورس کد پروژه ی خود را به بخش‌های کوچک تقسیم‌بندی کرده -خواه بخش‌های یک خطی مثل فراخوانی یک فانکشن، خواه بخش‌های مثلاً ده خطی- و از صحت کارکرد این بخش‌های سورس کد اطمینان حاصل کند. اگر شما بتوانید به اندازه‌ای از کارکرد سورس کد پروژه ی خود اطمینان داشته باشید که یکی از دوستان برنامه نویس شما -که نقش Devil`s Advocate را بازی می کند- نتواند به آن گیر دهد، کفایت می‌کند و شما به هدف خود دست یافته اید.

به خاطر داشته باشید به طور کلی منظور از Devil`s Advocate یا «وکیل مدافع شیطان» کسی است که مهارت خاصی در ایراد بنی اسرائیلی گرفتن دارد و همواره نیمه ی خالی لیوان را نگاه می کند. ممکن است این تصور برای شما پیش بیاد که در شرکت های حرفه‌ای چنین افرادی اصلاً جایگاه خوبی ندارند اما این باور کاملاً اشتباه است. شرکت های تراز اول برای وکلای مدافع شیطان سر و دست می شکنند چرا که این افراد می‌توانند متضمن موفقیت یک محصول شوند.
در بررسی تک تک خطوط سورس کد، می بایست همواره این نکته را مد نظر قرار دهیم که تا حد ممکن بلوک های کد مستقل از یکدیگر باشند و اصطلاحاً Dependency (دیپندنسی یا وابستگی) کمی مابین بخش‌های مختلف کد وجود داشته باشد چرا که در این صورت، بررسی سورس کد به مراتب راحت‌تر خواهد بود. به طور کلی، یکسری نکات هستند که اگر بتوانیم از آن‌ها در کدنویسی پیروی کنیم، تا حد قابل توجهی می‌توانند متضمن یک محصول نهایت بهینه گردند که عبارتند از:

- تا حد ممکن از فانکشن هایی که ماهیت GoTo دارند اجتناب کنید. در اینجا منظور از GoTo، فانکشن هایی است که برای انجام کاری خاص نیاز به سایر فانکشن ها دارند و همین مسأله منجر ارتباط بین فانکشنی و در نهایت پیچیدگی بیشتر سورس کد می شود.

- تا حد ممکن از متغیرهای گلوبال که امکان تغییر مقادیر آن‌ها وجود دارد استفاده نکنید چرا که این دست متغیرها منجر به ایجاد وابستگی مابین بخش‌های مختلف کد می‌شوند (منظور از متغیرهای گلوبال، متغیرهایی است که در بدنه ی کلاس‌ها تعریف شده و به نوعی public هستند؛ یعنی از هر کجای برنامه می‌توان به آن‌ها دسترسی داشت.)

- هر متغیر می بایست تا حد ممکن از Scope یا «حوزه ی» کوچکی برخوردار باشد. به عبارت دیگر، مثلاً به جای تعریف کردن متغیری تحت عنوان userAccountNumber که گلوبال است، بهتر است که این متغیر را داخل یک فانکشن تعریف کنیم و صرفاً داخل همان فانکشن به آن دسترسی داشته باشیم.

- از فضاهای خالی به منظور خوانایی بیشتر کد استفاده کنید. به عبارت دیگر، بخش‌های مختلف سورس کد را با زدن اینتر مجزا کنید و در عین حال هم از Indentation های درست استفاده کنید (منظور از Indentation، اسپیس هایی است که از سمت چپ ویرایشگر کد تا ابتدای دستورات وجود دارند.) امروزه اکثر IDE ها دارای این قابلیت هستند تا به صورت خودکار، فواصل سورس کد را منظم کنند.

- کد خود را گویا کنید. به عبارت دیگر، نام هایی برای کلاس ها، فانکشن ها، متغیرها و … استفاده کنید که نیازی به کامنت گذاری نداشته و مثلاً نام یک فانکشن به خوبی نمایانگر ماهیت و کاری که آن فانکشن انجام می‌دهد باشد. به طور مثال، اگر فانکشی قرار است اطلاعات کاربر را از دیتابیس گرفته و در اختیار ما قرار دهد، نامی همچون fetchUserInfo مناسب است چرا که هم کوتاه است اما در عین حال گویای ماهیت این فانکشن نیز هست.

- اگر منطق برنامه ی شما به گونه‌ای است که نیازمند بخش‌های تو در تو است، بهتر آن است که هر بخش را در قالب یک فانکشن کدنویسی کنید.

- هر فانکشن می بایست فقط و فقط یک کار را انجام دهد و از نوشتن فانکشن های «همه کاره» شدیدا خودداری کنید. گفته می‌شود که یک فانکشن خوب، فانکشنی است که در صفحه ی مانیتور، بدون نیاز به اسکرول کردن، ابتدا و انتهای آن معلوم باشد. یعنی چیزی در حدود 24 خط کد! (البته بسته به رزولوشن و اندازه ی مانتیور، این قانون برای برنامه نویسان مختلف نتایج کاملا متفاوتی دارد.)

- تعداد پارامترهای ورودی فانکشن ها می بایست محدود باشد (مثلاً 4 پارامتر ورودی به نظر محدودیت خوبی به نظر می آید) و در صورتی هم که تعداد پارامترهای ورودی مد نظر شما زیاد است -مثلا 12 پارامتر ورودی- می‌توانید پارامترهای مرتبط با یکدیگر را در قالب یک آبجکت تعریف کرده و از آن آبجکت به عنوان یکی از پارامترها استفاده نمایید.

علاوه بر موارد فوق الذکر، راه کارهای دیگر نیز هستند که با اعمال آن‌ها می‌توان درک بهتری از سورس کد پیدا کرد اما موارد مطروحه جزو مهم‌ترین چیزهایی هستند که به شما کمک خواهند کرد تا کدی تمیز، بدون باگ، بدون وابستگی، گویا و بهینه داشته باشید..

 






# مفهوم DSL چیست و چرا آشنایی با آن در حوزهٔ برنامه‌نویسی اهمیت دارد؟

منظور ازDSL که مخفف واژگان Domain-Specific Language به معنی «زبان اختصاصی هر حوزه ی کاری» می باشد، یکسری زبان‌های برنامه نویسی است که به صورت تخصصی برای یکسری کارهای خاص در یکسری حوزه های خاص مورد استفاده قرار می‌گیرند. برای درک بهتر دی اس ال ها، می‌توان آن‌ها را همچون زبان‌های برنامه نویسی کوچکی تلقی کرد که برای انجام یکسری کارهای خاص در یک سیستم مورد استفاده قرار می‌گیرند و از جمله حوزه های خاصی که از دی اس ال ها در آن‌ها استفاده می شود، می‌توان به صنعت بیمه، صنعت هواپیمایی، پتروشیمی و … اشاره کرد.

یکی از دلایلی که دی اس ال ها بوجود آمدند این بود که زبان‌های رایج و همه منظوره برای یکسری ابزارها، سیستم ها، پلتفرم ها و حتی صنایع آن طور که باید و شاید اثربخش نبودند و همین شد که این گروه از زبان‌های برنامه نویسی کوچک اما در عین حال کاربری ابداع شدند.

بر خلاف زبان‌های برنامه نویسی همه منظوره ای همچون جاوا، پایتون، پرل و غیره، حوزه ای که از دی اس ال ها می‌توان در آن استفاده کرد محدود است اما این در حالی است که در آن حوزه ی خاص، دی اس ال ها با سرعت بیشتر و عملکرد به مراتب بهتری نسبت به زبان‌های همه منظور عمل خواهند کرد.

در ضمن، به نوعی می‌توان گفت که دی اس ال ها برای حوزه ی خاصی که طراحی می‌شوند فوق‌العاده خوب هستند اما برای حوزه هایی که خارج از ساختار از پیش تعریف شده ی دی اس ال باشند فوق‌العاده بد هستند.

نکته توجه داشته باشیم که ما با استفاده از دی اس ال ها نخواهیم توانست یک برنامه ی کامل و جامع بنویسیم بلکه صرفاً به منظور انجام کارهای کوچکی که به سرعت می بایست انجام شوند می‌توان از این زبان‌های برنامه نویسی کوچک استفاده کرد.
از جمله دی اس ال های رایج می‌توان به CSS, Ant و SQL اشاره کرد. به یاد داشته باشید که از برخی زبان‌های General Purpose یا «چند منظوره» همچون سی شارپ، اسکالا، روبی و … می‌توان به منظور ساخت یک DSL استفاده کرد. مثلاً از زبان اسکالا -که خود این زبان برگرفته از زبان برنامه نویسی جاوا است- می‌توان برای ساخت DSL هایی برای صنایع بسیار حساس همچون صنعت نفت استفاده کرد.

انواع DSL ها
به طور کلی، زبان‌های دی اس ال را می‌توان به دو دسته ی Internal (اینترنال یا داخلی) و External (اکسترنال یا خارجی) تقسیم‌بندی کرد.

دی اس ال های اینترنال به گروهی از زبان‌های برنامه نویسی گفته می‌شود که بر پایه زبان‌های برنامه نویسی همه منظوره ای همچون سی شارپ، جاوا، اسکالا، روبی و … بوده و این در حالی است که بسیاری از قابلیت‌های این زبان‌های مادر در DSL هایی که بر پایه ی آن‌ها نوشته شده‌اند مشهود است که به عنوان مثال می‌توان به سینتکس -نحوه ی نوشتار- این زبان‌ها اشاره کرد. از زبان‌های دی اس ال اینترنال در جامعه ی توسعه دهندگان زبان برنامه نویسی Lisp به کرات استفاده می شود.

در مقابل، دی اس ال های اکسترنال قرار دارند که خود توسعه‌دهنده می‌تواند تصمیم بگیرد که از چه نشانه ها، سینتکس و ساختاری برای زبان مد نظرش استفاده کند. دی اس ال های اکسترنال تا حد بسیار زیادی دست شما را باز می‌گذارند اما این در حالی است که طراحی این دست زبان‌ها به مراتب دشوارتر بوده و مستلزم صرف زمان نسبتاً زیادی برای توسعه ی آن‌ها است چرا که شما می بایست کامپایلر اختصاصی دی اس ال را به منظور اجرای سینتکسی که مد نظر شماست را نیز طراحی کنید. در توسعه ی سیستم عامل های مبتنی بر Unix از زبان‌های دی اس ال اسکترنال به کرات استفاده می شود.

در زمان طراحی DSL ها، همواره می بایست مخاطب را مد نظر قرار داد و دید که مخاطبین این زبان برنامه نویسی جدید چه گروهی از کاربران هستند؛ آیا توسعه‌دهنده اند یا جزو مدیران و تیم اجرایی یک شرکت محسوب می شوند. پس از آن که مخاطبین زبان مشخص شدند، می بایست بر اساس نیاز و تخصص ایشان اقدام به طراحی سینتکس، سطح فنی مورد نیاز زبان، ابزارهای مورد نیاز و نحوه ی به کارگیری زبان کرد. با پنهان سازی جزئیات فنی در زبان‌های دی اس ال، می‌توان کاربران هدف را به ابزاری تجهیز کرد که بدون نیاز به کمک توسعه دهندگان، بتوانند نیازهای خود را مرتفع سازند.

مزایای DSL ها
به طور کلی، مزایای طراحی زبان های دی اس ال را می توان به صورت زیر خلاصه کرد:
- برخلاف زبان های همه منظوره، دی اس ال ها بهترین گزینه برای نیازهای خاص هستند.
- کسانی که با برنامه نویسی هم آشنایی نداشته باشند به سادگی قادر خواهند بود تا یک دید کلی نسبت به آن ها پیدا کنند.
- این امکان وجود خواهد داشت تا با طراحی یک GUI یا «رابط گرافیکی کاربری» فرایند استفاده از دی اس ال را ساده تر نمود.
- امکان ساخت Prototype (پروتوتایپ یا نمونه ی اولیه) یک نرم افزار یا اپلیکیشن با استفاده از دی اس ال ها به مراتب راحت تر صورت می گیرد.

یکی از بهترین نمونه های دی اس ال، CSS است که مخفف واژگان Cascading Style Sheets به معنی «الگوی های آبشاری» می باشد. به طور کلی، کدهای سی اس اس به طراحان سایت اجازه می دهند تا به عناصر تشکیل دهنده ی یک صفحه ی وب شکل و ساختار دهند. برای مثال، کدهای سی اس اس زیر رنگ بنده ی یک صفحه ی سایت را قرمز کرده، اندازه ی فونت را 16 پیکسل کرده و رنگ فونت را هم سفید می کنند:
```Css
body {
    background: #F00
    font-size: 16px;
    color: #FFF
}
```






# از ساختارشکنی نترسید!

کمتر کسی را می‌توان یافت که در حوزه ی برنامه نویسی کار کرده باشد و با پروژه یی مواجه نشده باشد که ساختار کدنویسی آن مشکل داشته باشد. در چنین پروژه هایی، رفع یک باگ منجر به ایجاد ده‌ها باگ دیگر خواهد شد! در چنین شرایطی، برنامه نویس کاملاً دست به عصا کدنویسی کرده و همیشه این نگرانی را دارد که پروژه از هم بپاشد.

دلیل مواجهه با چنین مشکلی کاملاً واضح است و این دلیل چیزی نیست جز «بیمار» بودن سیستم و این بیمار نیاز به یک پزشک دارد و در غیر این صورت، اوضاع از این هم وخیم تر خواهد شد. در‌ واقع، همان‌طور که یک عمل جراحی در ابتدا با درد همراه است و شرایط اصلاً خوشایندی را برای بیمار فراهم نمی کند اما در نهایت منجر به سلامت بیمار می شود، در این گونه پروژه ها نیز می بایست متحمل چنین دردی شویم!

خود شما –به عنوان برنامه نویس یا یکی از برنامه نویسان چنین پروژه یی- دقیقاً می‌دانید که مشکل از کجا است و چه بخش‌هایی نیاز به ریفکتور شدن دارند اما از دست به عمل شدن هراس دارید.

به خاطر داشته باشید به طور خلاصه، منظور از Code Refactoring (کد ریفکتورینگ) این است که ساختار فعلی سورس کد یک پروژه را تغییر دهیم -یا بهتر بگوییم بهبود بخشیم- بدون آن که تاثیری در نوع ماهیت پروژه ایجاد گردد. فرض کنیم چند سال پیش کدی را نوشته ایم، حال که چیزهای جدید فرا گرفته ایم و به کد نگاه می کنیم، می بینیم کدی که مثلا در 40 خط نوشته ایم را می توان خیلی بهینه تر کرده و به 10 خط کاهش داده و در عین حال اثربخشی آن را نیز بیشتر کرد. به چنین کاری Refactoring گفته می شود.
مادامی که شما به صورت لوکال اقدام به تغییر و تحول سورس کد خود می کنید، هرگز از دست کاری کد خود نترسید چرا که در نهایت منجر به بهبود وضعیت پروژه خواهد شد. خیلی از اوقات ما -به عنوان برنامه نویس- می‌دانیم که مشکل از کجا است اما یا حوصله ی رفع کردن آن را نداریم یا به دلیل طولانی شدن زمان کار کردن روی پروژه، ترجیح می‌دهیم مشکلات را به حال خود رها کرده و روی پروژه ی دیگری کار کنیم و یا این که از رو به رو شدن با مشکلات پروژه هراس داریم.

متأسفانه خبر بد این که این شتری است که درب خانه ی هر برنامه نویسی می خوابد! شما چاره یی جز این ندارید که سورس کد خود را ریفکتور کنید، باگ ها را رفع کنید و وابستگی‌ها را به حداقل برسانید. اگر هم روی پروژه یی کار می‌کنید که شما مسئول مستقیم آن نیستید، سعی کنید مدیر خود را مجاب کنید که اگرچه این اصلاحات نتایج ملموس و قابل مشاهده یی ایجاد نمی کنند، اما در نهایت منجر به کاهش هزینه‌ها در دراز مدت و تجربه ی کاربری بهتری می شوند.

به خاطر داشته باشید Dependency (دیپندنسی یا وابستگی) در توسعه ی نرم افزار به این نکته اشاره دارد که سورس کد پروژه ما برای اجرای تمام و کمال، نیاز به سایر کدها، لایبرری ها و حتی سایر نرم افزارها داشته باشد. توجه داشته باشیم که در توسعه ی نرم افزار، می بایست تمام تلاش خود را به کار بندیم تا این وابستگی ها به حداقل برسند. علاوه بر این، اصطلاحی داریم تحت عنوان Dependency Hell یا «جهنم وابستگی» که وقتی رخ می دهد که نرم افزار ثالثی که از آن در پروژه ی خود استفاده می کنیم تغییری در سورس کد اش ایجاد می کند که این تغییر منجر به عملکرد ناصحیح نرم افزار ما خواهد شد.






# برای تست نرم‌افزار از دیتای واقعی استفاده کنید

پیش از هر گونه توضیحی، سناریویی تعریف می‌کنیم تا ببینیم برای چند درصد از ما آشنایی دارد؛ نرم افزاری نوشته‌ایم -مثلا یک وب اپلیکیشن- حال نیاز است تا یکسری دیتای اولیه وارد دیتابیس کرده تا بتوانیم تست نهایی را انجام دهیم. پیش از هر چیز، چند یوزر می بایست تعریف کنیم؛ برای این کار، از نام کاربری‌هایی همچون ali1, ali2 و ali3 استفاده می کنیم. اکنون تک تک این یوزرها را می بایست به یک گروه کاربری ربط دهیم. مثلاً گروه‌های کاربری ادمین، کاربر معمولی و کاربر میهمان (در ضمن، برای ثبت نام در سایت، برای انتخاب نام کاربری حتماً می بایست هشت کاراکتر وارد کرد اما چون در مرحله ی تست است و قصد داریم برای ثبت نام و مهم‌تر از آن لاگین کردن، تعداد کاراکتر کمتری را وارد کنیم، بخشی از کد که مسئول چک کردن تعداد کاراکترهای نام کاربری است که کامنت می کنیم.)

به علاوه این که آقا/خانم برنامه نویس برای تست یک اینپوت فرم -مثلا ناحیه یی برای وارد کردن نام خانوادگی- عبارت jfldjf'sdjfsjf یا چیزی شبیه به آن را وارد می کند! سناریو را بیش از این ادامه نمی‌دهیم اما پر واضح است که مثال‌های زیادی از این نوع رفتارهای توسعه دهندگان می‌توان زد به این صورت که از آنجا که ایشان فکر می‌کنند در مرحله ی تست هیچ‌ کس کد ایشان را نمی بیند، از دیتای غیر واقعی و … استفاده می کنند. 

وقتی ما به عنوان یک توسعه دهنده و گاهی اوقات هم تست کننده ی نرم افزار اقدام به تست می کنیم، تحت هیچ عنوان نمی بایست از نام های کاربری همانند آنچه در بالا گفته شد برای ثبت نام استفاده کنیم؛ علاوه بر این، برای تست کردن فرم ها و ... حتما می بایست دیتای واقعی وارد کنیم چرا که آدم های واقعی قرار است که این نرم افزار را مورد استفاده قرار دهند و در غیر این صورت، احتمال زیادی وجود دارد که به هدف نهایی خود که همان ارائه ی یک محصول باکیفیت و بدون باگ است نرسیم.

خیلی از اوقات پیش می آید زمانی که برای تست نرم افزار خود بخشی از کد را کامنت می کنیم -از روی تنبلی- زمانی که می خواهیم محصول نهایی را Deploy (دیپلوی یا منتشر) کنیم، فراموش می کنیم که بخش مد نظر را از کامنت خارج کنیم و این می تواند تبعات بسیاری مخربی داشته باشد!

خلاصه ی کلام این که تست کردن به این روش می‌تواند آینده ی اپلیکیشن را تحت الشعاع قرار دهد. همواره سعی کنید در فرایند تست محصول نهایی، از دیتای شبیه به واقعی استفاده کنید چرا که در بسیاری از مواقع، دیتای تستی -به صورت ناخواسته- منتشر شده و در اختیار End-user ها قرار می‌گیرد و نیاز به توضیح نیست که امروزه با وجود شبکه‌های اجتماعی، هر گونه «کم کاری» از طرف تیم برنامه نویسی شما می تواند در معرض دید هزاران کاربر بالقوه قرار گرفته و آبروی تیم برنامه نویسی شما را به کلی تحت تأثیر قرار دهد.






# حتی یک ارور را هم نادیده نگیرید!

پیش از هر چیز، ابتدا نیم نگاهی به داستانی فرضی داشته باشیم و در ادامه به بررسی ربط این داستان به ارورهای کدنویسی خواهیم پرداخت. فرض کنید که پس از فارغ التحصیلی از دانشگاه، چند سالی است که هم دانشکده یی های خود را ندیده اید و به لطف شبکه‌های اجتماعی، شما و همکلاسی هایتان همدیگر را می یابید. در یک کافه یا رستورانی قرار می‌گذارید تا یکدیگر را ملاقات کنید. زمان جلسه ساعت 5 بعد از ظهر است و اما شما تازه ساعت 4:30 از منزل بیرون رفته‌اید و از آنجا که اصلاً دوست ندارید پس از سال ها، آدم بدقولی جلوه کنید، با سرعت هرچه تمام تر به سوی محل قرار ملاقات پیش می روید.

از این تاکسی به اون تاکسی، از این اتوبوس به آن اتوبوس، جاهایی را هم از کوچه پس کوچه‌ها می‌روید که سریع‌تر به مقصد برسید. در حال عبور کردن از مقابل مغازه یی که صاحب آن داشت جلوی مغازه اش را آبپاشی می کرد، کمی تلو تلو می‌خورید و ناگهان نقش بر زمین می شوید!

با توجه به این که خیلی عجله دارید، اول احساس درد زیادی نمی‌کنید و به سرعت بلند شده، لباس هایتان را می تکانید و مجدد به سرعت هرچه تمام تر به راه خود ادامه می‌دهید و در نهایت تقریبا به‌موقع به قرار ملاقات خود می رسید. در حین گپ و گفتگو با دوستان، باز هم کمی احساس درد می‌کنید که با خود می‌گویید که "خب زمین خودم ام و کمرم کمی کوفتگی پیدا کرده!" در طول کل جلسه، آن طور که باید و شاید از در کنار دوستان قدیمی خود بودن لذت نمی برید تا این که جلسه به پایان می‌رسد اما از آنجا که ثانیه به ثانیه به درد کمر شما افزوده می شود، مجبور می‌شوید که فردای آن روز به درمانگاه مراجعه کنید و می‌بینید که دیسک کمر شما آسیب دیده است.

واقعیت امر آن است که اگر به محض زمین خوردن، موضوع جدی گرفته می‌شد و به درمانگاه مراجعه می کردیم، شاید هرگز این آسیب دیدگی به دیسک های کمر کشیده نمی‌شد و صرفاً با چند روز استراحت و مراعات مشکل حل می شد! کدنویسی بسیاری از برنامه نویسان هم شبیه به داستان بالا است. چگونه؟ به این شکل که وقتی با اروری در کدهای خود مواجه می شوند، اگر آن ارور به گونه یی باشد که وی را از ادامه ی توسعه ی نرم افزارش نگاه ندارد، ارور را نادیده گرفته و به کار خود ادامه می‌دهند و همین مسأله منجر به بروز مشکلاتی گاها بسیار بزرگ در آینده ی نرم‌افزار می شوند. اگر بخواهیم به مسأله ی ارورها از این بعد نگاه کنیم، ارورهای نرم افزاری را می‌توان به دسته های زیر تقسیم‌بندی کرد:

- دستورات return: خیلی اوقات پیش می‌آید فانکشن هایی که می نویسیم، باید چیزی را اصطلاحاً ریترن کنند اما هرگز چک نمی‌کنیم که فانکشن مد نظر دقیقاً چه چیزی را ریترن کرده است چرا که گاهی اوقات پیش می‌آید که اگر فانکشن ما چیزی را ریترن نکند، ما در مراحل ابتدایی توسعه ی نرم‌افزار اصلاً متوجه آن نخواهیم شد. 

- اکسپشن ها: مدیریت Exception ها در بسیاری از زبان‌های برنامه نویسی سطح بالا دیده می‌شود و کار برنامه نویسان را ساده کرده است چرا که در صورت بروز چنین اکسپشن هایی، مفسر زبان برنامه نویسی مد نظر به ما هشدار خواهد داد. گاهی اوقات برنامه نویسانی را می‌بینیم که مثلاً در زبان برنامه نویسی پی اچ پی به شکل زیر از ساختار مدیریت اکسپشن ها استفاده می کنند:
```C#
try {
    // do something
} catch() {} // ignoring catching any errors
```
همان طور که در بلوک کد بالا مشاهده می شود، برنامه نویس به خوبی بخش try را هندل کرده است اما اگر به هر دلیلی این قسمت به مشکل برخورد، در بخش catch هیچ کدی برای گرفتن اکسپشن ها نوشته نشده است!

به طور خلاصه، باید بگوییم همان‌طور که بی توجه به درد کمر می‌تواند منجر به صدماتی جدی به دیسک های کمر شود، بی توجه به ارورها، هشدارها، اکسپشن ها و … در حین فرایند توسعه ی نرم‌افزار -خواه نرم‌افزار دسکتاپ باشد، خواه اپ موبایل یا وب اپلیکیشن- می‌تواند منجر به مشکلاتی جدی در مراحل تکمیلی توسعه ی نرم‌افزار گردد که از آن جمله می‌توان به موارد زیر اشاره کرد:
- دشواری در یافتن باگ ها زمانی که برنامه بزرگ‌تر می شود.
- ایجاد حفره های امنیتی در نرم‌افزار و بالا رفتن ضریب هک.
- عدم تمایل سایر توسعه دهندگان به مشارکت در توسعه ی نرم‌افزار شما

لذا ضروری به نظر می رسد که به محض مواجهه با ارورهایی از هر نوع، فورا اقدام به رفع آن ها کرده و هرگز کار امروز را به فردا محول نکنیم. 






# فرهنگ استفاده از یک زبان برنامه‌نویسی را در کنار سینتکس آن بیاموزید

یش از آن که به موضوع این بخش از آموزش که «صرفاً سینتکس یک زبان برنامه نویسی را فرا نگیرید، بلکه فرهنگ استفاده از آن زبان را نیز بیاموزید» است بپردازیم، نیاز است تا مثالی از دنیای واقعی و آموزش یک زبان زنده بزنیم.

در فرایند آموزش زبان‌های خارجی به‌خصوص زبان انگلیسی، بسیاری از مدرسین زبان را می‌بینیم که می‌گویند "برای یادگیری زبان انگلیسی، شما نیاز به فراگیری چهار مهارت Reading, Writing, Listening, Speaking دارید." این توصیه اصلاً اشتباه نیست اما ناقص است! پیش از آن که بگوییم نقص این توصیه کجا است، ابتدا مثالی می زنیم. فرض کنیم که یک نفر از ایران به کشوری انگلیسی زبان مثل کانادا مهاجرت می کند. این فرد در محفلی نشسته و همه گپ و گفتگو می کنند. آقا/خانم مهاجر پس از آن که چیزی می گوید، یکی از حضار از حرفش لذت می‌برد یک شصت به وی نشان می دهد . شصت نشان دادن در فرهنگ غربی یعنی Bravo یا «آفرین، ایول، خیلی خوب بود!» اما در فرهنگ ما چه طور؟ نیاز به توضیح نیست که در فرهنگ ایرانی این علامت معنی خیلی خوبی ندارد!

آقا/خانم مهاجر به دلیل این که از زیرساخت های فرهنگی کشور مقصد خبر ندارد، در چنین شرایطی کاملاً دستپاچه شده و حتی ممکن است سوء تفاهم در ذهنش شکل گیرد اما این در حالی است که اگر در کلاس‌های زبانی که پیش از مهاجرت شرکت کرده بود، مدرس اش علاوه بر مهارت های چهارگانه ی Reading, Writing, Listening, Speaking مهارت پنجمی تحت عنوان Culture یا «فرهنگ» را نیز به وی آموخته بود، او هرگز دچار سوء تفاهم نمی شد.

به خاطر داشته باشید لیست این خرده فرهنگ‌ها بسیار زیاد است اما اگر بخواهیم به نمونه یی دیگر از اختلافات فرهنگی میان ایران و غرب مثال بزنیم، این که در ایران وقتی ما بخواهیم عدم تمایل خود را برای انجام کار با سر نشان دهیم، سر خود را بالا می‌اندازیم و نظر منفی خود را القاء می‌کنیم اما در فرهنگ غرب، برای نشان دادن این حس، سر خود را به سمت راست و چپ تکان می دهند!
یادگیری زبان‌های برنامه نویسی هم تاحدودی شبیه به یادگیری یک زبان زنده ی دنیا است. به عبارت دیگر، علاوه بر یادگیری سینتکس یک زبان برنامه نویسی، شما باید «فرهنگ» استفاده از آن زبان به‌خصوص را نیز بیاموزید. خیلی اوقات ما به خاطر عدم آگاهی از زیر و بم یک زبان برنامه نویسی، نمی‌توانیم آن طور که باید و شاید از تمام پتانسیل زبان انتخابی خود بهره ببریم و به طور مثال از یک زبان شیء گرای قدرتمند، همچون یک زبان پروسیژرال ساده استفاده می‌کنیم. 

علاوه بر این، آشنایی با زبان‌های برنامه نویسی مختلف، می‌تواند به شما دید بازتری در پیاده‌سازی ایده های نرم افزاری بدهد. به طور مثال، اگر یک زبان برنامه نویسی مثل پایتون، زبان اصلی شما باشد اما در عین حال با زبان‌هایی همچون جاوا و پی اچ پی هم آشنایی داشته باشید، درک به مراتب بهتری از تفاوت زبان‌های مختلف و دلایل انتخاب یک زبان برای پروژه یی خاص خواهید داشت. علاوه بر این، آشنایی با زبان‌های برنامه نویسی مختلف، می‌تواند دید خوبی در درک دیزاین پترن ها به شما بدهد.

هشدار این نکته که آشنایی با زبان‌های برنامه نویسی چیز خوبی است هرگز بدان معنا نیست که شما باید از هر زبان برنامه نویسی کمی بدانید اما در هیچ کدام حرفه یی نباشید؛ همچون اقیانوسی به عمق یک سانتی متر! همواره توصیه این است که به جای تست کردن تکنولوژی های مختلف، به یک زبان برنامه نویسی چسبیده و در آن حرفه یی شد اما در عین حال نیم نگاهی هم به سایر فناوری ها داشته باشیم.






# اکسپش‌ها را به راحت‌ترین شکل ممکن هَندل کنید

فرض کنیم برای هندل کردن Exception ها یا بهتر بگوییم «خطاهای» برنامه ی خود، کلاسی مخصوص این کار می نویسیم که مسئول هندل کردن هر گونه اکسپشنی است. مثلاً در زبان PHP برای هندل کردن اکسپشن ها، از ساختار زیر استفاده می شود:
``` C
try {
      // do something
 } catch (Exception $e) {
      return $e;
 }
 ```
کدی که می‌خواهیم اجرا شود را داخل بلوک try قرار داده و در صورت بروز هر گونه اکسپشنی، بلوک داخل catch اجرا خواهد شد. برخی برنامه نویسان هستند که داخل بلوک catch از یک جفت try/catch دیگر نیز استفاده می‌کنند تا بتوانند به صورت لایه به لایه، اصطلاحاً اکسپشن ها را هندل کنند.

چنین رویکردی گاهی اوقات منجر به سردرگمی های فراوانی می‌شود و نتیجه این که وقتی با یک اکسپشن رو به رو می شوید، متوجه نخواهید شد که مشکل دقیقاً از کجا است. همواره سعی کنید برای هندل کردن اکسپشن ها راحت‌ ترین و سر راست ترین رویکرد ممکن را انتخاب کنید تا در حین بزرگ شدن برنامه، با کمترین میزان سردرگمی مواجه شوید.

علاوه بر این، توجه داشته باشید که کاربر نرم‌افزار شما تحت هیچ عنوان نباید اکسپشن هایی که اساساً راهنمای توسعه دهندگان برای رفع باگ های سیستم هستند را مشاهده کنند چرا که علاوه بر ایجاد یک تجربه کاربری نامطلوب، اکسپشن ها معمولاً اطلاعاتی زیرساخت از نرم‌افزار در اختیار کاربر قرار می‌دهند که همین مسأله می‌تواند منجر به پایین آمدن ضریب امنیتی نرم‌افزار شما شود.






# فرایند توسعه یک نرم‌افزار خوب اصلاً شانسی نیست

اگر ما به هر چیزی از مکانیکی گرفته تا نجاری و یا طراحی و سایر کارهای هنری نگاه کنیم، خارج از گود همه این کارها ساده به نظر می رسند؛ مدیران معمولاً بر این باورند که توسعه دهندگان اصلاً کار عجیب و غریبی انجام نمی‌دهند و توسعه دهندگان هم در مقابل فکر می‌کنند مدیران فقط در دفتر خود نشسته و دستور می دهند!

برنامه نویسی صرفاً نوشتن کد نیست بلکه توانایی حل مسئله، الگوریتم نویسی، تحلیل دیتابیس و … جزو بخش‌های لاینفک حرفه ی برنامه نویسی اند که کمتر مد نظر قرار داده می‌شوند و سختی این دست مهارت ها در مقایسه با کدنویسی به مراتب بیشتر است.

با در نظر گرفتن این مسائل، باز هم شاهد برخی برنامه نویسان هستیم که صرفاً درگیر فرایند توسعه ی نرم‌افزار بوده و هرگز در مسائلی همچون تحلیل بازار، تجربه ی کاربری، تأمین بودجه ی توسعه ی نرم افزار، راه اندازی سرور، تضمین کیفیت محصول نهایی، نگهداری نرم‌افزار و … دخالت نمی کنند و معمولاً فکر می‌کنند که دشوارترین کار ممکن در توسعه ی یک محصول نرم‌افزاری مختص به خودشان است و سایر اعضای تیم هیچ کار خاصی انجام نمی دهند.

گاهی اوقات مدیران شرکت های نرم افزاری هم در چنین دامی می افتند. پروژه آنقدر سر وقت، بدون باگ و خوب تحویل مشتری می‌شود که مدیر فکر می‌کند همه چیز با «اجی مجی لاترجی» درست شده و حضور «مدیر پروژه» را اساساً اضافی تلقی می کنند.

این‌ها دام‌هایی هستند که معمولاً اعضای تیم های نرم افزاری در آن‌ها می‌افتند که شدیداً باید از این‌گونه دام‌ها حذر کرد. در فرایند توسعه ی نرم‌افزار سعی کنید در یک حوزه عمیق شوید و به خوبی زیر و بم آن را فرا بگیرید اما هرگز از سایر حوزه ها مثل هاستینگ، کانفیگ سرور، مسائل امنیتی، بهینه سازی و … غافل نشوید چرا که آگاهی از این حوزه ها، منجر به این خواهد شد تا با دید بازتری بتوانید برای حل مسائل پیچیده ی پروژه ی خود، الگوریتم هایی اصولی و بهینه بنویسید.






# آشنایی با قانون DRY

در حوزه ی توسعه ی نرم افزار، اصول و قواعد بسیاری وجود دارد که گاها یکی از دیگری مهم‌تر جلوه می‌کند اما یکی از اساسی‌ترین قواعد برنامه نویسی، قانون DRY است که مخفف واژگان Don't Repeat Yourself به معنی«دوباره کاری نکن» است!

این قانون توسط دو توسعه‌دهنده به نام های Andy Hunt و Dave Thomas ابداع شد که بسیاری از دیزاین پترن های معروف برنامه نویسی، ریشه در این قانون دارند.

برنامه نویسی که بتواند تشخیص دهد کدام بخش‌های کد اصطلاحاً Duplicate یا «مشابه» هستند و تمام تلاش خود را به کار بندد تا با استفاده از کلاس‌ها و فانکشن های مختلف، میزان استفاده از کدهای تکراری در سراسر برنامه را به حداقل برساند، در نهایت سورس کد تمیز تری تحویل خواهد داد که در آینده نگهداری چنین پروژه یی به مراتب راحت‌تر از سورس کدی است که پر است از کدهای مشابه!

هرچه میزان کدهای دوپلیکیت در سورس کد شما بیشتر باشد، احتمال ایجاد باگ در آینده به مراتب بیشتر خواهد شد؛ علاوه بر این، اگر روزی بخواهید بخشی از کد خود را ریفکتور کنید یا تغییر دهید، به جای یک بخش، می بایست چندین بخش را ریفکتور کنید که این کاری بس زمان گیر است.

در فرایند توسعه ی نرم افزار، بخش‌های بسیاری از کد را می‌توان دید که تکراری هستند و قانون DRY دقیقاً برای چنین موقعیت هایی است. شما به عنوان یک توسعه‌دهنده ی حرفه یی، همواره باید این ذهنیت را داشته باشید که در نرم افزاری که می نویسید -خواه یک اپ موبایل باشد و خواه یک سایت- صرفاً از یک راه باید بتوان کار خاصی را انجام داد (مثلاً ارتباط با دیتابیس) و این راه‌کار باید تا حد ممکن ساده، ایمن و اثربخش باشد.

دوپلیکیت شدن در منطق نرم‌افزار می‌تواند به اشکال مختلفی جلوه کند که از جمله ی رایج ترین آن‌ها می‌توان به آبجکت هایی که از روی کلاس خاصی ساخته می‌شوند اشاره کرد و اینجا است که بسیاری از دیزاین پترن ها به داد توسعه دهندگان می آیند. در واقع، ابداع دیزاین پترن ها یا «الگوهای طراحی» جلوگیری از استفاده از کدهای مشابه است. 

به طور مثال، اگر آبجکتی داریم که «عملکردها و رفتارهای» متنوعی از آن انتظار می رود، به جای استفاده از دستورات شرطی if برای هندل کردن چنین موقعیت هایی، چنین عملکردها و رفتارهایی را می‌توان با استفاده از دیزاین پترن Strategy عملی ساخت. 

علاوه بر دیزاین پترن ها، یکسری اصول کدنویسی که تحت عنوان SOLID شناخته می‌شوند نیز بر پایه ی اصل DRY هستند (برای آشنایی بیشتر با مفهوم SOLID، به آموزش آشنایی با قوانین پنج گانهٔ SOLID مراجعه نمایید.) به طور مثال، حرف S در ابتدای SOLID به اصطلاح Single Responsibility اشاره دارد. به عبارت دیگر، هر کلاسی که در پروژه ی خود ایجاد می‌کنیم فقط و فقط باید مسئول یک کار باشد و در صورت نیاز به اعمال تغییرات در کلاس مد نظر، فقط و فقط باید یک دلیل برای ایجاد آن تغییر وجود داشته باشد نه اینکه کلاس مد نظر در جای جای نرم‌افزار برای کارهای مختلفی استفاده شده باشد و به هر دلیلی، نیاز به اعمال تغییرات در آن کلاس داشته باشیم.

به عنوان مثالی دیگر، حرف O در SOLID به اصلی تحت عنوان Open/Closed Principle اشاره دارد. این اصل حاکی از آن است که کدی که می نویسید باید «امکان توسعه یافتن را به برنامه نویسان دیگر بدهد اما تحت هیچ عنوان امکان ایجاد تغییر در کدهای قبلی را ندهد.» چنین اصلی این تضمین را ایجاد می‌کند که نرم‌افزار در فرایند توسعه و تکمیل با این مشکل مواجه نخواهد شد که برنامه نویس دیگری بیاید، بخش‌هایی را تغییر دهد غافل از اینکه این اعمال تغییرات، منجر به ایجاد خرابی در سایر بخش‌های نرم‌افزار شده است.

به طور کلی، مد نظر داشتن قانون DRY در توسعه ی نرم افزار، راه‌کاری است که از آن طریق می‌توان برنامه‌هایی اصولی تر، ساده تر، بدون باگ تر، قابل نگهداری تر و مهم‌تر از همه، باکیفیت تر نوشت؛ البته هرگز فراموش نکنیم که گاهی اوقات شرایطی برای توسعه‌دهنده پیش می‌آید که مجبور به تکرار کد است -مثلا در فرایند Denormalization دیتابیس- که در چنین شرایطی دوباره کاری اصلاً مشکلی ندارد!

به خاطر داشته باشید در کار با دیتابیس یا پایگاه داده، Denormalization به فرایندی گفته می‌شود که از آن طریق توسعه‌دهنده سعی می‌کند پرفورمنس یا عملکرد فراخوانی داده‌ها از دیتابیس را با اضافه کردن داده‌های تکراری یا اضافی و همچنین گروه بندی کردن داده‌ها ارتقاء بخشد. نقطه ی مقابل این فرایند، Normalization قرار دارد که تمرکزش بر کاهش هرچه تمام تر داده‌های اضافی و تکراری در دیتابیس است.






#  آشنایی با مراحل توسعهٔ نرم‌افزار

ه طور کلی، فرایند توسعه ی نرم‌افزار به‌خصوص وب اپلیکیشن ها به ۴ دسته ی زیر تقسیم‌بندی می‌شوند که یک توسعه‌دهنده باید به خوبی با ویژگی‌های هر کدام آشنا باشد که در این آموزش، به تفصیل در مورد خصوصیات هر مرحله توضیح خواهیم داد.

فرایند توسعه ی نرم‌افزار دارای مراحل مختلفی است که به هر کدام از آن‌ها اصطلاحاً Tier (تایر به معنی مرحله) گفته می شود. شرکت های کوچک دارای سه محیط Development و Stage و Production هستند اما شرکت های متوسط و بزرگ معمولاً یک محیط QA یا Quality Assurance به معنی «تضمین کیفیت» نیز می باشند.

مفهوم Development: این محیط که به صورت خلاصه dev نامیده می شود، شامل کلیه ی سخت افزارها و نرم افزارهای مورد نیاز برای اجرای صحیح نرم‌افزار است که توسط توسعه‌دهنده مورد استفاده قرار می‌گیرد و معمولاً شامل آخرین تغییرات صورت گرفته روی نرم‌افزار است. توسعه‌دهنده تغییرات مد نظر خود را روی سورس کد اعمال کرده و آن‌ها را در محیط توسعه ی نرم‌افزار لوکال خود -مثلا لپ تاپش- تست می‌کند و از درست کار کردن کدها اطمینان حاصل می کند.

لازم به ذکر است که این محیط توسعه ی نرم‌افزار کاملاً فردی است و تغییرات اعمال شده روی کد، عملکرد کدهای سایر توسعه دهندگان را تحت تأثیر خود قرار نخواهد داد. علاوه بر این، در محیط dev، توسعه‌دهنده از ابزارهای مختلفی برای توسعه ی نرم‌افزار استفاده می‌کند که از آن جمله می‌توان به ماشین‌های مجازی، لایبرری های مختلف، IDE های مختلف، کامپایلر و … اشاره کرد. با توجه به اینکه محیط توسعه ی dev یک محیط کاملاً فردی است و از توسعه‌دهنده یی به توسعه‌دهنده ی دیگر متفاوت است، این محیط را Local Environment یا Sandbox هم می نامند.

مفهوم Staging: این مرحله از توسعه ی نرم‌افزار که تحت عنوان Integration هم شناخته می شود، مرحله یی است که سایت یا اپلیکیشن در محیطی کاملاً شبیه به محیط Production تست می‌شود و Quality Assurance به معنی «تضمین کیفیت» که به طور خلاصه QA نامیده می‌شود نیز روی آن اعمال می گردد. کانفیگ سروری که برای این مرحله از کار استفاده می شود کاملاً مشابه سرور اصلی است. تیم های توسعه ی نرم‌افزار حرفه یی برای اپلیکیشن هایی که هزاران کاربر دارند را پیش از فرستادن روی سرور اصلی، حتماً روی Staging Server تست می کنند.

مفهوم Production: این محیط که اصطلاحاً محیط Live نامیده می شود، همان سروری است که نرم‌افزار -مثلا وب سایت- روی آن پیاده‌سازی شده و کاربران نهایی می‌توانند از آن استفاده کنند و آخرین مرحله از فرایند توسعه ی نرم‌افزار است.
اپلیکیشن پس از تست و اطمینال حاصل کردن از درست بودن همه چیز و Bug-free بودن آن، روی سرور Production فرستاده می شود.

نکته توجه داشته باشید که آپدیت کردن اپلیکیشن در مرحله ی Production باید در زمانی صورت گیرد که حداقل تعداد کاربران در حال استفاده از اپلیکیشن -مثلا وب سایت- باشند (مثلا ساعت ۳ نیمه شب). علاوه بر این، زمانی که آخرین تغییرات روی سرور Live اعمال می شوند، باید تمامی اعضای تیم از این قضیه مطلع باشند تا در صورت بروز هرگونه مشکلی، خیلی سریع بتوان آن را مرتفع ساخت.

در واقع Production Deployment شکل‌های مختلفی دارد که بسته به ماهیت اپلیکیشن، می‌توان یکی از آن‌ها را انتخاب کرد:
- جایگزین -Override- کردن کدهای قدیمی با کدهای جدید از طریف اف تی پی
- پیاده‌سازی نسخه یی جدید از اپلیکیشن روی سرور به موازات نسخه ی قبلی و هدایت کردن کاربران به نسخه ی جدید با تغییر کانفیگ سرور
- استفاده از یک سرور کاملاً جدید حاوی آخرین ریلیس و ریدایرکت کردن ترافیک از سرور قدیمی به سرور جدید

چه موقع Rollback کنیم؟
گاهی اوقات در فرایند توسعه نرم‌افزار پیش می‌آید که همه چیز به خوبی پیش نمی‌رود و بلافاصله پس از Deployment یا «فرستادن آخرین نسخه روی سرور اصلی» اپلیکیشن می ترکد! در چنین شرایطی ما نیاز به Rollback کردن داریم. به عبارت دیگر، اپلیکیشن خود را به آخرین ورژنی که به درستی کار می‌کرد باز گردانیم. گاهی اوقات با Rollback کردن نه تنها مشکل برطرف نمی شود، بلکه چندین مشکل دیگر نیز ایجاد می‌گردد؛ لذا در چنین شرایطی کاملاً باید با احتیاط عمل کنیم. زمانی که نیاز به رول بک پیدا کردید، پیش از هرگونه اقدامی، سؤالات زیر را از خود بپرسید؟

آیا مشکل به خاطر کدی که Deploy کردید بوجود آمد یا دلیل دیگری وجود دارد؟ شما صرفاً زمانی می‌توانید رول بک کنید که مشکل بوجود آمده مرتبط با فایل‌هایی باشد که آپلود کرده‌اید و در غیر این صورت، رول بک کاری از پیش نخواهد برد! ممکن است دقیقا در زمانی که شما آخرین ریلیس را آپلود می کنید، یک مشکل سروری هم بوجود آید و شما فکر کنید که مشکل از آخرین آپدیت بوده و کاملا گمراه شوید.

آیا رول بک کردن امکان‌پذیر است؟ هر Release یا نسخه یی از اپلیکیشن قابل رول بک کردن نیست؛ فرض کنید که آخرین ریلیس نرم‌افزار شما حاوی اسکمای متفاوتی از دیتابیس است که در چنین شرایطی رول بک کردن اوضاع را وخیم تر هم می کند.

به هر حال، اگر پاسخ شما به دو سؤال فوق «آری» است، با خیال راحت می‌توانید رول بک کنید اما توجه داشته باشید که پاسخ آری دادن به دو سؤال بالا هرگز کاری آسان نیست.

نکته ی دیگری که در ارتباط با ریلیس نسخه های جدید نرم‌افزار باید مد نظر قرار داد، مفهومی است تحت عنوان Automatic Deployments to Production که این اصطلاح حاکی از آن است که ما به صورت اتوماتیک، آخرین تغییرات را بلافاصله روی سرور اصلی آپلود کنیم. به طور مثال، می‌توان نرم‌افزار اف تی پی را به گونه یی تنظیم کرد که بلافاصله پس از مشاهده ی تغییری در هر فایلی، آن فایل را جایگزین فایل متناظر روی سرور کند (جهت آشنایی بیشتر با مفهوم اف تی پی، به آموزش اف تی پی چیست؟ مراجعه نمایید.)

چنین کاری را می‌توان به عنوان یکی از پر ریسک ترین و خطرناک ترین کارها در فرایند توسعه ی نرم‌افزار قلمداد کرد و شدیدا باید از آن پرهیز کرد. فرض کنید توسعه‌دهنده یی به اشتباه کدی را تغییر می‌دهد و آن کد هم بلافاصله روی سرور آپلود می‌شود و فرایند اجرای صحیح نرم‌افزار دچار اختلال می شود.






# به‌کارگیری درست از اصول برنامه‌نویسی شیٔ‌گرا

در برنامه نویسی شیء گرا مفهومی داریم تحت عنوان Encapsulation که به زمانی اطلاق می‌شود که ما Attribute ها وBehavior های یک آبجکت را در کپسولی فرضی در کنار یکدیگر قرار می دهیم. علاوه بر این، با به کارگیری مفهومی تحت عنوان Encapsulation ما خواهیم توانست دسترسی به بخش یا بخش‌هایی از یک کلاس یا آبجکتی که بر اساس آن کلاس نوشته شده را محدود کنیم.

حال ممکن است این سؤال برای شما پیش بیاید که "اگر من خودم اقدام به ساخت یک کلاس می کنم، چه لزومی دارد که بخش یا بخش‌هایی از کلاس ساخته شده را از خودم پنهان سازم؟" در پاسخ به چنین سؤالی بایستی گفت که در اینجا قضیه پنهان کاری و … نیست، بلکه در اینجا منظور به حداقل رساندن وابستگی میان بخش‌های مختلف برنامه است. در چنین شرایطی، ایجاد یک تغییر کوچک در کلاس مد نظر -مثلا محدود کردن سطح دسترسی به برخی قابلیت‌های کلاس- فوراً روی تمامی آبجکت های ساخته شده از روی این کلاس اعمال خواهد شد. 

امروزه برخی برنامه نویسان را می‌بینیم که مثلاً کلاسی ساخته‌اند که یک متد main چند صد خطی دارد و یا کلاسی که صرفاً داری متدهای set و get است. چنین نمونه‌هایی حاکی از آنند که توسعه دهندگان هنوز با مفهوم واقعی شیء گرایی آشنا نشده اند.

پیش از این گفتیم که یک آبجکت دربرگیرنده ی یکسری Attribute ها وBehavior ها است و این در حالی است که رفتار آبجکت بسته به فضایی که در آن قرار گرفته متغیر است. برای روشن شدن این مسأله مثالی می زنیم. فرض کنیم یک درب منزل داریم. این در، می‌تواند چهار State (یا حالت) مختلف داشته باشد: بسته، باز، در حال بسته شدن و در حال باز شدن اما این درب منزل به هر حال دارای دو عملکرد بیشتر نیست: باز شدن و بسته شدن و بسته به حالتی که در آن قرار دارد، عملکردهای باز و بسته رفتارهای متفاوتی می توانند داشته باشند.

برای روشن تر شدن مطلب، مثالی از دنیای برنامه نویسی بزنیم. فرض کنیم سه کلاًس داریم تحت عناوین Customer, Order و Item. کلاس Customer برای نگهداری اعتبار حساب مشتریان و سایر مسائل مربوطه مورد استفاده قرار می گیرد. آبجکتی هم که از روی کلاس Order ساخته می‌شود مسئول سفارش‌های مربوط به یک مشتری را هندل می‌کند و آبجکت های ساخته شده از روی کلاس Item هم مسئول اضافه کردن محصول به سبد خرید هستند. داشتن چنین کلاس هایی حاکی از آنند که ما به درستی اصول برنامه نویسی شیء گرایی را به کار می گیریم.

اما در مقابل، برنامه نویسانی که تجربه ی کمتری در زمینه ی شیء گرایی دارند تمامی منطق نرم افزاری خود را مثلاً در کلاسی تحت عنوان OrderService قرار داده و بسته به نیاز خود آبجکت هایی از روی آن می سازند که این اصلا کار درستی نیست! به عنوان فصل الخطاب، سعی کنید تا حد ممکن یکی از  اصول مهم برنامه نویسی شیء گرا یعنی Encapsulation را در حین کدنویسی رعایت کنید.






# اعداد اعشاری با خطای محاسباتی در کامپیوتر ذخیره می‌شوند

در این بخش می خواهیم در مورد اعداد اعشاری و نحوه ی ذخیره ی آن ها در کامپیوتر صحبت کنیم، بنابراین بهتر است در ابتدا تعریفی از این نوع اعداد با ذکر مثالی داشته باشیم. 

یک خط کش ۱۰ سانتی متری را در ذهن خود متصور شوید؛ حال عدد ۳/۶ را روی این خط کش فرضی در نظر بگیرید. این عدد از 3 بزرگتر و از 4 کوچکتر است. برای نشان دادن این که این عدد چقدر از 3 بزرگتر و از 4 کوچکتر است از علامت ممیز یا اعشار / استفاده می کنیم که به طور کلی، به این دست اعداد «اعداد اعشاری» می گوییم. بنابراین می توان گفت که یک عدد اعشاری بین دو عدد صحیح قرار دارد.

برای تعریف اعداد صحیح در کامپیوتر از استانداردهای IEEE استفاده می شود. بر اساس این استاندارد برای ذخیره ی هر عدد اعشاری سه فیلد در نظر گرفته می شود:
- اعشار یا مانتیس
- توان
- علامت

برای مثال، بر طبق این استاندارد داریم:

101 × 2.7495 = 27.495

که 2.7495 مانتیس، 1 توان و علامت آن نیز مثبت است (البته اعداد در کامپیوتر در پایه ی 2 ذخیره می شوند نه پایه ی 10).

هر پیاده سازی اعداد اعشاری تعداد مشخصی بیت را برای مانتیس در نظر می گیرد، به عبارت دیگر تعداد اعداد قابل ذخیره سازی در کامپیوتر با محدودیت مواجه است. برای مثال برای ذخیره ی اعداد اعشاری در سیستم های ۳۲ بیتی، برای مانتیس ۲۳ بیت در نظر گرفته شده است. این موضوع باعث می شود که نتوانیم اعداد اعشاری که نمایش آن ها دارای تعداد رقم اعشاری متناهی نیست را به طور دقیق در کامپیوتر ذخیره کنیم.

برای ذخیره سازی هر عدد بسته به فضای اختصاص داده شده به مانتیس، ابتدا عدد مورد نظر گرد می شود و سپس در کامپیوتر ذخیره می شود؛ به همین دلیل ممکن است نمایش یک عدد اعشاری در کامپیوتر 32 بیتی با کامپیوتر 64 بیتی متفاوت باشد، چرا که فضای اختصاص داده شده به مانتیس در آن ها متفاوت است.

بنابراین باید توجه داشته باشیم که امکان ذخیره سازی دقیق تمام اعداد حقیقی که بخش اعشاری آن ها دارای تعداد نامتناهی رقم است در کامپیوترها وجود ندارد و به دلیل این نوع ذخیره سازی در زمان کدنویسی و انجام محاسبات روی اعداد صحیح ممکن است با خطای گرد کردن یا Roundoff Error مواجه شویم و جواب های غیر قابل انتظار از محاسبات کامپیوتری دریافت کنیم. بنابراین می توان گفت که بهتر است در برنامه هایی که نیازمند محاسبات دقیق هستند تا حد امکان از اعداد اعشاری استفاده نکنیم.






# جاه طلبی خود را با شرکت در پروژه های متن باز برآروده کنید!

اگر شما برنامه نویسی باشید که در یک شرکت آی تی کار می‌کند، به احتمال قریب به یقین هر روز روی پروژه هایی کار می‌کنید که اصلاً جذاب نیستند به طوری که بارها و بارها می بایست یک کار واحد را انجام دهید؛‌ مثلاً بخش لاگین یک سایت را بنویسید و یا سیستم مالی یک نرم‌افزار حسابداری را تکمیل کنید.

در چنین شرایطی حس جاه طلبی که یکی از خصیصه های اصلی اکثر توسعه دهندگانی است که دوست دارند کارهای کارهای خارق‌العاده یی انجام دهند تحت هیچ عنوان ارضاء نمی‌شود و نتیجه این که پس از مدتی از کار خود خسته می‌شوند. خبر خوشحال کننده برای این دست توسعه دهندگان این است که می‌توانند شروع به کار روی پروژه های اپن سورس کنند چرا که در چنین شرایطی می‌توانند واقعاً چیزی را که دوست دارند کدنویسی کنند.

امروزه به یمن پلتفرم هایی همچون گیت هاب و غیره، هزاران پروژه ی اپن سورس پرطرفدار وجود دارد که بخش قابل توجهی از آن‌ها فعال بوده و توسعه دهندگان بسیاری روی آن‌ها کار می‌کنند. این پروژه های اپن سورس طیف گسترده یی را شامل می شوند؛ از سیستم عامل گرفته تا هوش مصنوعی، ربات ها، یادگیری ماشینی و غیره به طوری که برای هر سلیقه یی، می‌توان یک پروژه ی مناسب یافت!

چیزی که در زمینه ی پروژه های اپن سورس همواره می بایست مد نظر داشت، این است که کار کردن روی این دست پروژه ها هیچ گونه عایدی برایتان نخواهد داشت؛ لذا اگر به دنبال کسب درآمد از طریق مشارکت در پروژه های اپن سورس هستید، بایستی بگوییم که متأسفانه مسیر نادرستی را انتخاب کرده اید.

گرچه کار کردن روی پروژه های اپن سورس عایدی چندانی به صورت مستقیم برای توسعه دهندگان ندارد، اما خبر خوب این که مشارکت در این پروژه های اپن سورس منجر به تقویت رزومه ی توسعه‌دهنده شده به طوری که در آینده فرصت های شغلی به مراتب بهتری برایش رقم خواهد خورد و زمانی که روی توسعه ی پروژه های اپن سورس صرف کرده است، به شکلی دیگر جبران خواهد شد!

علاوه بر ارضاء شدن حس درونی توسعه‌دهنده پس از مشارکت در پروژه های اپن سورس، اتفاقات خوبی دیگر نیز در انتظار وی هستند که از آن جمله می‌توان به این نکته اشاره کرد که ما با کار کردن روی پروژه های اپن سورس، با نحوه ی کدنویسی سایر برنامه نویسان سراسر دنیا آشنا شده و خواهیم دید که یک توسعه‌دهنده دیگر، چه راه‌کاری برای مسأله یی یکسان به در نظر گرفته است و همین مسأله می‌تواند به بهبود رویکردمان در برنامه نویسی کمک کند.

در ضمن، زمانی که ما در یک پروژه ی اپن سورس مشارکت می‌کنیم و بخشی که کدنویسی کرده‌ایم مورد قبول واقع می‌گردد -البته در بسیاری مواقع هم سورس ما صد در صد رد خواهد شد- این مسأله می‌تواند به افزایش اعتماد به نفس ما کمک کند. چه چیزی بهتر از این که در حوزه ی فناوری اطلاعات فرد تأثیر گذاری باشیم و کمک به توسعه ی چیزی کنیم که تا سال‌های سال، چندین هزار نفر کاربر عادی از آن استفاده کرده و لذت ببرند!

پس به راحتی می‌توانید شروع به کار روی پروژه های اپن سورس کنید، باگ های احتمالی آن‌ها را بیابید، پیشنهاداتی به منظور بهبود عملکرد پروژه بدهید، دوستان اپن سورسی دیگری از سراسر دنیا پیدا کنید، روی نرم‌افزار که دوست دارید کار کنید و در کل، از کاری که می‌کنید لذت ببرید!






# قانون طلایی طراحی API

به طور کلی، طراحی API کار دشواری است مخصوصاً اگر قصد طراحی برای سیستم‌های بزرگی را داشته باشیم؛ اگر شما قصد طراحی API را در سر می پرورانید که در آینده یی نه چندان دور چندین هزار کاربر از API شما استفاده خواهند کرد، حتماً می‌باید به این موضوع هم فکر کنید که تغییرات احتمالی در آینده چه اتفاقی برای کاربران رقم خواهد زد و اگر یک تغییر کوچک در API خود دادید، کاربران چگونه می‌باید با این تغییر کنار بیایند!

علاوه بر این، توجه به این نکته که کاربران API مثلاً چگونه با Override کردن برخی متدهای کلاس‌های API شما، سرویس تان را تحت تأثیر قرار خواهند داد نیز حائز اهمیت است. یکی از استراتژی هایی که توسعه‌دهندگان از آن تبعیت می‌کنند، محدود کردن سطح دسترسی کاربران است؛ به طور مثال، در زبان جاوا بسیاری از متدها را می‌توان final کرد و در زبان سی‌شارپ، می‌توان از کیورد sealed استفاده کرد تا جلوی دستکاری سیستم توسط کاربران را گرفت اما این تمام ماجرا نیست.

ما با نوشتن Unit Testها، تا حدودی می‌توانیم از صحت عملکرد API خود اطمینان حاصل کنیم اما این کافی نیست! قانون طلایی طراحی ای‌پی‌آی حاکی از آن است که «علاوه بر نوشتن یونیت تست برای ای‌پی‌آی، خود را جای کاربران ای‌پی‌آی گذاشته و اقدام به استفاده ی واقعی از ای‌پی‌آی کنید!» که در چنین شرایطی، خواهید دید که کاربران با چه مشکلاتی دست و پنجه نرم خواهند کرد، مشکلات احتمالی چیست، راه های در رو کدامند و ...






# کسی که چند سال است کدنویسی می‌کند، اصلاً علامهٔ دهر نیست!

افرادی که چند سالی است در حوزه ی توسعه ی اپلیکیشن و برنامه نویسی کار می‌کنند و جزو حرفه یی های این حوزه محسوب می شوند، مسلماً حداقل یک بار با سؤال یا سؤالاتی از این دست رو به رو شده اند که «من فلان مشکل را در سورس کد خود دارم، می دونی مشکل از کجاست و چطور می‌شود آن را رفع کرد؟»

کسانی که معمولاً از این دست سؤالات می‌پرسند، اطلاعات چندانی از ارور لاگ ها و یا شرایطی که منجر به ایجاد مشکل مربوطه می‌شوند در اختیار شما نمی‌گذارند؛ ایشان بر این باروند که یک توسعه‌دهنده ی حرفه یی علامه ی دهر است و پاسخ به هر سؤالی را می‌داند و بلد است که چگونه هر باگی را دیباگ کند!

به طور کلی، چنین رویکردی را به کرات می‌توان در برنامه نویسان مبتدی مشاهده کرد؛ ایشان بر این باورند که منتور ایشان یا برنامه نویس ارشد تیم توسعه ی نرم‌افزار پاسخ به هر سؤالی را باید بداند بدون آن که جزئیاتی دقیق از مشکل مربوطه را در اختیارش قرار دهند.

در دنیای برنامه نویسی، به کسانی که تجربه ی زیادی در کدنویسی دارند اصطلاحاً Guru گفته می‌شود اما همواره باید این نکته را به خاطر داشته باشیم که Guru ها هم همچون سایر افراد هستند با این تفاوت که به مسائل و مشکلات از زوایای مختلفی نگاه می‌کنند، تفکر الگوریتمیک دارند، کنجکاو هستند و زود دست از تلاش نمی کشند. لذا این دیدگاه که یک برنامه نویس باتجربه می بایست پاسخ به تمامی سوالات را بداند، دیدگاهی کاملا اشتباه است.






# کار زیاد ضمانت موفقیت در برنامه‌نویسی نیست!

به عنوان یک برنامه نویس، دیر یا زود متوجه خواهید شد که گرچه زیاد کار کردن و سخت کوشی شرط لازم برای موفقیت در این حوزه است، اما هرگز شرط کافی نبوده و صرفاً با کار زیاد نمی‌توان به موفقیت‌های چشمگیری در این زمینه دست یافت.

به طور مثال، فرض کنیم که شما و تعدادی از همکارانتان روی پروژه یی در حال کار کردن هستید؛ ماندن زمان های طولانی در آفیس یا شرکت و کد زدن روی پروژه هرگز بدان معنا نیست که شما ارزش بیشتری در این پروژه می آفرینید. گاهی اوقات پیش می‌آید که حتی با کمتر کار کردن، شما می‌توانید ارزش بیشتری برای تیم نرم افزاری خود رقم بزنید. حال ممکن است بپرسید که چطور؟

برنامه نویسی و به طور کلی توسعه ی نرم‌افزار دربرگیرنده ی یادگیری مداوم است؛ هرچه شما بیشتر روی پروژه یی وقت می‌گذارید، بیشتر با جنبه‌های مختلف پروژه آشنا شده و بالتبع زوایای بیشتری از پروژه را درک کرده که در نهایت می‌توانند منجر به یافتن راه کارهای به مراتب بیشتر و بهینه‌تری گردند.

برنامه نویسی حرفه یی همچون دوی سرعت نیست که شما موظف باشید یک مسیر مشخص را در سریع‌ترین زمان ممکن طی کرده تا به انتهای مسیر برسید. بسیاری از پروژه های برنامه نویسی همچون صخره نوردی است؛ به عبارت دیگر، هرگز نمی‌توان این‌گونه تصور کرد که یک مسیر از صخره ها را انتخاب کرده و با بیشترین سرعت ممکن از آن‌ها بالا رفت. پروژه های برنامه نویسی نیاز به تحلیل فرایندها -یا در صخره نوردی تحلیل مسیرهای مختلف و کم خطر- دارند و شما به عنوان یک برنامه نویس حرفه یی می بایست با سرعتی یکنواخت به مسیر خود ادامه داده و هر کجا که احساس کرده‌اید مسیر را اشتباه رفته اید،‌ بازگشته و مسیر به مراتب بهتری اتخاذ نمایید.

علاوه بر این، یک برنامه نویس خوب می بایست همواره تشنه ی یادگیری اطلاعات عمومی در زمینه ی توسعه ی نرم‌افزار از یک سو و همچنین یادگیری تکنیک های برنامه نویسی با زبان مد نظر به صورت تخصصی از سوی دیگر باشد. در این راستا، نیاز به مطالعه ی کتب مختلف، شرکت در سمینار/وبینارهیا مربوطه، ارتباط با افراد حرفه یی این حوزه، امتحان کردن ابزارهای جدیدی که به بازار عرضه شده‌اند و … خواهید داشت.

به عنوان یک برنامه نویس حرفه یی، همان‌طور که مثلاً پزشکان خود را آپدیت نگاه می‌دارند تا بتوانند جان بیماران خود را نجات دهند، نیاز دارید تا آپدیت باشید و همواره از آخرین دستاوردهای حوزه ی کاری خود مطلع بوده و آن‌ها را به خدمت گیرید.

به جای این که در زمان استراحت خود -بعد از ظهرها، آخر هفته‌ها و در تعطیلات- کماکان روی پروژه یی که در دست دارید کد بزنید، این زمان گرانبها را به مطالعه در حوزه ی کاری خود اختصاص دهید و پس از مدت زمانی -مثلا ۶ ماه- تفاوت چشمگیری در توانمندی‌های خود مشاهده خواهید کرد.

 






# چگونه به یک باگ نگاه کنیم؟

برخی توسعه دهندگان برچسب «باگ» روی مسائل خارج از عرف نرم افزاری می‌گذارند و برخی دیگر صرفاً به «مشکل» اکتفا می‌کنند؛ خواه این مسائل را باگ بنامییم خواه مشکل، آن‌ها وجود دارند و به راحتی می‌توانند موفقیت نرم‌افزار ما را تحت الشعاع قرار دهند و یکی از مهارت های اصلی هر توسعه‌دهنده ی حرفه یی، این می‌تواند باشد که چگونه باگ های یک نرم‌افزار را رصد کند و تمام تلاش خود را به کار گیرد تا آن‌ها را مرتفع سازد.

برای رفع باگ ها، ما پیش از هر چیز به یک ‌Bug Report (باگ ریپورت) نیاز داریم تا بیش از پیش، با خصوصیات باگ احتمالی آشنا شده و دیگر اعضای تیم را نیز در جریان قرار دهیم؛ یک باگ ریپورت خوب از ویژگی‌های زیر برخوردار است:
- نحوه ی کار با نرم‌افزار به گونه یی که منجر به مشاهده ی باگ شود را ارائه می‌دهد؛ علاوه بر این، به ما می‌گوید که این باگ هر چند وقت یک بار پدید می‌آید.
- به نظر شما چه اتفاقی باید افتاده باشد که این باگ ایجاد شده؟
- گزارشی کامل از اتفاقاتی که رخ داده‌اند به منظور درک بهتر ماهیت باگ و در صورت امکان، ارائه ی دلیل اصلی پدید آمدن باگ

کمیت و کیفیت اطلاعاتی که ما از یک باگ پیدا می‌کنیم دارای ارتباطی مستقیم با فرایند Debugging (دیباگینگ یا رفع مشکل) است. به یاد داشته باشیم زمانی که با یک باگ در نرم‌افزار خود مواجه می‌شویم، تحت هیچ عنوان دست به انکار آن نزده و یا مشکل بوجود آمده را به گردن سایر اعضای تیم نیندازید! بلکه تا حد ممکن اطلاعات مرتبط در مورد باگ مربوطه کسب نمایید و در صدد رفع آن برآیید.






# با حذف کدهای اضافی، سورس‌کد خود را بهبود بخشید

آمریکایی ها شعاری دارند تحت عنوان Less Is More با این مضمون که «هرچه کمتر، بهتر!» و شاید بتوان گفت که این جمله خیلی کلیشه یی است و ممکن است در بسیاری مواقع کاربرد نداشته باشد، اما حداقل در کدنویسی کاربرد دارد به این شکل که با حذف کلاس‌ها، فانکشن ها و بلوک های کد اضافی از سورس کد خود، در نهایت سورس کد به مراتب بهتر و تمیزتری در اختیار خواهید داشت.

گاهی اوقات در حین کدنویسی فکر می‌کنیم که یکسری کارها به بهبود نرم‌افزار ما منجر خواهند شد اما در نهایت کاشف به عمل می‌آید که در حین اجرا، باعث کاهش راندمان نرم‌افزار می‌شوند و تنها در صورت حذف آن‌ها است که بهبودی حاصل می‌شود. در کدنویسی همواره می بایست این نکته را به خاطر داشته باشیم که باید کدی بنویسیم که «ارزشی برای نرم‌افزار ما بیاورد نه این که صرفاً از نوشتن آن لذت ببریم».

گاهی اوقات هم در تحلیل نرم‌افزار و مراحل اولیه ی کدنویسی، فکر می‌کنیم که یک قابلیت ممکن است در آینده به کارمان آید، لذا با خود فکر می‌کنیم که زمان زیادی از ما نمی‌برد و آن را در سورس کد خود می گنجانیم اما همواره به یاد داشته باشیم که اگر به قابلیتی در حال حاضر نیاز نداریم، نیاز به نوشتن آن نیست!






# برنامه‌هایی که می‌نویسید را کاربرپسند کنید

اگر به فولدر Downloads سیستم خود نگاهی بیندازید، و ببینید که پر است از فایل‌های zip و exe که شاید حتی یک بار هم آن‌ها را استفاده نکرده باشید! شما جزو آن دسته از کاربرانی هستید که علاقمند به جمع آوری هرگونه نرم افزاری -از نرم افزاری های گرافیکی گرفته تا هک و غیره- هستید.

در نقطه ی مقابل این دست کاربران، کاربرانی هستند که خیلی وسواسی هستند و دوست دارند که سیستم خود را تا حد ممکن تمیز نگاه دارند و صرفاً نرم افزارهایی را روی آن نصب کنند که به آن ها نیاز دارند. این دست کاربران خیلی برایشان مهم است نرم افزاری که Install می‌کنند، قابلیت Uninstall شدن داشته باشد؛ لذا اگر برنامه یی نوشته‌اید که نمی‌توان را آن را حذف نمود و یا اگر می‌شود، به سختی این کار صورت می‌گیرد، به طور حتم نظر مساعد این دست از کاربران را از دست خواهید داد.

اگر برنامه یی که نوشته‌اید که Graphical User Interface (یا به اختصار GUI به معنی رابط کاربری گرافیکی) دارد، تا حد ممکن مراحل انجام کار را ساده نگاه دارید و همچون نرم افزارهای شرکت ادوبی، از منوهای تو در تو و گاها گیج‌کننده استفاده نکنید.

اگر یک لایبرری نوشته اید، بهتر است که در سایت مربوطه یا صفحه ی گیت هاب لایبرری خود، راهنمایی خلاصه و مفید از نحوه ی کارکرد لایبرری خود در نظر بگیرید. نیاز به توضیح نیست که لایبرری های رغیب همیشه ادعا می‌کنند به بهینه‌تر هستند، راحت‌تر هستند، سبک‌تر هستند و بسیار مزیت دیگر؛ لذا اگر به هر دلیلی در چند دقیقه ی اول نتوانید مشتری بالقوه ی خود را به مشتری بالفعل درآورید، این رقبای شما هستند که برنده ی بازی خواهند بود.

به طور کلی، شما به عنوان یک توسعه‌دهنده ی نرم‌افزار -خواه یک پروژه ی اپن سورس برای تفنن بنویسید و خواه پروژه ی بزرگ یک مشتری را کدنویسی کنید- می بایست این نکته را مد نظر داشته باشید که کاربران نرم افزاری بسیار بی‌وفا هستند و به محض آن که نرم افزاری بیابند که از نرم‌افزار شما ارزان‌تر، کاربرپسندتر، بهینه‌تر و در کل اثربخش تر باشد، به سمت رقبای شما خواهند رفت؛ لذا وقتی کدنویسی می‌کنید، به نیازهای پایه یی کاربران -که اغلب اوقات آنقدر بدیهی هستند که از قلم می‌افتند- تمام توجه خود را به کار گیرید.






# فرایندهای برون برنامه‌ای، زمان پاسخگویی نرم‌افزار را تحت‌الشعاع خود قرار می‌دهند

یکی از چیزهایی که در ارزیابی کیفیت یک نرم‌افزار مورد توجه قرار می‌گیرد، Response Time (ریسپانس تایم یا زمان پاسخگویی) نرم‌افزار است. این نرم‌افزار می‌تواند یک وب سایت آنلاین باشد و یا یک نرم‌افزار حسابداری که روی سیستم خود نصب می‌کنیم؛ هرچه که باشد، اگر نوع کاربری نرم‌افزار به گونه یی باشد که کاربران نیاز به تعامل مکرر با سیستم داشته باشد، ریسپانس تایم نقش تعیین کننده در تجربه ی کاربری نرم‌افزار ایفا می‌کند به طوری که اگر کاربری کاری را انجام دهد و چند ثانیه منتظر بماند تا سیستم پاسخ وی را بدهد، این حس به کاربر نرم افزارمان دست که می‌دهد که وقت اش تلف می‌شود.

ریسپانس تایم یکی از چیزهایی است که در فرایند تحلیل نرم افزار، طراحی پایگاه داده و همچنین الگوریتم های به کار گرفته شده در سیستم می بایست مد نظر قرار داده شود؛ علاوه بر این موارد، نکته ی دیگری هم وجود دارد که در زیاد شدن ریسپانس تایم دخیل است و آن هم چیزی نیست جز برقراری ارتباط با سایر نرم‌افزارها همچون وب سرویس ها و …

فرض کنیم که نرم افزاری نوشته‌ایم که قیمت روز خودرو را از یک API گرفته و در دسترس ما قرار می‌دهد؛ زمانی که کاربر مثلاً روی دکمه ی خودروهای داخلی کلیک می‌کنید، یک ریکوئست برای API مد نظر ارسال می‌شود تا قیمت خودروها را از دیتابیس سرویس مربوطه گرفته و در قالب یک ریسپانس -که معمولاً در فرمت جیسون است- در اختیار ما قرار می‌دهد. حال اگر این API هرگونه تاخیری در گرفتن دیتای مد نظر داشته باشد، این تأخیر به حساب نرم‌افزار ما نوشته شده و ریسپانس تایم آن را افزایش می‌دهد که در نهایت منجر به ایجاد یک تجربه ی کاربری نامطلوب برای کاربرانمان می‌شود.

برای رفع این مشکل، راه کارهای متعددی را می‌توان اتخاد نمود؛ به عنوان مثال، می‌توان تعامل نرم‌افزار خود با مثلاً وب سرویس مربوطه را به حداقل رساند و در هر بار ریکوئست فرستادن، کمترین دیتای ممکن را درخواست کرد.

راه‌کار دیگری که می‌توان به کار برد این است که داده‌هایی که قبلاً به دست آمده را Cache کرد، بنابراین کاربران جدیدی که ریکوئست مشابهی ارسال می‌کنند، پاسخ خود را خیلی سریع از روی کش سیستم دریافت می‌کنند.

به طور کلی، ریسپانس تایم نقش تعیین کننده یی در موفقیت نرم افزارهایی که می نویسیم دارد و باید تمام تلاش خود را به کار بندیم تا آن را پایین نگاه داریم.






# بیلد (Build) اصولی ارائه کنید

در فرایند کدنویسی گاهی اوقات برایمان پیش می‌آید که با لیست بلند بالایی از ارورها در حین اجرای نرم‌افزار مواجه می‌شویم و این در حالی است که با خود می‌گوییم «ان شاء الله اگر فرصتی شد، همه ی ارورها را بعداً رفع خواهم کرد!»

زمانی که ما یک پروژه ی جدید را از پایه شروع به کدنویسی می‌کنیم، نه مشکلی وجود دارد و نه اروری اما همین که سورس کد ما به مرور زمان حجیم و حجیم تر می‌شود، احتمال این که ارورها، هشدارها و اکسپشن ها زیاد شوند هم بالا می‌رود و این در صورتی که اگر این ارورها را به‌ موقع رفع نکنیم، در آینده رفع کرد یک هشدار کوچک می‌تواند به دردسری بزرگ مبدل گردد!

یکی از استراتژی های خوب در حین کدنویسی، به کارگیری سیاست Zero-tolerance Policy است؛ در‌ واقع این سیاست حاکی از آن است که IDE و محیط توسعه ی نرم افزار خود را به گونه یی تنظیم کنیم که هرگونه هشدار، خطا و اروری را به ما گوشزد کند حتی اگر خیلی کوچک و در ظاهر بی اهمیت باشند.

برای درک بهتر این موضوع، مثالی از دنیای واقعی می‌زنیم؛ واژه ی «درد» معانی و تعاریف مختلفی می‌تواند داشته باشد. به طور مثال، اگر بخواهیم درد را تعریف کنیم، می‌توانیم از آن به عنوان یک «مکانیسم اطلاع رسانی» یاد کنیم. اگر درد وجود نداشت، ما به سادگی گرمای بیش از حد را نمی توانستیم حس کنیم و بالتبع از آن دوری کنیم و ممکن بود صدمات جبران ناپذیری به بدن خود وارد کنیم.

در کدنویسی هم قضیه دقیقاً به همین شکل است؛ وجود ارورها، هشدارها و اکسپشن ها اصلاً چیز بدی نیستند چرا که همین هشدارها هستند که ما را از وجود باگی در سورس کد خود مطلع می‌کنند و باید قدر آن‌ها را دانست. در چنین شرایطی است که وقتی ما نرم افزار خود را Build می کنیم، نسخه ی بیلد شده ی سورس کد ما اصولی است و سایر توسعه دهندگانی که با آن‌ها روی یک پروژه کار می‌کنیم تا حد ممکن کمتر سردرگم خواهند شد.

نکته به طور کلی، در شاخه ی برنامه نویسی و توسعه ی نرم‌افزار، Build به فرایندی گفته می‌شود که در آن سورس کد به برنامه یی قابل اجرا و قابل استفاده مبدل می‌گردد که معمولاً با یک شناسه -مثلا ۱۷- شناخته می‌شود که قبل از انتشار نهایی نرم‌افزار و در فرایند تست نرم افزار ایجاد می‌گردد. یکی از فرایندهای مهم در بیلد کردن، کامپایل کردن سورس کد است که در این فرایند سورس کد نرم‌افزار به کدهای قابل اجرا توسط ماشین تبدیل می‌شوند.






# استفادهٔ بهینه از ابزارهای کامندلاینی

امروزه بسیاری از ابزارهای توسعه ی نرم‌افزار در IDE ها به صورت پیکج های از پیش نصب شده در اختیار توسعه‌دهندگان قرار می‌گیرند و همین مسئله منجر به محبوبیت بیش از پیش IDE در مقایسه با ادیتورهای کد در میان توسعه‌دهندگان می‌شود چرا که نه تنها کدنویسی با این محیط‌های توسعه راحت تر است، بلکه برنامه‌نویس دیگر نیازی نخواهد داشت تا به یک سری جزئیات همچون فرایند کامپایل کردن و … فکر کند.

به خاطر داشته باشید IDE مخفف واژگان Integrated Development Environment به معنی «محیط توسعه ی یکپارچه ی نرم‌افزار» است که از مهم‌ترین آن‌ها می‌توان به ویژوال استودیو، اکلیپس و نت بینز اشاره کرد.
سهولت در استفاده از IDE ها گرچه به عنوان یکی از نقاط قوت این دست نرم‌افزارها محسوب می‌گردد، اما IDE ها عاری از هر گونه عیبی هم نیستند! زمانی که ما می‌گوییم استفاده از یک نرم‌افزار بسیار سهل و آسان است، این بدان معنا است که نرم‌افزار بسیاری از کارها را به صورت خودکار انجام می‌دهد؛ به عبارت دیگر، بسیاری از تصمیماتی که بر عهده ی توسعه‌دهنده هستند را خود نرم‌افزار می‌گیرد و به همین دلیل هم هست که توسعه‌دهندگان ی که صد در صد وابسته به IDE انتخابی خود هستند -خواه ویژوال استودیوی مایکروسافت یا گزینه‌های اپن‌سورسی همچون اکلیپس- در یک سری از مواقع اصلاً متوجه نمی‌شوند که سورس‌کد ایشان چگونه بیلد می‌شود و ابزارهای مختلف دقیقاً چه کاری انجام می‌دهند (به طور مثال، شما یک دکمه را در اندروید استودیو می‌زنید و خروجی apk حاضر و آماده در اختیار شما قرار می‌گیرد.)

در نقطه ی مقابل توسعه‌دهندگان ی که کاملاً وابسته به IDE ها هستند، برنامه‌نویسانی قرار دارند که از ابزارهای کامند لاینی استفاده می‌کنند؛ این دست برنامه‌نویسان زمانی که یک برنامه را بیلد می‌کنند -البته با استفاده از ابزارهای کامند لاین- دقیقاً می‌توانند متوجه شوند که پشت پرده چه اتفاقاتی رخ می‌دهد.

برای شروع کار با ابزارهای بیلد کردن کامند لاین، می‌توان از نمونه‌های اپن‌سورسی همچون GCC شروع کرد. زمانی که شما شخصاً اقدام به کامپایل کردن، اسمبل کردن و لینک کردن سورس‌کد خود می‌کنید و در نهایت یک بیلد نهایی به دست می آورید، کاملاً با فرایند های توسعه ی نرم‌افزار آشنا خواهید شد و از آن پس، یک IDE برایتان صرفاً نرم‌افزاری گرافیکی است که یک سری ابزارهای کامند لاینی را در خود جای داده است.

علاوه بر این که پس از استفاده از ابزارهای کامند لاین برای بیلد کردن سورس‌کد خود به ماهیت فرایندها پی می برید، یک سری کارهای دیگری نیز می‌توانید انجام دهید که در مقایسه با IDE ها از سهولت و اثربخشی بیشتری برخوردارند؛ برای مثال، ابزارهای جستجو و جایگزین کردنی همچون grep و sed گاهی اوقات از گزینه‌هایی که در نرم‌افزارهای گرافیکی در اختیار توسعه‌دهندگان قرار می‌گیرد اثربخش تر هستند.

در ضمن، ابزارهای کامند لاینی امکان اسکریپت‌نویسی -خودکار کردن یک سری کارهای تکراری- را نیز به شما می‌دهند تا مثلاً در بازه های زمانی مشخص، نسخه‌های مختلفی از نرم‌افزار بیلد شده و ذخیره گردد.

حال سؤالی که اینجا مطرح می‌شود این است که مگر به غیر از این است که IDE ها برای راحتی کار برنامه‌نویسان و افزایش بازدهی ایشان طراحی و ساخته شده‌اند؟ اگر پاسخ به این سؤال آری است، پس چرا باید برنامه‌نویسان را تشویق به استفاده از ابزارهای کامند لاینی کنیم؟

پاسخ به سؤال فوق «آری» است اما نکته یی که در این آموزش یاد آور شدیم هرگز بدان معنا نیست که شما از امروز باید IDE خود را کنار بگذارید و کلاً به صورت کامند لاینی فرایند توسعه ی نرم‌افزار خود را دنبال کنید بلکه منظور این است که آشنایی با ابزارهای کامند لاینی، دید به مراتب بازتری به شما به عنوان یک برنامه‌نویس می‌دهند و زمانی که کاری را در نرم‌افزارهای گرافیکی انجام می‌دهید که صرفا با چند کلیک به هدف خود می‌رسید، متوجه می‌شوید که پشت پرده چه اتفاقاتی رخ می‌دهد و بهترین رویکرد برای درک این موضوع هم استفاده از ابزارهای کامند لاین است.

پس از آن که شما شروع به استفاده از ابزارهای کامند لاین کردید، هر وقت که با IDE خود کار کنید کاملاً متوجه می‌شوید که هر کلیک چه کاری انجام می‌دهد و با دید بازتری می‌توانید فرایند بیلد نرم‌افزار را کنترل کنید. نکته ی آخر هم این که وقتی به کامند لاین تسلط پیدا کنید، به احتمال قریب به یقین دیگر به سمت نرم‌افزارهای گرافیکی نخواهید رفت!






# یادگیری هم‌زمان بیش از یک زبان برنامه‌نویسی

فلسفه ی برنامه نویسی حاکی از آن است که «مهارت برنامه نویسی مستقیماً وابسته به پارادایم های مختلف برنامه نویسی که یک برنامه نویس برای کدنویسی مورد استفاده قرار می‌دهد و با آن‌ها احساس راحتی می‌کند است نه دانش اندکی که وی ممکن است از یک زبان برنامه نویسی دیگر داشته باشد!»

هر برنامه نویسی، با یک زبان برنامه نویسی پا به دنیای برنامه نویسی می‌گذارد و جالب است بدانیم که آن زبان، تأثیر بسزایی روی رویکرد فرد در مورد توسعه ی نرم‌افزار می‌گذارد؛ اصلاً مهم نیست که فرد برنامه نویس چند سال است که با زبان انتخابی اش کد می زند، بلکه مادامی که فرد در حال کار با آن زبان است، می‌توان گفت که فقط و فقط آن زبان را بلد است. جالب است بدانیم که برنامه نویسان اصطلاحاً تک-زبانه دایره ی فکر کردن خود را محدود به قابلیت‌های آن زبان می‌کنند اما برنامه نویسی که اقدام به یادگیری زبان دوم می‌کند، ذهنیت وی در مورد توسعه ی نرم‌افزار به چالش کشیده خواهد شد مخصوصاً اگر زبان دوم از لحاظ ساختاری دارای تفاوت‌های عمیقی نسبت به زبان اول باشد.

برای روشن‌تر شدن این مسأله مثالی می‌زنیم؛ زبان‌های سی، پاسکال و فورترن دارای مدل های ساختاری تقریباً یکسانی هستند به طوری که اگر کسی زبان سی را بلد باشد و زبان دومش را فوترن انتخاب کند، به طور حتم با چالش های خیلی زیادی مواجه نخواهد شد اما مهاجرت از زبان‌هایی همچون سی یا فوترن به زبان دیگری همچون سی پلاس پلاس یا آدا، برنامه نویس را با موقعیت های بسیار متفاوتی در زمینه ی نحوه عملکرد زبان برنامه نویسی مواجه خواهد ساخت و بالتبع مهاجرت از سی پلاس پلاس به هسکل هم چالشی مضاعف خواهد بود.

در‌ واقع پارادایم های برنامه نویسی مختلف من جمله Procedural یا رویه یی، Object-oriented یا شیء گرا، Functional یا تابعی و … وجود دارند که از لحاظ ساختاری دارای تفاوت‌هایی با یکدیگر هستند و در صورت مهاجرت در میان این پارادایم ها، می بایست منتظر چالش های فراوانی هم باشیم!

نکته یی که در اینجا می بایست مد نظر داشته باشیم این است که این چالش ها هرگز بد نیستند بلکه اتفاقاً باید به استقبال آن‌ها برویم چرا که پارادایم های مختلف برنامه نویسی، نگاه ما به توسعه نرم‌افزار را دگرگون می‌کنند چرا که مسأله یی خاص در یک زبان برنامه نویسی ممکن است به شیوه یی نسبتاً دشوار حل شود در صورتی که با توجه به پارادایم های اعمال شده در زبانی دیگر، پاسخ به آن مسأله با دردسرهای به مراتب کمتری در دسترس مان قرار گیرد و در چنین شرایطی است که ما می‌توانیم به ماهیت واقعی هر دو زبان پی ببریم.

به طور کلی، برنامه نویسان حرفه یی از یادگیری زبان‌های جدید اصلاً واهمه یی به خود راه نمی‌دهند و علاقمند به یادگیری زبان‌های جدید هستند؛ حتی اگر در کدنویسی روزمره ی خود، صرفاً از یک زبان برنامه نویسی استفاده کنند باز هم مشتاق به یادگیری زبان‌های دیگر هستند چرا که می‌دانند سایر زبان‌ها -مخصوصا اگر از پارادایم متفاوتی نسبت به آنچه زبان فعلی شان ارائه می‌کند- نگرش متفاوتی برای حل مسأله در اختیار ایشان قرار می‌دهند.

مدیران شرکت های نرم‌افزار می بایست بخشی از تایم کاری تیم توسعه ی نرم‌افزار خود را به یادگیری زبان‌های جدید اختصاص دهند حتی اگر قرار نباشد هیچ پروژه یی با زبان‌های جدید نوشته شود چرا که اتخاذ چنین رویکردی منجر به بازتر شدن دید برنامه نویسان شرکت نسبت به همان زبانی که به صورت روزمره مورد استفاده قرار می‌دهند می‌شود.

در پایان هم می بایست این نکته را یادآور شد که یادگیری یک زبان صرفاً به یادگیری سینتکس اش و نوشتن یک برنامه ی Hello World خلاصه نمی‌شود بلکه نیاز به ماه ها کار مستمر و نوشتن پروژه های مختلف با آن زبان و درگیر شدن با بخش‌های مختلف زبان دارد.






# محیط کد نویسی (IDE) خود را مثل موم در دست بگیرید

در دهه ی ۸۰ میلادی، برنامه نویسان محدود بودند به ویرایشگرهای کد ساده یی که اگر خیلی خوش شانس بودند، ویرایشگر کد ایشان به Syntax Highlighting مجهز بود! در آن دوران اگر کسی می‌خواست برنامه ی خود را دیباگ کند، می بایست ابزارهای مجزایی نصب کند و اصلاً این‌ گونه نبود که با یک کلیک، فرایند دیباگ آغاز شود بلکه نیاز به انجام فرایندهای مختلفی بود.

در دهه ی ۹۰، شرکت های نرم‌افزار متوجه خلائی در بازار برنامه نویسی شدند و آن هم چیزی نبود جز برنامه‌هایی کاربردی که می توانستند زندگی برنامه نویسان را ساده‌تر و در عین حال لذت بخش تر سازند و نتیجه این که IDE های مختلف به بازار عرضه شدند که قابلیت‌های جدید همچون کامپایلر، دیباگر و … را به نرم افزارهای ویرایشگر کد معمولی افزوده بودند.

در همین دوران بود که برنامه‌های کامپیوتری به «منو» های مختلف مجهز شدند و با‌ عرضه ی دیوایس «ماوس» به بازار، برنامه نویسان دیگر مجبور نبودند تا برای انجام کاری خاص، از ترکیب کلیدهای مختلف استفاده کنند بلکه به سادگی با نشانگر ماوس خود، می توانستند روی یکی از منوهای نرم‌افزار کلیک کرده و پشت پرده، کامند خاصی اجرا گردد.

پس از سال ۲۰۰۰، محیط های توسعه ی یکپارچه ی نرم‌افزار آنقدر رایج شدند که بسیاری از شرکت های نرم افزاری این IDE ها را به رایگان در اختیار برنامه نویسان قرار می‌دادند تا از این طریق شناخته تر شده و بتوانند سایر سرویس ها و محصولات خود را به فروش برسانند. این نرم‌افزارها از آن زمان تاکنون، روز به روز به ابزارهای بهتر و بیشتری مجهز شده اند به طوری که امروزه شاهد IDE هایی هستیم که قابلیت‌های منحصر به فردی همچون Automated Refactoring و یا Extract Method دارند.

نکته کاری که Extract Method انجام می‌دهد این است که بخشی از کد را انتخاب کرده، سپس نرم‌افزار آن بلوک کد را به یک متد با نامی خاص برایمان تبدیل می‌کند.
یکی دیگر از قابلیت‌های محیط های توسعه ی یکپارچه ی نرم‌افزار امروزی -IDE- این است که می‌توان در تنظیمات نرم‌افزار یکسری «قوانین» وضع کرد و از آن پس، هر موقع که آن قانون را نقض کنیم، یک هشدار در معرض دیدمان قرار خواهد گرفت. به طور مثال، می خواهیم در زبان پی اچ پی قانونی را نظر بگیریم که هر پراپرتی که در بدنه ی کلاس خود تعریف می‌کنیم، protected باشد؛ در چنین شرایطی، هر موقعی که فراموش کنیم کلیدواژه ی protected را استفاده کنیم، نرم‌افزار به ما هشدار خواهد داد.

تفاوتی که نرم افزارهایی همچون vi که در سیستم عامل های مبتنی بری یونیکس همچون گنو/لینوکس در دسترس کاربران قرار دارد با IDE های مدرن این است که استفاده از نرم افزاری همچون vi نیاز به مطالعه ی زیادی صرفاً برای یادگیری کار کردن با این نرم‌افزار است اما محیط گرافیکی بسیاری از IDE های مدرن به گونه یی طراحی شده است که برنامه نویس طی چند ساعت می‌تواند کار با آن را یاد بگیرد اما در طول زمان، بسیاری از برنامه نویسان به همان کارهای ابتدایی که یاد می‌گیرند با نرم‌افزار مد نظر خود انجام دهند اکتفا کرده و خیلی علاقه یی به کشف زیر و بم IDE از خود نشان نمی‌دهند!

برای روشن‌تر شدن این مسأله مثالی می‌زنیم. امروزه هر کاری که قبلاً از طریق کامند می‌شد انجام داد را می‌توان از طریق ماوس و منوهای تعبیه شده در نرم‌افزار انجام داد و برخی برنامه نویسان در طول زمان به استفاده از ماوس عادت می‌کنند اما غافل از این که برداشتن دست خود از روی کیبورد و استفاده از ماوس، زمان ایشان را هدر می‌دهد؛ برای کلیه ی کارهایی که از طریق ماوس می‌توان انجام داد، همچنین می‌توان «کلیدهای میانبر» نیز تعریف کرد به طوری که مثلاً برای باز کردن یک پنجره ی جدید، بستن پنجره، تغییر نام و … می‌توان بدون آن که دست خود را از روی کیبورد برداریم، کار مد نظر را انجام دهیم.

اگر بخواهیم چکیده یی از این آموزش به دست آوریم، بایستی بگوییم که در توسعه ی نرم‌افزار زمان و مهم‌تر از آن صرفه جویی در زمان نقش بسیار تعیین کننده یی در موفقیت پروژه دارد و یکی از چیزهایی که می‌تواند به ما به عنوان یک برنامه نویس کمک کند، صرفه جویی در زمان کدنویسی با مسلط شدن به IDE مد نظر خود است؛

سعی کنیم به جای آن که بیشتر از ماوس استفاده کنیم، از کلیدهای میانبر از پیش تعیین شده در IDE استفاده کرده و یا خود کلیدهای میانبری بسته به نیازمان تعریف کنیم تا به جای آن که زمانی را صرف بلند کردن دست خود از روی کیبورد، بردن به سمت ماوس، حرکت دادن آن، کلیک روی یک منو و باز شدن پنجره ی مد نظر کنیم، به سادگی در همان حین که کدنویسی می کنیم، یکی دو کلید میانبر را هم‌زمان فشرده و کامند مد نظرمان اجرا گردد.

شاید در ابتدای راه استفاده ی صرف از کلیدهای میانبر کمی سخت باشد و به خاطر سپردن آن‌ها کاری دشوار، اما در طول زمان کدنویسی برایمان به مراتب لذت بخش تر خواهد شد.






# ا محدودیت‌های خود دست و پنجه نرم کنید

همواره به خاطر داشته باشید که منابع شما -شامل زمان و بودجه- محدود هستند؛ برای انجام پروژه های نرم افزاری یک زمان و پول کاملاً مشخصی در اختیار شما قرار می‌گیرد و این در حالی است که در این زمان محدود و بودجه ی کاملاً مشخص، علاوه بر تکمیل پروژه، شما می بایست دانش خود را به روز نگاه دارید، مهارت های جدید یاد بگیرید، با زبان‌های برنامه نویسی جدید آشنا شوید و …

علاوه بر این، در حین پیاده‌سازی پروژه های نرم افزاری همواره بایستی به این نکته توجه داشته باشیم که برای به دست آوردن بیشترین میزان Performance (پرفورمنس یا عملکرد)، می بایست دید نسبتاً عمیقی از سخت افزاری که در اختیار ما قرار گرفته شامل سی پی یو، حافظه ی رم، زیرساخت های شبکه، هارد دیسک و … داشته باشیم به علاوه این که باید تمام تلاش خود را به کار گیریم تا الگوریتم هایی که می نویسیم را با توجه به این محدودیت‌ها، پیاده‌سازی کنیم تا بهترین نتیجه را بگیریم.

به عبارت دیگر، به منظور ایجاد یک پرفومنس بهینه، بایستی یک «سازگاری و آشتی» مابین مفاهیم انتزاعی همچون الگوریتم ها و سخت افزاری که در اختیار ما قرار گرفته است ایجاد کنیم و صرفاً در این صورت است که می‌توانیم ادعا کنیم یک نرم‌افزار بهینه تولید کرده ایم.






# همواره بدانید چه چیزی را قرار است کامیت کنید

به نوعی می‌توان برنامه نویسان را به ۲ گروه مختلف تقسیم‌بندی کرد: گروهی که وقتی از ایشان می‌پرسید که مشغول به چه کاری هستند، به وضوح می‌توانند بگویند که مثلاً «در حال کار کردن روی کلاس مرتبط با یوزر هستم» و گروهی که پاسخی همچون «در تلاش برای بهبود روند سرویس یوزرها ام» که به نظر می‌رسد برنامه نویسی که پاسخ اول را داده است، دقیقاً می‌داند در حال انجام دادن چه کاری است اما در این در حالی است که برنامه نویس دوم بیشتر یک دید کلی نسبت به پروژه دارا است!

در همین راستا اگر از برنامه نویسی که پاسخ اول را داده است بپرسیم که چه چیزی را در نهایت کامیت خواهی کرد، به سادگی قادر خواهد بود تا نام تک تک فایل‌هایی که روی آن‌ها کار کرده و قرار است آن‌ها را کامیت کند ببرد اما برنامه نویسانی که به گروه دوم تعلق دارند، نه تنها نمی‌دانند که کارشان دقیقاً چه زمانی تمام خواهد شد، بلکه حتی نمی‌دانند که آیا قصد دارند فایل‌های قبلی را ریفکتور کنند یا مجبور می‌شوند که چند فایل جدید هم به پروژه بیافزایند.

نکته به طور کلی، در سیستم‌های کنترل نسخه همچون Git، منظور از اصطلاح «Commit» ذخیره سازی تغییرات صورت گرفته روی سورس کد به صورت لوکال و روی سیستم خود برنامه نویس است و در صورتی که این تغییرات مورد تأیید باشند، در نهایت می‌تواند آن‌ها را اصطلاحاً Push کند تا سایر برنامه نویسان تیم هم بتوانند تغییرات صورت گرفته را در اختیار داشته باشند.
برنامه نویسی که پاسخی مشابه پاسخ اول را در اختیار ما می‌دهد، دقیقاً می‌داند که قرار است چه کاری انجام دهد و اصطلاحاً «فوکوس» روی پروژه دارد؛ کارهایی که می بایست روی پروژه انجام شوند را تقسیم‌بندی کرده، هر بخش را در بازه ی زمانی مشخصی انجام داده و در نهایت می‌داند که کدنویسی اش منجر به بهبود کدام بخش از پروژه شده است. اما برنامه نویسانی که پاسخی مشابه پاسخ دوم ارائه می‌دهند نمی‌توانند دقیقاً بگویند که مشغول به چه کاری هستند چرا که در آن واحد می‌خواهند یک بهبود کلی روی سیستم اعمال کنند که چنین بهبودی ممکن است نیاز به ریفکتورینگ بخش قابل توجهی از سورس کد داشته باشد.

برنامه نویسان گروه اول همواره این شانس را دارند که اگر بخواهند به گذشته بازگردند، این کار را به سادگی با چند بار Ctrl +Z انجام دهند اما این قضیه در مورد برنامه نویسان گروه دوم اصلاً صدق نمی‌کند! پس به خاطر داشته باشیم که در انجام پروژه های نرم افزاری، همواره تسک ها را به بخش های کوچک و قابل کنترلی تقسیم بندی کرده، برای هر کدام از آن ها یک Deadline (ددلاین یا ضرب الاجل) در نظر بگیریم و در آن واحد فقط و فقط روی یکی از آن ها کار کرده و به محض تکمیل یک تسک، با خیال راحت سراغ تسک بعدی برویم.






# آشنایی با نحوهٔ به‌کارگیری دیتابیس‌های رابطه‌ای

درصورتی‌که دست به توسعهٔ اپلیکیشنی زده‌اید که قرار است حجم قابل‌توجهی از دیتاهای مرتبط با یکدیگر را جمع‌آوری کند، بدون شک نیاز به دیتابیسی از نوع Relational (رابطه‌ای) خواهید داشت. پیش از این، سیستم‌های مدیریت دیتابیس‌های رابطه‌ای یا اصطلاحاً RDBMS (که مخفف واژگان Relational DataBase Management System است) برای دولوپرها هزینه‌بر بودند و از سوی دیگر نیز استفاده از آن‌ها به سادگی آنچه امروزه می‌بینیم نبود.

اما خوشبختانه درحال‌حاضر RDBMSهایی اپن‌سورس و رایگان به بازار عرضه شده‌اند که از جملهٔ مهم‌ترین آن‌ها می‌توان به MySQL و PostgreSQL اشاره کرد؛ خبر بهتر این‌که دیتابیس‌های به‌اصطلاح Embedded را به‌سادگی استفاده از یک لایبرری در داخل اپلیکیشن‌های مختلف و تقریباً بدون نیاز به هرگونه ستاپ یا پیکربندی مورد استفاده قرار داد که از جملهٔ مهم‌ترین آن‌ها می‌توان به SQLite و HSQLDB اشاره کرد.

درصورتی‌که دیتای اپلیکیشن‌ شما از توان پردازش میزان حافظهٔ RAM سرورتان بیشتر است، سیستم‌های RDBMS این امکان را در اختیار دلوپرها قرار داده‌اند تا با Index (ایندکس یا اندیس) کردن جداول، به‌سادگی بر این مشکل فائق آیند.

مسلماً کار با سیستم‌های RDBMS نیازمند آشنایی با زبان SQL است؛ جالب است بدانید سینتکس زبان SQL بسیار قابل‌فهم بوده و پس از یادگیری این زبان پس از کمی تکرار و تمرین، به‌سادگی قادر خواهید بود دست به عملیات CRUD بزنید (منظور از اصطلاح CRUD،‌ انجام به‌اصطلاح Update، Read، Create و Delete به‌ترتیب به‌معنی ایجاد، فراخوانی، به‌روزرسانی و حذف است).

نکته SQL که به‌صورت «اس‌کیو‌ال» تلفظ می‌شود، مخفف واژگان Structured Query Language است که به‌منزلهٔ زبان استانداری برای ارتباط با دیتابیس‌های مختلف مورد استفاده قرار می‌گیرد.
یکی دیگر از مزایای آموختن کار با دیتابیس‌های RDBMS این است که این‌نوع سیستم‌های مدیریت دیتابیس همان‌طور که از نامشان پیدا است، اصطلاحاً Relational (رابطه‌ای) هستند؛ به‌عبارت دیگر، می‌توان بین جداول مختلف، ستون‌های یک جدول با سایر ستون‌های جداول دیگر و به‌طورکلی مابین دیتای ذخیره شده نوعی از ارتباط را برقرار ساخت.

وجود چنین ارتباطی چندین مزیت دارا است؛ اولین مزیت این که درحین فراخوانی یک داده، می‌توان پی به ارتباطش با سایر داده‌های ذخیره‌سازی شده برد (مثلاً می‌شود مشخص کرد که اگر یک کاربر از جدول مخصوص ذخیره‌سازی اطلاعات کاربران پاک شد، کلیهٔ کامنت‌های ثبت شده توسط آن کاربر هم در جدول مخصوص این‌کار به‌صورت خودکار پاک شود).

علاوه‌بر این، وجود چنین ارتباطی می‌تواند این تضمین را ایجاد کند که به‌صورت ناخواسته، تحت هیچ‌ عنوان نمی‌شود دیتایی را از دیتابیس حذف کرد؛ به‌عبارت دیگر، اگر مابین ستون‌های ۲ جدول مختلف نوعی ارتباط محدودکننده درنظر گرفته شده باشد، مادامی‌که دیتای یکی از جداول در جایی مورد استفاده قرار گرفته باشد،‌ دیگر امکان حذف آن داده وجود ندارد و همین مسأله این تضمین را ایجاد می‌کنند که یکپارچگی مابین کلیهٔ داده‌های ذخیره‌شده حفظ می‌گردد.

یکی دیگر از نکاتی که در مورد RDBMSها می‌بایست مدنظر قرار داد این است که این سیستم‌های مدیریت دیتابیس با زبان‌های برنامه‌نویسی مختلفی سازگار هستند و امکان استفادهٔ هم‌زمان توسط چندین زبان مختلف را به دولوپر می‌دهند.

به‌طور مثال، فرض کنیم وب اپلیکیشنی داریم که برای کدنویسی بخش صفحات دینامیک آن از زبان PHP استفاده کرده‌ایم اما درعین‌حال باتوجه به این که برای تحلیل داده‌ها به زبان و لایبرری‌هایی نیاز داریم که این فرایند را برایمان ساده‌تر کنند، برای این‌کار به‌سادگی بااستفاده از زبان Python می‌توان به تعامل با دیتابیس پرداخت.






# آشنایی با مهارت‌های ارتباطی و فراگیری زبان‌های خارجی

یکی بخش‌های لاینفک حرفه‌ٔ کدنویسی، ارتباطات است؛ گرچه بخش قابل‌توجی از زمان دولوپرها به تعامل با کامپیوتر، کامپایلر، ابزارهای توسعهٔ نرم‌افزار و مهم‌تر از همه پروژه‌ای که درحال کار کردن روی آن هستند می‌گذرد، اما درعین‌حال دولوپرها گاهی‌اوقات می‌بایست با سایرین نیز به دلایل مختلفی ارتباط داشته باشند.

موفقیت پروژه‌های بزرگ و مهم برنامه‌نویسی امروزه دیگر بیش از آن‌که دلیل فنی داشته باشد، مستلزم وجود تعاملی سازنده به‌صورت گروهی-اجتماعی است؛ بسیاری از برنامه‌نویسان موفق کسانی هستند که علاوه‌بر تسلط به یک یا چند زبان برنامه‌نویسی، به مهارت‌های ارتباطی و دیگر زبان‌های زندهٔ دنیا به‌غیر از زبان مادری خود نیز مسلط هستند.

نیاز به توضیح نیست که در فرایند کدنویسی، دولوپر به‌نوعی از طریق کدهایی که می‌نویسد صحبت کرده و از سیستم می‌خواهد تا تسک‌های مدنظرش را به انجام برساند. یک برنامه‌نویس خوب در تعامل با دیگر افراد نیز به‌خوبی می‌داند که با چه زبانی و با چه شیوه‌ای به تعامل با ایشان بپردازد تا به بهترین شکل ممکن بتواند منظورش را به دیگران منتقل کرده و ارتباطی اثربخش ایجاد نماید.

نکته‌ٔ دیگری که در زمینهٔ ارتباطات فردی در حوزهٔ توسعهٔ نرم‌افزار می‌بایست مدنظر قرار داد این است که به غیر از دولوپرها، افراد ذی‌نفع بسیاری در یک پروژهٔ نرم‌افزاری نسبتاً‌ بزرگ دخیل هستند که از آن جمله می‌توان به مدیر محصول، مدیر پروژه، کارشناس تجربهٔ کاربری، مدیر بازاریابی، تسترهای نرم‌افزار، دولوپرهای فرانت‌اند و همچنین صاحب اصلی محصول (مشتری) اشاره کرد که برخی از ایشان دارای دانش فنی هستند و برخی دیگر خیر.

یک دولوپر خوب کسی است که به‌خوبی با نیازهای تک‌تک افراد فوق‌الذکر آشنایی داشته و ایشان را به‌خوبی درک کند و برای نیل به چنین مهمی، ما می‌بایست با هریک از افراد بالا با زبان خودش بتوانیم صحبت کنیم؛ به‌عبارت دیگر، جایی نیاز است فنی صحبت کنیم و جایی هم می‌بایست در غیرفنی‌ترین حالت ممکن منظور خود را بیان کنیم تا مخاطب کاملاً متوجه منظورمان شود.

اجازه دهید برای روشن‌تر شدن این مسأله، مثالی بزنیم؛ فرض کنیم یک مشتری داریم که حسابدار است و قرار است برایش یک نرم‌افزاری مالی بنویسیم؛ برای این که ارتباط کلامی با این مشتری به بهترین شکل ممکن صورت گیرد، ما می‌بایست با برخی مفاهیم حسابداری همچون ترازنامه، بدهکار، بستانکار، صورت مالی، دارایی جاری، اصل بهای تمام‌شده، بدهی، معوقه و غیره آشنایی داشته باشیم که اصطلاحاً به این موارد Jargon گفته می‌شود.

نکته Jargon به اصطلاحات تخصصی هر حرفه‌ای گفته می‌شود که بخش قابل‌توجهی از مکالمات افراد فعال در آن حوزه بااستفاده از این اصطلاحات تخصصی صورت می‌گیرد؛ به‌عنوان مثال، افراد مختلفی همچون پزشکان، وکلا، حسابداران، مکانیک‌ها، برنامه‌نویس‌ها و دیگر متخصصین هرکدام اصطلاحات کاری خود را دارند که در حین صحبت با همکارانشان، به‌سادگی از آن‌ها استفاده کرده و هردو طرف هم به‌خوبی منظور یکدیگر را متوجه می‌شوند.
به‌طور‌کلی، زمانی‌که یک برنامه‌نویس این وظیفه را دارا است تا نیازها، ایده‌ها و دغدغه‌های مشتریان را به کد تبدیل کند، آشنایی با این جارگون‌ها یک ضرورت است. همچنین جدای از تمامی این مباحث و دانستن این نکته که مهارت‌های ارتباطی و اجتماعی بخشی جدایی‌ناپذیر از زندگی یک دولوپر است، برخورداری از دانش زبان انگلیسی برای دولوپری که قصد دارد برچسب حرفه‌ای روی خود بزند یک باید است.

به‌عبارت دیگر، دولوپری که بخواهد پابه‌پای دانش روز نرم‌افزاری دنیا حرکت کند، به‌راحتی داکیومنت‌های زبان‌های برنامه‌نویسی، لایبرری‌ها و غیره را بخواند، به‌راحتی در گوگل و استک‌اورفلو سرچ کند و با دیگر دولوپرهای سراسر دنیا در ارتباط باشد، داشتن مهارت زبان انگلیسی (حداقل خواندن و نوشتن) کم‌ترین چیزی است که از وی انتظار می‌رود.

به‌عبارت دیگر، اگر دولوپر تازه‌کاری هستید که قصد دارید حرفه‌ٔ توسعه‌ٔ نرم‌افزار را به‌عنوان شغل اصلی خود و محل درآمدتان انتخاب کنید اما دانش کافی در زمینهٔ زبان انگلیسی ندارید، توصیه می‌شود فراگیری زبان برنامه‌نویسی خود را متوقف کرده و شروع به یادگیری زبان انگلیسی کنید چراکه پس از مسلط شدن به مهارت‌های خواندن و نوشتن -و البته درصورت امکان مهارت‌های صحبت کردن و گوش کردن- سرعت یادگیری و پیشرفت شما در زمینهٔ کدنویسی به‌مراتب بیش از زمانی خواهد بود که زبان نمی‌دانستید!






# خود را با مهارت تخمین زدن تجهیز کنید!

به‌عنوان یک دولوپر، گاهی‌اوقات نیاز است تا در مورد چیزهای مختلف همچون زمان تکمیل یک تسک و غیره به مدیران، همکاران و حتی گاهی هم کاربران سرویسی که درحال توسعهٔ آن هستند تخمین بزنید تا ایشان به‌راحتی بتوانند در مورد زمان، هزینه‌های جاری، فناوری‌ و دیگر منابع مورد نیاز برای دستیایی به اهدافشان تصمیم‌گیری کنند.

تخمین زدن چیزهای مختلف، یک مهارت است که می‌بایست تکنیک‌هایی برای هرچه بهتر انجام دادن این کار آموخت؛ پیش از هرچیز، باید بدانیم که اصلاً «تخمین زدن» به چه معنا است و برای «چه کارهایی» می‌بایست از آمار و ارقام تخمینی استفاده کرد. اجازه دهید برای روشن‌تر شدن این مسأله، مکالمه‌ای فرضی مابین یک مدیر پروژه و یکی از دولوپرهای تیم نرم‌افزاری‌اش را در ادامه مدنظر قرار می‌دهیم:

مدیر پروژه: می‌تونی یک زمان تخمینی از تکمیل فیچر X بدی؟
دولوپر: ۱ ماه

مدیر پروژه: خیلی طولانیه! ما فقط ۱ هفته زمان داریم.
دولوپر: حداقل ۳ هفته زمان نیاز دارم تا بتونم چنین چیزی رو بنویسم.

مدیر پروژه: بیش از ۲ هفته برام راه نداره.
دولوپر: اوکی مشکلی نیست.

در پایان این مذاکره، دولوپر به تخمینی از انجام فیچر X دست پیدا می‌کند که مطلوب مدیر پروژه است؛ اما از آنجا که قبول ضرب‌العجل ۲ هفته‌ای از طرف دولوپر به‌نوعی زمان تخمینی مورد تأیید وی نیز محسوب می‌شود، هرگونه مسئولیتی درصورت نرسیدن به این ضرب‌العجل متوجه دولوپر خواهد بود و وی باید پاسخگو باشد. برای این که به درک درستی از چیزی که در این مکالمه اشتباه است برسیم، می‌بایست معنا و مفهوم ۳ چیز مختلف را به‌خوبی درک کنیم: تخمین، هدف و تعهد.

1 - تخمین (Estimate) یک محاسبهٔ تقریبی یا قضاوت کردن در مورد کیفیت یا کمیت چیزی است؛ چنین تعریفی حاکی از آن است تخمین چیزی است که براساس تجربیات گذشته و دیتایی که در دسترس داریم صورت می‌گیرد و این درحالی است که احساسات و آمال و آرزوها در تخمین زدن همواره می‌بایست مدنظر قرار داده نشوند. تعریفی که از تخمین به‌دست می‌آید همچنین حاکی از آن است یک تخمین هرگز دقیق نیست (مثلاً نمی‌شود گفت که تکمیل فلان تسک برنامه‌نویسی، ۳ روز کاری کامل و ۵ ساعت ۳۰ دقیقه به‌طول خواهد انجامید.)

2 - هدف (Target) در کسب‌وکار به نقطه‌ای اشاره دارد که پس از رسیدن به آن نقطه، نتیجه‌ای دلخواه نصیبمان می‌شود (مثلاً در یک پروژهٔ نرم‌افزاری این هدف را داریم تا پس از انجام یک تسک، اپلیکیشن بتواند در آن واحد هم‌زمان ۱۰۰۰ کاربر را بدون کمبود در منابع سخت‌افزاری و نرم‌افزاری ساپورت کند).

3 - تعهد (Commitment) قولی است که یکی از طرفین به دیگری می‌دهد تا تسک خواسته شده را در زمان مقرر با کیفیت مدنظر طرف مقابل به‌صورت مشخصی که روی آن از قبل توافق شده تحویل دهد (به‌طور مثال، در یک پروژهٔ طراحی سایت می‌توان گفت که افزودن شدن قابلیت سرچ به سایت در نسخهٔ ۲.۰ تعهدی است که دولوپر به مشتری می‌دهد).

گرچه تخمین، هدف و تعهد مجزا از یکدیگر می‌باشند، اما این درحالی است که اهداف و تعهدات می‌بایست براساس تخمین‌های درستی صورت گیرند؛ به‌عبارت دیگر، هدف اصلی از تخمین زدن در فرایند توسعهٔ نرم‌افزار این نیست که خروجی یک پروژه را پیش‌بینی کنیم بلکه هدف اصلی آن است که مشخص کنیم آیا اهداف پروژه به‌اندازهٔ کافی واقع‌گرایانه هستند تا بر آن اساس بتوان مدیریت و برنامه‌ریزی درستی انجام داد یا خیر تا درنهایت بتوان به تعهدات قول داده شده دست یافت.

اگر مجدد به مکالمهٔ صورت گرفته مابین مدیر پروژه و دولوپرش باز گردیم، می‌بینیم که این مدیر قصد داشت تا براساس هدفی نادرست که در ذهنش داشت، دولوپر را مجبور کند متعهد به انجام تسک X شود و در این مکالمه اصلاً منظور مدیر پروژه گرفتن یک زمان تخمینی از دولوپر نبود!

در پایان هم یادآوری یک نکته ضروری است که هروقت از شما خواسته شد تا به‌عنوان یک برنامه‌نویس در مورد چیزی تخمین بزنید، اطمینان حاصل کنید که از تمامی جنبه‌های کار آگاهی دارید، پس از تخمین زدن و وسط کار از شما تکمیل تسک‌های جانبی خواسته نمی‌شود، تمامی ابزارها و حداقل شرایط لازم برای به انجام رساندن تسک خواسته شده را دارید و از همه مهم‌تر، کلیهٔ شرایط پیش‌روی شما واقع‌گرایانه هستند.






# کدام یک؟ IDE یا Editor ، مسأله این است!

یکی از نکاتی که در ۹۷ چیزی که هر برنامه‌نویسی باید بلد باشد پیش از این گفته شد، مسألهٔ «IDE خود را مثل موم در دست بگیرید» بود؛ در این آموزش گفتیم که یک دولوپر حرفه‌ای کسی است که آنقدر به IDE خود مسط باشد که به‌سادگی و بااستفاده از کلیدهای میانبر بتواند به‌بخش‌های نرم‌افزار مورداستفادهٔ خود دسترسی یافته و به‌سرعت کدنویسی کند.

به خاطر داشته باشید IDE مخفف واژگان Integrated Development Environment به‌معنی «محیط توسعهٔ یکپارچهٔ برنامه‌نویسی» است که از جمله IDEهای معروف و محبوب می‌توان به Eclipse ،Visual Studio و IntelliJ IDEA اشاره کرد.
اما درعین‌حال، برخی متخصصین بر این باورند که IDEها -اگر نگوییم همیشه، اما در ابتدای راه فراگیری اصول کدنویسی- دولوپرها را به‌نوعی تنبل و وابسته می‌کنند. اجازه دهید برای روشن‌تر شدن دلیل چنین اتفاقی، چند مثال ساده بزنیم.

یکی از خصوصیات منحصربه‌فرد IDEها چیزی است تحت‌عنوان Code Completion؛ به‌عبارت دیگر، نرم‌افزار وقتی که شما ابتدای نام تابعی از پیش تعریف شده در زبان برنامه‌نویسی مدنظر خود را می‌نویسید، برای این که به فرایند کدنویسی شما سرعت بخشد پیشنهاداتی به شما داده و درنهایت کد تابع شما را تکمیل می‌کند.

علاوه‌بر این، یکی دیگر از خصوصیات بسیار کاربردی IDEها برقرار ارتباط بین بخش‌های مختلف پروژه است؛ به‌عبارت دیگر، اگر مثلاً زبانی همچون PHP را درنظر بگیریم، وقتی که قصد داریم یک کلاس از یکی از ماژول‌های پروژه را در کلاسی در ماژولی دیگر مورد استفاده قرار دهیم، می‌بایست کلاس مدنظر را به‌اصطلاح use کنیم اما این درحالی است که نرم‌افزاری همچون اکلیپس این‌کار را به‌صورت خودکار برای برایمان انجام داده به‌طوری‌که اصلاً روحمان هم خبردار نخواهد شد که چنین اقدامی صورت‌ گرفته است!

این‌ها صرفاً ۲ مثال از صدها کاربرد اثربخش، مفید و منحصر‌به‌فرد IDEها است و اگر فقط‌وفقط به یک روی سکه نگاه کنیم، این ۲ مورد و صدها مورد دیگر را می‌توان به‌عنوان نقاط قوت یک IDE قلمداد کرد.

اما روی دیگر سکه چه‌طور؟
برخی دولوپرها بر این باورند که روی دیگر سکه مادامی‌که برنامه‌نویسی مبتدی از یک IDE استفاده می‌کند را می‌توان به‌عنوان یک نقطهٔ ضعف قلمداد کرد. مجدد اجازه دهید برای روشن‌تر شدن این مسأله، به ۲ مثالی که در بالا بدان‌ها اشاره شد بازگردیم.

وقتی که ما از یک IDE استفاده می‌کنیم و این نرم‌افزار هم صرفاً قصد این را دارا است تا فرایند کدنویسی را برایمان لذت‌بخش‌تر سازد و مثلاً وقتی نام فانکشنی همچون explode در زبان پی‌اچ‌پی را می‌نویسیم، به‌صورت خودکار ادامهٔ نام این فانکشن را تکمیل کرده و حتی پارامترهای ورودی پیش‌فرض را نیز مدنظر قرار می‌دهد.

نقطهٔ منفی چنین کاری این است که یک دولوپر -به‌خصوص زمانی‌که در ابتدای راه کدنویسی است- دیگر مبانی زبان مدنظرش در ذهنش نهادینه نشده و هموراه وابسته به نرم‌افزار برای تکمیل کدها است و اگر روزی قرار باشد تا با نرم‌افزاری مثلاً همچون Nodepad ویندوز، Gedit لینوکس و یا TextMate مکینتاش اقدام به ویرایش سورس‌کدی کند، به احتمال قریب‌به‌یقین در این رابطه به مشکل خواهد خورد.

یا حتی وقتی که در مثال دوم گفتیم اکلیپس به‌صورت خودکار کلاس‌های مورد استفاده را اصطلاحاً use می‌کند، در دراز مدت ممکن است ما هرگز متوجهٔ بایدی بودن چنین کاری نشویم و از آنجا که همواره کلاس‌های use شده در بالای فایل هستند و معمولاً ما هم در بخش‌های پایینی یک فایل کدی را اضافه کرده و یا اقدام به ریفکتور کردن بخشی از کد می‌کنیم، هرگز متوجه نمی‌شویم که این کار باید صورت گیرد و مجدد اگر روزی قرار باشد تا با یک ادیتور ساده دست به ویرایش سورس‌کد بزنیم، ممکن است عدم توجه به این مسأله منجر به سردرگمی‌مان برای دقیقه‌های -و شاید ساعت‌های- متمادی گردد.

در کل، IDEها بسیار خوب هست اما به‌نظر می‌رسد که در ابتدای راه کدنویسی،‌ بیش از آن‌که مفید باشند و در دراز مدت کمک برنامه‌نویس کنند، وی را تنبل و وابسته بار می‌آورند؛ لذا توصیه آن است که در حین یادگیری اصول کدنویسی و یا مبانی یک زبان برنامه‌نویسی، همواره از ادیتورهای ساده‌ای مثل موارد فوق‌الذکر استفاده نمایید تا اصول و زیروبم زبان مدنظر در ذهنتان نهادینه شود سپس زمانی‌که احساس کردید به‌خوبی می‌دانید که مثلاً فانکشن‌های مختلف به‌ چه شکلی نوشته می‌شوند، ارتباط بخش‌های مختلف یک زبان‌ برنامه‌نویسی خاص به چه شکل است و غیره، در آن موقع می‌توانید برای آن‌که سرعت کدنویسی خود را افزایش دهید -که خود این مسأله هم به‌نوعی حاکی از حرفه‌ای بودن است- می‌توانید به استفاده از یک IDE روی آورید.






# ارسال پیام خطا به دولوپر توسط نرم‌افزار

شما ممکن است پروژه‌های نرم‌افزاری‌تان را بااستفاده از تست‌های خودکار (Automated Tests) سنجیده، آمار و ارقام مفیدی در مورد سورس‌کد، باگ‌ فیکس‌ها و … داشته باشید که حاوی اطلاعات ارزشمندی دربارهٔ فرایند تکامل پروژه در طول زمان باشند.

دولوپرهای حرفه‌ای همواره یک خط قرمزی دارند که هرگز اجازه نمی‌دهند کیفیت کدها پایین‌تر از آن قرار گیرد؛ حال اگر چنین خط قرمزی توسط خود پروژه مدیریت شود چه اتفاقی رخ خواهد داد؟ به‌عبارت دیگر، خود سورس‌کد به گونه‌ای طراحی شود که اگر چیزی در شرف خراب شدن بود، به دولوپر هشدار دهد.

یک اپلیکیشن هم می‌تواند همچون ما آدم‌ها سخنگو باشد اما به این شکل که یا از طریق ایمیل و یا از طریق دیگر راه‌های ارتباطی همچون پیامک، نوتیفیکشن و غیره اطلاعاتی از چند و چون کارکرد اپلیکیشن را در اختیار دولوپر قرار دهد.

اگر در حین کدنویسی به چنین قابلیتی هم فکر کنیم -یعنی خود نرم‌افزار در مورد تعداد اکسپشن‌ها، ارورها و غیره به دولوپرش هشدار دهد- می‌توانیم اطمینان حاصل کنیم قبل از آن که اوضاع روبه وخامت بگذارد، می‌توانیم دست به اصلاح سورس‌کد بزنیم.

برخی دولوپرها هم به‌خاطر مهم دانستن این موضوع، کمی خلاقیت به‌خرج داده و سیستمی طراحی می‌کنند که درصورت بروز مشکلات فنی در اپلیکیشن طراحی شده، یک چراغ قرمز هشدار چنین پیامی را به اعضای تیم توسعهٔ نرم‌افزار منتقل کند و شاید هم برخی پا را از این هم فراتر گذاشته و سیستمی طراحی کننده که بااستفاده از یک اسپیکر، نرم‌افزار درصورت بروز مشکل به صدا درآمد و مثلاً بگوید «دولوپرم عزیزم من اصلاً حالم خوب نیست و باگ‌ها امانم رو بریده‌اند!»

به‌طورکلی، لاگ‌ها اطلاعات بسیار ارزشمندی از نحوهٔ کارکرد نرم‌افزار در اختیار دولوپر قرار می‌دهند و این درحالی است که بسیاری از دولوپرها اصلاً توجهی به این دست اطلاعات ارزشمند نمی‌کنند! ما به‌سادگی و بااستفاده از لاگ‌های نرم‌افزارمان می‌توانیم روزبه‌روز دست به بهبود سورس‌کد زده و باگ‌ها، خطا‌ها و اکسپشن‌ها را به حداقل برسانیم.






# چیزهای اضافی را لود نکنید!

به لطف جامعهٔ اپن‌سورس، امروزه می‌بینیم که بسیاری از زبان‌های برنامه‌نویسی، فریمورک‌ها، لایبرری‌ها و غیره به‌صورت اپن‌سورس و رایگان در اختیار دولوپرها قرار گرفته‌اند؛ این وفور نعمت، گاهی منجر به ایجاد آشفتگی در پروژه‌های نر‌م‌افزاری می‌شود زیرا از آنجا که دولوپر نمی‌خواهد برای استفاده از مثلاً لایبرری X در پروژه‌اش هزینه‌ای بپردازد، گرچه دیگر نیازی به این لایبرری ندارد، اما کماکان این لایبرری داخل پروژه قرار دارد که نه‌تنها فضایی را اشغال کرده است (ولو چند کیلوبایت) بلکه لینک به این لایبرری در جای‌جای سورس‌کد هم مشاهده می‌شود و این درحالی است که اگر دولوپر دیگری بخواهد این پروژه‌ را در آینده نگهداری کرده و یا توسعه دهد، ممکن است دچار سردرگمی شود.

در چنین مواقعی می‌بایست تمام تلاش خود را به‌کار بندیم تا وابستگی‌های پروژه همچون ماژول‌ها، لایبرری‌ها و غیره کاملاً شفاف بوده و اگرهم تمایل نداریم تا مثلاً لایبرری‌های بلااستفاده را حذف کنیم، حتماً می‌بایست به‌نوعی مشخص شوند (که این کار را با کامنت‌گذاری صحیح می‌توان انجام داد).

این قضیه نه‌تنها در مورد لایبرری‌های به‌اصطلاح Third Party صدق می‌کند، بلکه در مورد کلاس‌ها، متدها و حتی متغیرها هم صادق است؛ به‌عبارت‌دیگر، گاهی در سورس‌کد برخی پروژه‌ها فانکشن‌هایی را می‌بینیم که در هیچ کجای پروژه فراخوانی نشده‌اند و اما کماکان وجود داشته و حتی کامنت‌ هم نشده‌اند!

نکته در صنعت توسعهٔ نرم‌افزار منظور از اصطلاح Third Party، کامپوننت‌های توسعه داده شده توسط هر تیم توسعه، شرکت و یا گروهی به‌غیر از توسعه‌‌دهندهٔ اصلی یک محصول (لایبرری، زبان‌برنامه‌نویسی، فریمورک و غیره) است که چنین کامپوننت‌هایی یا به‌صورت اپن‌سورس و رایگان و یا به‌صورت پولی عرضه می‌گردند.
در چنین شرایطی، وقتی که می‌خواهیم اقدام به حذف بخش‌هایی از سورس‌کد کنیم که دیگر مورد استفاده قرار نمی‌گیرند -همچون لایبرری‌های قدیمی یا حتی کلاس‌های بلااستفاده- حتماً می‌بایست به‌خاطر داشته باشیم اصلاً نباید این اطمینان را داشته باشیم که ۱۰۰٪ در هیچ‌کجای پروژه از موارد مدنظر استفاده نشده‌ است.

برای اطمینان حاصل کردن از این موضوع، ابتدا باید لایبرری را به‌صورت موقت حذف کرده سپس به انحاء مختلف شروع به تست پروژه کنیم تا مطمئن شویم که بدون حضور مثلاً لایبرری X، پروژه کماکان بدون مشکل کار می‌کند.

به‌طورکلی، تمیز بودن سورس‌کد پروژه -که نبود لایبرری‌ها، ماژول‌ها، کلاس‌ها و فانکشن‌های بلااستفاده در آن به‌نوعی مرتبط با تمیز بودن است- نشان از حرفه‌ای بودن دولوپرش دارد اما این تمیزی سورس‌کد بیش از هر چیزی، کمک به دیگر دولوپرهایی خواهد کرد که ممکن است در آینده بخواهند روی چنین پروژه‌ای کار کنند.






# چه‌موقع و چگونه از راه‌کارهای موقتی در کدنویسی استفاده کنیم؟

در پاسخ به این سؤال که چرا برخی دولوپرها دست به استفاده از سولوشن‌های (راه‌کارهای) موقتی می‌زنند بایستی گفت که علت اصلی مشکلات غیرمنتظره‌ای هستند که پیش می‌آیند و بایستی در کوتاه‌ترین زمان ممکن رفع شوند.

در بسیاری از تیم‌های توسعه‌ٔ نرم‌افزار همواره بخش‌‌هایی وجود دارند که هرگز از استانداردهای کدنویسی تبعیت نکرده و با سایر بخش‌های سورس‌کد هم‌خوانی ندارند و بالاخره روزی می‌بایست ریفکتور شده و با سایر بخش‌های سیستم هارمونی پیدا کنند.

نیاز به توضیح هم نیست که اکثر دولوپرها همواره از این موضوع شاکی هستند؛ گرچه دلایل بسیاری برای وجود این دست «راه‌کارهای موقتی» بسیارند اما کلید موفقیت این دست راه‌کارها کاربردی بودنشان است!

باتوجه به این که Interim Solutions (راه‌کارهای موقتی) به‌نوعی مفید واقع شده و مورد قبول برخی دولوپرها قرار گرفته‌اند، کمتر کسی را می‌توان یافت که برای رفع آن‌ها گامی بردارد چراکه مفید، کاربردی و مشکل‌گشا بوده و تنها نقطه‌ضعفی که دارند این است که استانداردهای کدنویسی را فالو نمی‌کنند (البته این درحالی است که چنین چیزی در بسیاری از شرکت‌های نرم‌افزاری و تیم‌های توسعه اصلاً مشکل خاصی محسوب نمی‌شود).

حال ممکن است زمان‌هایی پیش آید که پس از پیاده‌سازی راه‌کارهای موقتی به‌منظور رفع یک باگ و یا افزودن یک فیچر جدید، نرم‌افزار پس از مدتی به مشکل می‌خورد و از آنجا که استانداردهای کدنویسی در پیاده‌سازی این دست راه‌کارها اعمال نشده، طبق روال هم به‌سادگی نمی‌توان دست به رفع مشکلات پیش آمده زد.

در پاسخ به این سؤال که در چنین مواقعی چه باید کرد؟ بایستی گفت که معمولاً آپدیت‌های موقعی روی باگ‌های موجود در راه‌کارهای موقتی جواب می‌دهند و از لحاظ ماهیت، آپدیت‌های موقتی دقیقاً شبیه راه‌کارهای موقتی هستند با این تفاوت که کمی به‌روزشده‌تر می‌باشند.

همواره این نکته را به‌خاطر داشته باشیم زمانی‌که پروژه‌ای حاوی راه‌کارهای موقتی بسیاری باشد، از یک سو پیچیدگی سورس‌کد افزایش یافته و از سوی دیگر نگهداری، آپدیت و دیباگینگ نرم‌افزار هم به‌مراتب دشوارتر خواهد شد. به‌عنوان یک Best Practice کلی، وقتی در فرایند توسعه‌ٔ نرم‌افزار با مشکلی روبه‌رو شدید، ابتدا مراحل زیر را به ترتیب اولویت انجام دهید:

۱- تا حد ممکن از ارائهٔ راه‌کارهای موقتی خودداری کنید. خودداری‌هایی از این دست در بسیاری از موارد چارهٔ کار نیست چراکه ممکن است مشکلی جدی بوجود آمده باشد که نیاز است تا در اسرع وقت رفع گردد و اگر دولوپر پروژه بخواهد استانداردهایی که تا پیش از این به‌کار می‌‌بسته را در رفع مشکل فعلی مدنظر گیرد، این استانداردها دست‌وپاگیر خواهند بود اما به‌هرحال به‌عنوان اولین تلاش چنین چیزی توصیه می‌شود.

۲- تا حد ممکن مقابل اصرارهای مدیر پروژه به‌منظور اعمال یک فیچر خاص در کمترین زمان ممکن مقابله نمایید. در برخی موارد، اصرارهای مدیر پروژه آنقدرها هم که وی وانمود می‌کند لازم‌الاجرا نیست و از همین روی ضرری ندارد که تا حدی در مقابل اصرارهای وی مقاومت کرد.

۳- اگر هم مجبور به این کار شدید، تا حد ممکن حداقل‌ استانداردهای کدنویسی را رعایت نمایید. به‌عبارت دیگر، اگر گایدلاین‌ها و استانداردهای کدنویسی را گروه‌بندی کنید، می‌توانید در اعمال چنین راه‌کارهایی آن‌دسته از استانداردهایی که به‌مراتب مهم‌تر از بقیه هستند را رعایت نموده و الباقی را نادیده بگیرید.






# استفادهٔ نادرست از اینترفیس‌ها را غیرممکن سازید

در برنامه‌نویسی شیٔ‌گرا به‌خصوص در مبحث Abstraction (انتزاع)، یکی از کارهای رایج ایجاد Interface است؛ اینترفیس‌ها بخشی لاینفک از فرایند کدنویسی حرفه‌ای هستند و این درحالی است که اگر شما به‌عنوان یک دولوپر به‌خوبی از عهدهٔ این‌کار برآیید، از یک سو استفاده از اینترفیس‌ها فرایند کدنویسی را بسیار لذت‌بخش خواهد ساخت و از سوی دیگر، سرعت کدنویسی تک‌تک‌ اعضای تیم افزایش می‌یابد اما درعین‌حال اگر طراحی اینترفیس‌ها به‌درستی صورت نپذیرد، به یک عامل مهم در ایجاد مشکلات پس از پیشروی پروژه مبدل شده و بیش از آن که منجر به سرعت کدنویسی اعضای تیم شود، بیشتر به یک گلوگاه مبدل خواهد شد!

اینترفیس چیست؟
اگر خیلی غیرفنی بخواهیم توضیح دهیم، در برنامه‌نویسی شیٔ‌گرایی (OOP) منظور از Interface مجموعه فانکشن‌ها و قابلیت‌هایی است که یک آبجکت می‌بایست داشته باشد تا بتواند تسک‌های مورد انتظار را به انجام برساند. حال اگر بخواهیم کمی فنی‌تر صحبت کنیم، منظور از یک اینترفیس، یک Abstract Class (کلاس انتزاعی) است حاوی یکسری فانکشن و دیگر ویژگی‌ها اما این درحالی است که این فانکشن‌ها تسک خاصی را انجام نمی‌دهند بلکه صرفاً مشخص‌کنندهٔ قابلیتی‌ هستند که یک کلاس می‌تواند داشته باشد و این وظیفهٔ کلاس است تا عملکرد خاصی را برای آن فانکشن‌ها تعریف نماید.  

به‌طورکلی، یک اینترفیس خوب اینترفیسی است که اولاً استفادهٔ درست از آن آسان باشد، ثانیاً استفادهٔ نادرست از آن غیرممکن -یا حداقل مشکل- باشد!

استفادهٔ درست از اینترفیس می‌بایست آسان باشد
وقتی اینترفیسی جهان‌شمول و خوب طراحی شده باشد، دولوپرها همواره تمام تلاش خود را به کار می‌گیرند تا از آن استفاده کنند چراکه می‌دانند در آینده کمتر به مشکل برخواهند خورد.

به‌طورمثال، استفاده از اینترفیس‌های اصولی در طراحی API منجر به این خواهد گشت تا دولوپرها همواره مجبور باشند پارامترهای درستی را به‌همراه مقادیر درست به فانکشن‌های مورد استفادهٔ خود پاس دهند. به‌عبارت دیگر، اینترفیس‌هایی که استفاده از آن‌ها آسان است، منجر به انجام طبیعی فرایندهای مورد انتظار از نرم‌افزار می‌شوند.

استفادهٔ نادرست از اینترفیس می‌بایست دشوار باشد
اینترفیس‌های خوب و اصولی اشتباهات احتمالی کاربران را پیش‌بینی کرده و بروز چنین اشتباهاتی را غیرممکن -یا حداقل دشوار- می‌سازند. اگر مجدد به مثال API فوق‌الذکر بازگردیم، یک اینترفیس غیراصولی استفاده شده در یک API این امکان را به کاربر می‌دهد تا پارامتری که صرفاً می‌بایست Integer باشد را با هر دیتاتایپی ارسال کند که این اصلاً خوب نیست.

چگونه اینترفیس‌هایی طراحی کنیم که استفادهٔ درست از آن‌ها آسان باشد؟
در پاسخ به سؤال فوق بایستی گفت که یک راه مناسب برای طراحی اینترفیس‌های اصولی این است که پیش از ایجادشان، اقدام به استفاده از آن‌ها نماییم! از آنجا که ممکن است کمی گیج شده باشید، با ذکر مثالی به بررسی این موضوع می‌پردازیم.

پیش از هر چیز، خود را جای دیگر دولوپرها بگذارید و از نگاه ایشان به فرایند کدنویسی پروژه‌ٔ‌تان نگاه کنید؛ سپس پیش از آن که دست‌به‌کد شوید، سناریوهای مختلف را روی کاغذ نوشته و به بررسی آن‌ها بپردازید.

به‌عبارت دیگر، اگر فرضاً شما یکی از کاربران APIیی بودید که در طراحی آن از اینترفیسی استفاده شده است، دوست داشتید اینترفیس مدنظر تا چه اندازه دست شما با باز بگذارد تا به ساده‌ترین شکل ممکن بتوانید اقدام به استفاده از آن API نمایید.

چگونه اینترفیس‌هایی طراحی کنیم که استفادهٔ نادرست از آن‌ها دشوار باشد؟
برای به‌دست آوردن چنین قابلیتی، می‌بایست ۲ نکته را مدنظر قرار دهیم: اول این که باید ارورهایی که کاربران ممکن است مرتکب شوند را پیش‌بینی کرده و به هر شکلی که شده جلوی آن‌ها را بگیرید و دوم این که در ماه‌های ابتدایی عرضهٔ‌ اینترفیس می‌بایست کاربری‌های اشتباهش را رصد کرده و در صورت بروز کاربری‌های اشتباه، دست به ریفکتور کردن اینترفیس بزنید (مثلاً اگر مشاهده می‌کنید کاربرانی که از اینترفیس شما استفاده می‌کنند بارها‌وبارها اقدام به پاس دادن پارامترهای اشتباه به فانکشن X می‌کنند، سعی کنید کدها را به شکلی ریفکتور کنید که هم‌راستا با نیازهای کاربران باشد و فانکشن X موجب دردسر کاربران نشود).

مثالی کاربردی از اینترفیس‌ها در زبان برنامه‌نویسی PHP
در زبان برنامه‌نویسی PHP همچون دیگر زبان‌های برنامه‌نویسی، اینترفیس‌ها این امکان را به دولوپر می‌دهند تا ساختاری واحد برای کلاس‌های مورد استفاده در پروژه تعریف کرده و کلیهٔ آبجکت‌ها از ساختاری استاندارد بهره‌مند گردند. علاوه‌بر این، زمانی‌که شما می‌دانید یک کلاس می‌بایست حاوی چه متدهایی باشد اما در مورد جزئیات داخل متدها مطمئن نیستید، استفاده از اینترفیس‌ها لازم می‌گردد.

در زبان PHP تعریف کردن اینترفیس دقیقاً شبیه‌ به کلاس‌ها است با این تفاوت که به‌جای کلیدواژهٔ class می‌بایست از کلیدواژهٔ interface استفاده نمود و کلاس‌هایی که قرار است از یک اینترفیس بهره‌مند گردند نیز بااستفاده از کلیدواژهٔ implements به چنین قابلیتی دست خواهند یافت.

در ادامه اینترفیسی خواهیم ساخت به‌نام Car که حاوی ۲ فانکشن انتزاعی تحت‌عناوین ()setModel و ()getModel است:
``` C
interface Car { 
    public function setModel($name);
  
    public function getModel();
}
```
همان‌طور که می‌بینیم، یکی از فانکشن‌ها شامل یک پارامتر ورودی نیز هست؛ حال کلاسی می‌سازیم تحت‌عنوان MyCar که قرار است حاوی ویژگی‌های انتزاعی اینترفیسی باشد که پیش از این نوشتیم:
``` C
class MyCar implements Car {
    private $model; 
   
    public function setModel($name)
    { 
        $this->model = $name; 
    }
  
    public function getModel()
    {
        return $this->model; 
    }
}
```
همان‌طور که می‌بینیم، کلاس MyCar بااستفاده از کلیدواژهٔ implements کلیهٔ ویژگی‌های اینترفیس Car را به‌دست آورده است.

به خاطر داشته باشید وقتی کلاسی از یک اینترفیس implements می‌کند، می‌بایست کلیهٔ فانکشن‌های نوشته شده در اینترفیس در کلاس مدنظر نیز تعریف شوند حتی اگر مورد استفاده قرار نخواهند گرفت که در غیر این‌صورت با ارور مفسر پی‌اچ‌پی مواجه خواهیم شد.
حال اگر بخواهیم کلاس دیگری مثلاً تحت‌عنوان YourCar داشته باشیم، می‌توانیم این کلاس را نیز از اینترفیس Car بهره‌مند گردانده تا این اطمینان حاصل شود که کلیهٔ کلاس‌های مدنظر -همچون MyCar و YourCar و غیره- و بالتبع آبجکت‌های ساخته شده از روی آن‌ها دارای استاندارد واحدی هستند.

در پایان هم به‌خاطر داشته باشیم که فلسفهٔ وجودی Interface سهولت دولوپرهایی یا کاربرانی است که از آن استفاده می‌کنند نه سهولت دولوپرهایی که اقدام به طراحیش نموده‌اند!






# تا حد ممکن همه‌ چیز را شفاف‌سازی کنید

یکی از مشکلاتی که همواره مدیران پروژه و دولوپرها با آن دست‌وپنجه نرم‌ می‌کنند، ددلاین (ضرب‌العجل) هایی است که به حقیقت نمی‌پیوندند! به‌عبارت دیگر، مدیر پروژه قولی را به مشتری می‌دهد که مثلاً پروژه‌ای در تایم مشخصی تکمیل خواهد شد و یا دولوپر به مدیر پروژه قول می‌دهد که فلان ماژول پروژه ظرف مثلاً ۱ هفته به اتمام خواهد رسید اما این درحالی است که هیچ‌کدام از این قول و قرارها به واقعیت تبدیل نمی‌‌شوند!

یکی از دلایل چنین معضلی این است که روند پیشرفت پروژه شفاف نیست؛ درواقع،‌ وقتی که ما فرایند پیشرفت پروژه را به‌صورت لحظه‌ای رصد کنیم، اگر مشکلات پیش‌رو به اندازه‌ای باشند که ما را از رسیدن به ددلاین مدنظر باز دارند، پیش از آن که بدقول شویم می‌توانیم سیاست دیگری اتخاذ کنیم (مثلاً یا تعداد دولوپرهای پروژه را افزایش دهیم و یا به مذاکره برای گرفتن زمان بیشتر بپردازیم).

به‌طورکلی، بااستفاده از استیک‌نوت‌ها می‌توان فرایند تکمیل پروژه را دائماً در معرض دید خود و سایر اعضای تیم قرار داد بدین شکل که از عناوینی همچون «شروع نشده»، «در دست اقدام» و «تکمیل شده» برای نشان دادن روند انجام کار استفاده کرد.

شفاف‌سازی فقط در ارتباط با زمان تکمیل پروژه حائز اهمیت نیست بلکه شفاف‌سازی چیزی است که در تمامی مراحل توسعه‌‌ٔ نرم‌افزار می‌بایست مدنظر قرار داده شود که در ادامه به برخی چیزهایی که منجر به شفاف‌تر شدن کار می‌شوند خواهیم پرداخت:

- مستندسازی پروژه: نیاز به توضیح نیست که کامنت‌گذاری بخش‌های کلیدی نرم‌افزار امری حیاتی است که درنهایت منجر به شفاف‌تر شدن سورس‌کد می‌شود (البته به‌خاطر داشته باشیم که کامنت‌گذاری بیش از اندازه هم اصلاً کار درستی نیست).

- یونیت تست: تست کردن صحت عملکرد نرم‌افزار از طریق Unit Testها چیز دیگری است که منجر به شفاف‌تر شدن پروژه می‌شود؛ به‌عبارت دیگر، یونیت تست‌ به دولوپرها کمک می‌‌کنند تا کاملاً با وابستگی‌های پروژه آشنا شده و درصورت اعمال تغییر در یکی از بخش‌های پروژه، متوجه شوند که کدام‌یک از سایر بخش‌ها نیز دستخوش تغییر خواهند شد.

- دیپلوی کردن سریع: چنانچه بتوان یک پروژهٔ نرم‌افزاری به را بخش‌های کوچک و مجزا از یکدیگر تقسیم‌بندی نمود و سپس با تکمیل هر بخش آن‌را دیپلوی (منتشر) کرد، به‌طور شفاف می‌توان خروجی کار را دید.

به‌طورکلی، شفافیت در فرایند توسعه‌ٔ نرم‌افزار بسیار ويژگی خوبی است چراکه درنهایت منجر به بهبود خروجی کار می‌شود؛ وقتی همه‌چیز شفاف، صریح و قابل‌اندازه‌گیری باشد، اعضای تیم هم بهتر تکلیف خود را خواهند دانست و درنهایت پروژه به شکل بهتری به پیش خواهد رفت.






# ضرورت آشنایی با مفاهیم کانکارنسی و پاراللیزم

بسیاری از دولوپرها بر این باورند که Concurrency (کانکارنسی یا هم‌زمانی) و Parallelism (پاراللیزم یا موازات) فرایندهای بسیار پیچیده‌ای بوده و فقط حرفه‌ای‌ها می‌توانند به شکل صحیحی آن‌ها را پیاده‌سازی کنند.

شاید به‌نوعی بتوان گفت که این دو مفهوم فرایندهای پیچیده‌ای بوده و برای پیاده‌سازی اصولی آن باید باتجربه بود، اما اگر دولوپری بخواهد برچسب حرفه‌ای روی خود بزند، چاره‌ای جز این ندارد که علاوه‌بر آشنایی با این مفاهیم، نحوهٔ پیاده‌سازی آن‌ها در سیستم‌هایی با تعداد پروسس‌های زیاد را هم بلد باشد.

 مفهوم Concurrency چیست؟
به‌طور خلاصه، بایستی گفت که منظور از کانکارنسی این است که ۲ یا بیش از ۲ تسک به‌صورت هم‌زمان شروع شده، اجرا شوند و درنهایت توسط منابع مشترک -همچون یک پردازنده یا حافظهٔ به اشتراک گذاشته شده- بدون ترتیب خاصی تکمیل گردند. به‌عبارت دیگر، زمانی‌که یک اپلیکیشن قادر به پردازش حداقل ۲ تسک در یک زمان باشد، آن را اپلیکیشنی کانکارنت (Concurrent) می‌نامیم.

گرچه به‌نظر می‌رسد که تمامی‌ تسک‌ها به‌صورت موازی درحال اجرا هستند اما در عمل این‌چنین نیست بلکه بدین شکل است که تسک اول شروع شده سپس به حالت انتظار درمی‌آید و منابع به تسک دوم اختصاص می‌یابند و در ادامه سیستم‌عامل هم براساس اولویت تسک‌ها، سی‌پی‌یو و دیگر منابع سیستمی همچون مموری در اختیار تسک‌ها قرار داده تا تکمیل گردند.

مقهوم Parallelism چیست؟
درصورتی‌که چندین تسک یا یک تسکی که به چندین بخش تقسیم‌بندی شده و در آن واحد توسط پردازنده‌ای چندهسته‌ای (Multi-Core) هندل شود ما با Parallelism سروکار داریم بدین شکل که هر هسته به یک تسک یا یکی از بخش‌های تسکی که به چندین بخش تقسیم‌بندی شده اختصاص می‌یابد.

به‌خاطر داشته باشیم که در Parallelism ما به سخت‌افزارهایی با پردازندهٔ چندهسته‌ای نیاز داریم و این درحالی است که اگر پردازده صرفاً یک هسته داشته باشد، کانکارنسی اتفاق خواهد افتاد نه پاراللیزم.

تفاوت‌های Concurrency و Parallelism چیست؟
1 - کانکارنسی زمانی است که حداقل ۲ تسک در بازهٔ زمانی Overlapping (روی‌هم افتاده) شروع، اجرا و تکمیل می‌گردند درحالی‌که پاراللیزم به زمان اطلاق می‌گردد که تسک‌ها به‌معنای واقعی کلمه در آن واحد -مثلاً در یک پردازندهٔ چندهسته‌ای- اجرا می‌شوند.

2 - کانکارنسی مرتبط با اجرای پروسه‌های مجزا از یکدیگر است درحالی‌که پاراللیزم اجرای هم‌زمان تسک‌های -احتمالاً- مرتبط است.

3 - یک اپلیکیشن می‌تواند کانکارنت باشد اما پارالل نباشد؛ به‌عبارت دیگر، چنین اپلیکیشنی بیش از یک تسک را در آن واحد پردازش می‌کند اما هیچ ۲ تسکی در یک لحظه اجرا نمی‌شوند.

4 - یک اپلیکیشن می‌تواند پارالل باشد اما کانکارنت نباشد؛ به‌عبارت دیگر، چنین اپلیکیشنی بخش‌های مختلف یک تسک را توسط یک پردازندهٔ چندهسته‌ای در آن واحد پردازش می‌کند.

5 - یک اپلیکیشن می‌تواند نه پارالل باشد و نه کانکارنت؛ به‌عبارت دیگر، چنین اپلیکیشنی تمامی تسک‌ها را به‌ترتیب یکی پس از دیگری پردازش می‌کند.

6 - یک اپلیکیشن هم می‌تواند پارالل باشد و هم کانکارنت؛ به‌عبارت دیگر، چنین اپلیکیشنی می‌تواند چندین تسک‌ را به‌صورت هم‌زمان از طریق یک پردازندهٔ چندهسته‌ای در آن واحد پردازش کند.






# یافتن راه‌کارهای ساده برای مشکلات سخت

برخی برنامه‌نویسان بر این باورند از آنجا که برخی مشکلات توسعهٔ نرم‌افزار که بسیار چالشی و دشوار هستند را می‌بایست با راه‌کارهای پیچیده مرتفع سازند به‌طوری که اگر سورس‌کد چند ماه پس از کدنویسی در اختیارشان قرار گیرد، به سختی قادر خواهند بود تا اولاً آن‌را درک نموده ثانیاً آن‌را توسعه دهند! برای روشن‌تر شدن این مسأله، قصد داریم مقایسه‌ای مابین حرفه‌ٔ نویسندگی و برنامه‌نویسی داشته باشیم.

در عصر حاضر کدام رمان‌نویس مشهوری را می‌شناسید که در نگارش رمانش از لغات سخت، پیچیده و تاریخ‌گذشته استفاده کند؟ مگر غیر از این است که رمان‌هایی که امروزه در بازار به چاپ صدم و بالاتر می‌رسند همگی از نثری ساده و قابل‌فهم -حتی برای گروه‌های سنی پایین- برخورداند. اصلاً منکر فاخر بودن گلستان سعدی نیستیم، اما بعید به‌نظر می‌رسد که نثر زیر به‌سادگی قابل درک باشد:

یاد دارم که در ایام طفلی متعبد بودمی و شب‌خیز و مولع زهد و پرهیز. شبی در خدمت پدر -علیه الرحمه- نشسته بودم و همه شب دیده برهم نبسته و مُصحف عزیز در کنار گرفته و طایفه‌ای گرد ما خفته. پدر را گفتم یکی از اینان سر بر نمی‌دارد که دوگانه‌ای بگذارد و چنان خواب غفلت برده‌اند که گویی نخفته‌اند که مرده‌اند. گفت جان پدر! تو نیز اگر بخفتی به که در پوستین خلق افتی.

حال به بخشی از کتاب دا نوشته سیده زهرا حسینی تحت‌عنوان «و بالاخره خرمشهر آزاد شد» نگاهی می‌اندازیم:

بالاخره ساعت ۲، روز سوم خرداد سال 1361 اعلام کردند خرمشهر آزاد شد؛ چه‌کسی می‌توانست حال‌و‌هوای ما را از شنیدن این خبر درک کند. توی ساختمان کوشک ولوله‌ای افتاد، همه یکدیگر را بغل کرده و از خوشحالی گریه می‌کردند. مردم و همسایه‌های تهرانی ما تبریک می‌گفتند؛ همه خوشحال بودند. از خوشحالی نمی‌دانستیم چه‌کار کنیم و رفتیم بیرون ساختمان؛ مردم و کارمندان اداره‌ها همه از شادی این خبر کارشان را رها کرده و به خیابان آمده بودند. همه‌جا پر از هیاهو و سر‌و‌صدا شده بود. همه‌جا شادی موج می‌زد و ...

از مقایسهٔ این ۲ نثر می‌توان به‌ این نتیجه رسید که فارغ از ارزش ادبی هر کدام، نثر برگرفته از کتاب دا به‌مراتب قابل‌فهم‌تر است. به‌ یاد داشته باشیم که یک رمان‌نویس حرفه‌ای می‌داند که خوانندگان از خرید کتابش چند هدف دارند که مهم‌ترین آن‌ها عبارتند از:
- گذران وقت
- آشنایی با تاریخ
- لذت بردن
- ارتباط برقرار گرفتن با داستان
- کسب تجربه
- یادگیری و …

حال اگر هریک از پارامترهای فوق -و حتی دیگر ویژگی‌های یک رمان خوب- غايب باشند، احتمال فراگیر شدن رمان در بین خوانندگان کم‌رنگ و کم‌رنگ‌تر خواهد شد.

در صنعت توسعهٔ نرم‌افزار هم دقیقاً با چنین مسأله‌ای روبه‌رو هستیم؛ به‌عبارت دیگر، یک دولوپر کاری شبیه به نویسندگان دارد با این تفاوت که به‌جای نگارش به زبان فارسی -یا دیگر زبان‌ها- با زبان برنامه‌نویسی مدنظرش و با سینتکس خاصی شروع به نوشتن می‌کند.

همان‌طور که یک نویسنده در نگارش یک رمان نباید هرگز دامنهٔ لغات و دستور زبانش را بااستفاده از ساختارهای متکلف و پیچیده به رخ خواننده بکشد، یک برنامه‌نویس خوب هم هرگز نباید آن‌قدر پیچیده کد بزند که در آینده دیگر دولوپرها با سورس‌کد خوانی گیج شوند.

حال همان‌طور که ۲ نثر متکلف و ساده را در بالا با یکدیگر مقایسه کردیم، در ادامه قصد داریم برنامه‌ٔ معروف Hello World را به ۲ صورت پیچیده و ساده بااستفاده از زبان ++C بنویسیم؛ ابتدا با برنامه‌ٔ پیچیده شروع می‌کنیم:

``` C
#include < iostream >

    class AbstractHello {
        public:
            virtual~AbstractHello() {
                std::cout << " World!";
            }
        void Prnt() {
            std::cout << "Hello";
        }


    };

class ChildHello: public AbstractHello {
    public:
        ~ChildHello() {
            Prnt();
        }
};

int main() {
    ChildHello * Obj;
    Obj = new ChildHello;
    delete Obj;
}
```
حال همین برنامه‌ را می‌توان با تعداد خطوط کد کمتر و درعین‌حال قابل‌فهم‌تر به‌صورت زیر نوشت:
``` C
#include < iostream >

int main() {
    std::cout << "Hello World!";
}
```
به‌عنوان خروجی هر دو برنامه داریم:
```
Hello World!
```
به‌طور خلاصه، یک دولوپر خوب کسی است که کدی بنویسد که از ویژگی‌های زیر برخوردار باشد:
- اسامی کلاس‌ها، فانکشن‌ها، متغیرها و … قابل‌فهم اما درعین‌حال ساده باشند.
- ساختار فولدرها و فایل‌ها همگون و سرراست باشند.
- استاندارد کدنویسی یکسانی در جای‌جای پروژه اعمال شده باشد.
- به‌گونه‌ای کدنویسی کند که به‌جای کامنت‌گذاری، خود سورس‌کد گویای ماهیتش باشد.
- و درنهایت کدنویسی‌اش طوری باشد که اگر یک برنامه‌نویس تازه‌کار هم به مرور سورس‌کد پرداخت، بتواند ارتباط بین اجزای مختلف کد را درک کند.

هر برنامه‌ای -خواه کوچک باشد و خواه بزرگ- بالاخره روزی توسط دولوپری به غیر از دولوپر اولیه‌اش می‌بایست دیباگ، نگهداری و توسعه داده شود؛ به همین دلیل، در حین کدنویسی همواره این نکته را مدنظر داشته باشید که در آینده بالاخره روزی یکی از همکارانتان قرار است روی کدهایی که نوشته‌اید کار کند پس ضروری است تا به‌گونه‌ای کدنویسی کنید که دیگر دولوپرها تا حد ممکن کمتر دچار سردرگمی‌ شوند.






# دولوپری که نداند Polymorphism چیست، دولوپر نیست!

مفهوم Polymorphism (پالیمورفیزم یا چندشکلی) یکی از ستون‌های برنامه‌نویسی شیٔ‌گرایی است؛ این اصلاح ریشهٔ یونانی دارد که از ۲ بخش Poly به‌معنی «چند» و Morph به‌معنی «شکل» تشکیل شده است و این اصطلاح در برنامه‌نویسی شیٔ‌گرایی به الگویی اشاره دارد که بر آن اساس، کلاس‌های مختلف با عملکردهای مجزا از یکدیگر می‌توانند از ساختار و کاربری یکسانی بهره‌مند گردند.

پالیمورفیزم یا چندشکلی در برنامه‌نویسی مفهوم نسبتاً پیچده است که صرفاً با ذکر مثال می‌توان به‌خوبی مفهوم آن را درک کرد؛ لذا در ادامه سعی خواهیم کرد این مفهوم را بااستفاده از زبان PHP تشریح کنیم.

فرض کنیم یکسری کلاس داریم که مسئول ایجاد اشکالی همچون، دایره، مستطیل و … هستند؛ هریک از این اشکال دارای شکل متفاوتی نسبت به بقیه هستند اما همگی در یک چیز مشترک هستند و آن‌هم این که همهٔ اشکال دارای مساحتی هستند که بااستفاده از یک فانکشن می‌توان آن‌را محاسبه کرد.

مثلاً برای این‌کار می‌توان فانکشنی تحت‌عنوان ()calcArea درنظر گرفت که در تمامی کلاس‌ها وجود دارد، اما در کلاس دایره مساحت را به یک شکل (Morph) محاسبه می‌کند و در کلاس مستطیل به شکلی دیگر.

چگونه پالیمورفیزم را پیاده‌سازی کنیم؟
به‌منظور پیاده‌سازی این مفهوم در برنامه‌نویسی شیٔ‌گرایی، یا باید از Interfaceها استفاده نمود و یا از کلاس‌های به‌اصطلاح Abstract؛ که در ادامه استفاده از اینترفیس‌ها را با ذکر مثال توضیح خواهیم داد (جهت آشنایی بیشتر با مفهوم اینترفیس، به آموزش نود و هفت چیزی که هر برنامه‌نویسی باید بداند: استفادهٔ نادرست از اینترفیس‌ها را غیرممکن سازید مراجعه نمایید).

همان‌طور که در ادامه مشاهده می‌کنید، اینترفیسی داریم تحت‌عنوان Shape که حاوی فانکشنی تحت‌عنوان ()calcArea است و هر کلاسی که از این اینترفیس استفاده کند، باید دارای چنین فانکشنی باشد:
``` C
interface Shape {
    public function calcArea();
}
حال اقدام به نوشتن کلاس مربوط به دایره می‌کنیم که اینترفیس فوق‌الذکر روی آن اعمال شده است:

class Circle implements Shape {
    private $radius;

    public function __construct($radius) {
        $this->radius = $radius;
    }

    // calcArea calculates the area of circles 
    public function calcArea() {
        return $this->radius * $this->radius * pi();
    }
}
```
مجدد دست به ساخت کلاس دیگری این‌بار برای شکل مستطیل می‌زنیم که همانند کلاس مربوط به دایره است با این تفاوت که کدهای قرار گرفته داخل فانکش ()calcArea متفاوت است:
``` C
class Rectangle implements Shape {
    private $width;
    private $height;

    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }

    // calcArea calculates the area of rectangles   
    public function calcArea() {
        return $this->width * $this->height;
    }
}
```
حال اقدام به ساخت آبجکت‌هایی از روی این ۲ کلاس کرده سپس بااستفاده از فانکشن ()calcArea مساحت شکل را محاسبه می‌کنیم:
``` C
$circ = new Circle(3);
echo $circ->calcArea();

$rect = new Rectangle(3, 4);
echo $rect->calcArea();
```
خروجی کدهای فوق به‌صورت زیر خواهد بود:
```
28.274333882308
12
```
در حقیقت، چندشکلی یا پالیمورفیزم این‌گونه تفسیر می‌شود که ما فانکشنی ثابت داریم تحت‌عنوان ()calcArea اما این درحالی است که این فانکشن بسته به این‌که در کدام کلاس قرار گرفته باشد، عملکردی متفاوت از خود نشان خواهد داد و به‌نوعی خود را در چند شکل مختلف عرضه می‌کند.

وقتی دلوپرها با این مفهوم در OOP آشنا باشند، به‌سادگی به‌جای استفاده از دستورات شرطی مختلف و یا سوئیچ‌ها به‌منظور هندل کردن شرایط مختلف، می‌توانند با به‌کارگیری از مفاهیم اینترفیس و پالیمورفیزم، شرایط مختلفی که در کدنویسی با آن‌ها مواجه می‌شوند را با نوشتن حداقل میزان کد مدیریت کنند.






# تستر‌های نرم‌افزار دشمن دولوپرها نیستند!

کسانی که اقدام به تست نرم‌افزار به‌منظور اطمینان حاصل کردن از صحت عملکردش می‌کنند معمولاً با نام‌هایی همچون Quality Assurance ،Quality Control و یا Tester شناخته می‌شوند اما از دید دولوپرها فرقی نمی‌کند این متخصصین را چه بنامیم چراکه ایشان این گروه از افراد را «معضل» قلمداد می‌کنند!

جالب است بدانیم که وقتی در مورد تسترها و یا مسئولین کنترل کیفیت از دولوپرها سؤال می‌کنیم، جملاتی همچون «خیلی گیر هستن»، «بیش از حد مته به خشخاش می‌گذارن» و چیزهایی از این است از زبان ایشان می‌شنویم.

چرا باید به تستترها به شکل یک رفیق نگاه کنیم؟
ماحصل کار تسترها این است که آبروی ما جلوی مشتری نرود، کارفرما از دست ما شاکی نشود و درنهایت شغل خود را از دست ندهیم! با این تفاسیر، گرچه درظاهر تسترها با ریپورت کردن مشکلات نرم‌افزار ممکن است موجبات ناراحتی دولوپرها را فراهم آورند اما درنهایت این کار تسترها منجر به این خواهد گشت تا دولوپرها حرفه‌ای‌تر جلوه پیدا کنند و از همین روی بهترین رفیق دولوپرها محسوب می‌شوند.

برای روشن‌تر شدن اهمیت این مسأله، مثالی می‌زنیم؛ فرض کنیم شما دولوپری هستید که روی پروژه‌ای مرتبط با هوش مصنوعی کار می‌کنید (یکی از پیچیده‌ترین نمونه نرم‌افزارهایی که در صنعت IT می‌توان پیاده‌سازی کرد).

در ادمین پنل اپلیکیشن، یکسری Typo (تایپو یا غلط املایی) وجود دارد، برخی لینک‌ها به صفحهٔ درستی ارجاع نمی‌دهند و چیزهایی از این است که در مقایسه با باگ‌های ساختاری، اصلاً چیزی به‌حساب نمی‌آیند.

وقتی‌که درحال ارائهٔ دمویی از اپلیکیشن به مشتری هستید، مشتری متوجه مشکلاتی جزئی از این دست می‌شود و اتفاقی که می‌افتد این است که باخود می‌گوید «کسی‌که چیزهایی ابتدایی از این دست رو نتونسته درست کنه، احتمال داره در طراحی الگوریتم‌های هوش مصنوعی، آنالیز داده‌ها و غیره هم بی‌دقتی کرده باشه!».

به همین سادگی ایماژی منفی از شما در ذهن مشتری یا کارفرما می‌تواند شکل گیرد و این احتمال نیز وجود دارد که ماهیت قرارداد نیز به خطر بیافتد و اینجا است که نقش تسترها اهمیت پیدا می‌کند؛ به‌عبارت دیگر، این گروه از اعضای تیم -که حتی منشی شرکت هم اگر فرد بادقتی باشد می‌تواند به‌نوعی یک تستر خوب محسوب شود- نه‌تنها منجر به این خواهند گشت که آبروی شما نرود، بلکه این کار ایشان درنهایت هم به‌نفع شرکت و هم مشتری خواهد شد.






# همواره یک نسخه از نرم‌افزار برای ریلیس داشته باشید

برخی تیم‌های توسعهٔ نرم‌افزار هستند که برای پلتفرم‌های مختلف، خروجی‌های مختلفی از نرم‌افزاری که توسعه داده‌اند می‌گیرند اما این درحالی است که چنین سیاستی صرفاً منجر به پیچیده‌تر شدن کارها می‌شود!

به‌عبارت دیگر، با چنین کاری تیم توسعه نسخه‌های تقریباً شبیه به همی تولید کرده که هریک از آن‌ها صرفاً در پلتفرم اختصاصی خودش می‌بایست دیپلوی گردد و همین مسأله ضریب خطا را بالا خواهد برد (مثلاً نسخهٔ توسعه‌ داده شده برای پلتفرم A روی پلتفرم B دیپلوی گردد یا بالعکس).

در یک کلام، وقتی دست به توسعهٔ یک نرم‌افزار می‌زنید همواره تمام تلاش خود را به‌کار گیرید تا صرفاً یک نسخهٔ نهایی از نرم‌افزار داشته باشید که از مراحل تست گرفته تا بارگزاری روی سرور اصلی، تمامی کارها روی همان یک نسخه صورت می‌گیرد.

حال ممکن است این سؤال پیش بیاید که یکسری تفاوت‌های مبتنی بر Environment وجود دارند که بایستی هندل شوند (منظور از Environment، پلتفرمی است که نرم‌افزار قرار است روی آن پیاده‌سازی گردد)؛ در پاسخ به این سؤال بایستی گفت که چنین تفاوت‌هایی را باید داخل همان Environment یا پلتفرم هندل کرد.

حال ممکن است در زمان طراحی معماری نرم‌افزار آن‌قدر که باید و شاید دقت به‌خرج داده نشده باشد و برخی تنظیمات پیکربندی در سورس‌کد اعمال شده باشد که چنین مسأله‌ای مشکل‌زا خواهد شد؛ برای رفع چنین معضلی، می‌بایست تنظیمات پیکربندی کلی نرم‌افزار در فایلی مثلاً تحت‌عنوان global-config قرار داده شده و تنظیمات مرتبط با پلتفرمی که این نرم‌افزار قرار است روی آن پیاده‌سازی شود در فایلی مثلاً تحت‌عنوان env-config تا به‌سادگی بتوان نرم‌افزار را روی محیط‌های متفاوت به‌کار گرفت.






# فقط سورس‌کد است که حرف اول و آخر را می‌زند

سورس‌کد باید آن‌قدر واضح و شفاف باشد که با نگاه کردن به آن، بتوان به ماهیت نرم‌افزار پی برد و این درحالی است که کامل‌ترین مستندات نرم‌افزار هم آن‌طور که بایدوشاید ماهیت نرم‌افزار را روشن نمی‌کنند و در این‌گونه مستندات صرفاً به یکسری کلیات بسنده می‌شود.

در همین راستا، در حین کدنویسی همواره این سؤال را از خود بپرسید که آیا سورس‌کدتان به‌وضوح کامل چند و چون نرم‌افزار را هم برای خودتان و هم برای دیگر دولوپرها بیان می‌کند؟

در پاسخ به این سؤال ممکن است بگویید که کامنت‌های نوشته شده در جای‌جای سورس‌کد اطلاعات مورد نیاز را ارائه خواهند داد اما همواره به‌خاطر داشته باشید از آنجا که کامنت‌ها -همچون دیگر مستندات نرم‌افزار- در اجرای نرم‌افزار نقشی ندارند، می‌توانند حاوی اشتباهاتی باشند که ممکن است دولوپرها را گمراه سازند (این اشتباهات زمانی دوچندان می‌شوند که سورس‌کد ریفکتور شده، چیزی از آن کم شده و یا چیزی به آن افزوده گردیده اما درعین‌حال کامنت مدنظر آپدیت نشده است).

کامنت‌ها اصلاً چیز خوبی برای شفاف‌سازی سورس‌کد نیستند!
اگر کدی که می‌زنید نیاز به کامنت دارد، در اولین فرصت اقدام به ریفکتور کردن کدتان کنید به شکلی که دیگر کد برای نشان دادن ماهیتش نیاز به کامنت نداشته و خود سورس‌کد گویای کاری باشد که قرار است انجام دهد.

برای انجام چنین کاری هم صرفاً نیاز به چند تغییر کوچک خواهید داشت؛ از نام‌های مناسب و بامسمی برای کلاس‌ها، فانکشن‌ها، متغیرها و … استفاده کنید. ساختار فولدرها را به‌گونه‌ای بچینید که هارمونی بین بخش‌های مختلف پروژه وجود داشته باشد. کد را به‌گونه‌ای ریفکتور کنید که خواندن آن ساده‌تر گردد و کارهایی از این دست.

همان‌طور که یک شاعر یا نویسنده به‌گونه‌ای اقدام به نوشتن یک شعر یا اثر ادبی می‌کند که سال‌ها پس از انتشار آن اثر -و حتی پس از مرگ پدید آورنده‌اش- بدون نیاز به هیچ‌‌گونه راهنما یا مفسری می‌توان آن اثر را درک کرد‌، یک دولوپر خوب هم به‌گونه‌ای کد می‌زند که خود سورس‌کد می‌تواند با دیگر دولوپرها ارتباط برقرار سازد.

اگر چنین مواردی در کدنویسی رعایت شوند، زمانی‌که پروژه‌ٔ شما به‌اصطلاح Legacy می‌شود، دعای خیر دولوپرهایی که قرار است چنین پروژه‌ٔ قدیمی را مدیریت کنند همواره پشت‌ سر شما خواهد بود.

نکته به‌طور‌کلی، منظور از سورس‌کدهای Legacy کدهایی است که خیلی قدیمی هستند و دیگر ساپورت نمی‌شوند.






# فقط کد نزنید بلکه Build Process را نیز مدنظر قرار دهید

دولوپرهایی هستند که تمام تمرکز خود را روی سورس‌کد اصلی نرم‌افزاری که درحال توسعهٔ آن هستند می‌گذارند و این درحالی است که برخی نرم‌افزارها هستند که برای اجرای کامل، نیاز به یکسری اسکرپیت‌های جانبی، پیکربندی‌ها و … دارند که در کنار یکدیگر منجر به ایجاد یک Build می‌شود.

نکته در صنعت توسعهٔ نرم‌افزار، منظور از Build فرایندی است که از آن طریق سورس‌کد نرم‌افزار به برنامه‌ای قابل‌اجرا مبدل می‌گردد که به‌تنهایی قابل‌‌استفاده بوده و نتایج قابل‌مشاهده‌ای ارائه می‌دهد.
به‌طورکلی، Build بخشی مهم از فرایند توسعه است و درصورتی‌که این فرایند به درستی پیاده‌سازی نشود، سورس‌کد نرم‌افزار ارزشی نخواهد داشت! همان‌طور که قبلاً گفتیم، برخی نرم‌افزارها برای اجرای صحیح نیاز به یکسری اسکرپیت‌نویسی‌ها دارند که از آن جمله می‌توان به Bash Scripting در لینوکس اشاره کرد.

اسکریپت‌نویسی معمولاًً به زبانی به غیر از زبان اصلی دولوپر صورت‌ می‌گیرد و همین مسأله منجر به این خواهد گشت تا دولوپرها خیلی تمایلی به این کار نداشته و این‌گونه اسکریپت‌نویسی‌ها را به دیگر اعضای تیم واگذار کنند!

برخی دولوپرها هم بر این باورند که فرایند بیلد کار متخصصین کنترل کیفیت است اما واقعیت امر آن است که در حین کدنویسی،‌ تست نرم‌افزار هم می‌بایست صورت گیرد که با این‌کار هم می‌توان از صحت عملکرد نرم‌افزار اطمینان حاصل کرد و هم هزینه‌های توسعهٔ نرم‌افزار را کاهش داد. در یک کلام، Build Process بخشی از کار دولوپر است نه کسی دیگر!

به‌طور خلاصه، آنچه دولوپرها می‌بایست همواره مدنظر داشته باشند این است که از آماده‌سازی پلتفرمی که نرم‌افزار قرار است روی آن اجرا شود تا پیکربندی و اسکریپت‌نویسی و غیره جزو وظایف یک دولوپر است که درنهایت منجر به این خواهد گشت که نرم‌افزار به‌طور کامل و بدون هیچ‌گونه نقصی اجرا گردد.






# اهمیت برنامه‌نویسی دونفره

یکی از چیزهایی که باعث ارتقاء تیم‌های برنامه‌نویسی می‌شود، Pair Programming یا «برنامه‌نویسی دونفره» است؛ اگر شما برنامه‌نویس تازه‌کاری هستید که زیردست یک برنامه‌نویس ارشد هستید، می‌بایست به‌معنای واقعی کلمه صبور بوده و از مواجهه با دولوپرهای باتجربه‌تر از خود ترس به دلتان راه ندهید چراکه ایشان به‌منزلهٔ منبع ارزشمندی از اطلاعات هستند که چیزهای بسیاری از آن‌ها می‌توانید یاد بگیرید.

برنامه‌نویسی دونفره در تیم‌های نرم‌افزاری کمک به انتقال دانش مابین اعضای تیم می‌کند گرچه درظاهر ممکن است به‌نوعی اتلاف وقت تلقی گردد. برنامه‌نویسی دونفره مزایای بسیاری دارا است که در ادامه برخی از مهم‌ترین آن‌ها را برخواهیم شمرد:

- برخی پروژه‌ها هستند که وابسته به یک دولوپر یا گروه خاصی از دولوپرها هستند و این درحالی است که اگر ایشان حضور نداشته باشند، روند پیشرفت پروژه نیز متوقف خواهد شد اما اگر برنامه‌نویسی دونفره در تیم توسعهٔ نرم‌افزار به‌کار گرفته شده باشد، همواره این امکان وجود دارد تا دیگر دولوپرها نیز بتوانند پروژه‌ای نیمه‌کاره را تکمیل نمایند.

- وقتی تیم‌های توسعهٔ نرم‌افزار در پیاده‌سازی پروژه‌های مختلف از برنامه‌نویسی دونفره کمک بگیرند، چالش‌های پیش‌روی ایشان همواره سریع‌تر مرتفع می‌گردند چراکه مشکلات مابین اعضای مختلف تیم پخش شده و ممکن است هرکسی ایده‌ای منحصربه‌فرد برای رفع آن در ذهن داشته باشد و این درحالی است که اگر دولوپری به‌تنهایی قصد داشته باشد مشکلی را رفع کند، از دریافت ایده‌های سایر همکاران محروم خواهد شد.

- همواره یکی از چالش‌های دولوپرهایی که قرار است روی پروژه‌ٔ سایر همکاران کار کنند، نامگذاری کلاس‌ها، فانکشن‌ها، متغیرها و … است اما اگر برنامه‌نویسی دونفره به شکلی اصولی به‌کار گرفته شود، این مشکل نیز تا حد قابل‌توجهی مرتفع خواهد شد زیرا تمامی دولوپرها روی بخش‌های مختلف پروژه اشراف داشته، با نحوهٔ نامگذاری دیگر همکاران آشنا بوده و درصورت بروز مشکل، می‌توانند روی کمک یکدیگر حساب کنند.

- وقتی در تیمی از دولوپرها برنامه‌نویسی دونفره به‌کار گرفته شده باشد، دولوپرها دیگر نگران ددلاین‌های پروژه و عدم توانایی برای گرفتن مرخصی برای رسیدگی به‌ کارهای شخصی نخواهند بود چراکه دیگر اعضای تیم به‌سادگی قادر خواهند بود تا ادامهٔ پروژه را با همان سبک کدنویسی دولوپر سابق ادامه دهند.

- در تیم‌های توسعهٔ نرم‌افزار همواره این احتمال وجود دارد که یکسری دولوپر جدید به تیم اضافه شده و یکسری دولوپر قدیمی تیم را ترک کنند و این درحالی است که اگر برنامه‌نویسی دونفره مابین اعضای تیم صورت گیرد، چالش‌های این آمدن و رفتن‌ها به حداقل خواهد رسید چراکه تک‌تک اعضای تیم با پروژه‌های مختلف آشنا شده و کسانی که تازه‌وارد هستند خیلی سریع با چند و چون پروژه‌ها آشنا شده و بالتبع با رفتن برخی دولوپرها، تازه‌واردها می‌توانند جای ایشان را با حداقل چالش پر کنند.






# آشنایی با تفاوت Static Typing و Dynamic Typing در برنامه‌نویسی

پیش از هرچیز، به این نکته توجه داشته باشیم که در اینجا منظور از Type، نوع داده‌ای است که با آن سرورکار خواهیم داشت. به‌طورکلی، زبانی که به‌اصطلاح Statically Typed است در آن نوع متغیرها در زمان کامپایل شدن (Compile Time) برنامه‌ مشخص می‌گردد که از آن جمله می‌توان به زبان‌های جاوا، اسکالا، سی‌شارپ، سی و سی‌پلاس‌پلاس اشاره کرد و همین مسأله منجر به این خواهد گشت که پرفورمنس برنامه بالا رود چراکه هر دفعه که برنامه اجرا می‌گردد، دیگر نیازی به چک کردن نوع متغیرها نخواهد بود (لازم به‌ذکر است که این فیچر به‌عنوان یکی از برگ‌برنده‌های زبان‌هایی از این دست است).

علاوه‌بر این، در این نوع زبان‌ها زمانی‌‌که دولوپر تایپی را برای یک متغیر درنظر می‌گیرد، دیگر قادر به تغییر آن نخواهد بود چراکه در این نوع زبان‌ها تایپ به متغیر اختصاص می‌یابد نه مقدار درنظر گرفته شده برای آن متغیر و درصورتی‌که تغییر تایپ صورت گیرد، با اکسپشن مواجه خواهیم شد. به‌عنوان نمونه در زبان جاوا داریم:
```
String str = "Hello World";
str = 7;
```
همان‌طور که در کد فوق ملاحظه می‌شود، ابتدا متغیری از جنس String با مقدار Hello World ایجاد کرده‌ایم که در این صورت برنامه بدون هیچ مشکلی کامپایل خواهد شد اما در خط دوم، مجدد مقدار این متغیر را برابر با یک عدد صحیح درنظر گرفته‌ایم و از آنجا که تایپ عدد صحیح با تایپ استرینگ متفاوت است، در حین کامپایل شدن برنامه با اکسپشن مواجه خواهیم شد.

یکی از خوبی‌های این نوع زبان‌ها این است که چک کردن برنامه توسط کامپایلر و در حین فرایند کامپایل شدن صورت می‌گیرد و بنابراین باگ‌های جزئی که ممکن است از دید پنهان بمانند خیلی زود یافت خواهند شد.

زبانی هم که به‌اصطلاح Dynamically Typed است در آن نوع متغیرها در حین اجرای برنامه‌ (Run Time) مشخص می‌شود و دولوپر در حین کدنویسی نیازی به مشخص کردن دیتاتایپ‌ متغیر نخواهد داشت که از آن جمله می‌توان به زبان‌های پایتون، جاوااسکریپت و پی‌اچ‌پی اشاره کرد.

علاوه‌بر این، در این نوع زبان‌ها پس از آن که تایپی برای یک متغیر درنظر گرفته شد، مجدد می‌توان تایپ آن متغیر را تغییر داد چراکه در این نوع زبان‌ها، دیتاتایپ به مقادیر متغیرها بر‌می‌گردد نه خود آن‌ها؛ به‌عنوان‌مثال، در زبان پی‌اچ‌پی داریم:
```
$str = "Hello World";
$str = 7;
```
می‌بینیم که در خط اول متغیری تحت‌عنوان str$ ساخته‌ایم که حاوی مقدار Hello World است و در خط دوم هم این مقدار که پیش از این استرینگ بود را به یک عدد صحیح (Integer) تغییر داده و برنامه هم بدون هیچ مشکلی اجرا خواهد شد.

به خاطر داشته باشید باتوجه به‌ این که در زبان‌های Dynamically Typed چک کردن دیتاتایپ‌ها در حین اجرا صورت می‌گیرد، برنامه‌های نوشته شده با این زبان‌ها تاحدودی مشکل پرفورمنسی دارند چراکه هردفعه در حین اجرا، فرایند چک کردن دیتاتایپ‌ها می‌بایست صورت گیرد.






# تا حد ممکن از نمایش ارورها برای کاربر اجتناب کنید!

پیام‌های خطا (Error Messages) یکی از رایج‌ترین راه‌های ارتباطی کاربران با سیستم پیش‌رویشان است و درواقع این پیام‌‌ها خبر از اتفاقی غیرمنتظره می‌دهند.

آنچه در ارتباط با تعامل کاربران با یک سیستم نرم‌افزاری می‌بایست همواره مدنظر قرار داد این است که کاربران معمولاً به شکلی سیستماتیک و قابل‌پیش‌بینی منجر به ایجاد ارورها می‌شوند (به‌طورمثال، وارد کردن یک ورودی غیر عددی در فیلدی که صرفاً عدد می‌گیرد). از همین روی، به دلیل قابل‌پیش‌بینی بودن این نوع تعامل، به‌سادگی قادر خواهیم بود همان‌طور که سایر بخش‌های سیستم را دیباگ می‌کنیم، دست به دیباگ کردن نحوهٔ تعامل کاربران با سیستم نیز بزنیم.

برای روشن‌تر شدن این مسأله، مثالی می‌زنیم؛ فرض کنیم یک فیلد ورودی داریم که صرفاً مخصوص دریافت تاریخ است آن‌هم در یک بازهٔ خاص؛ در چنین شرایطی، به‌جای آن که به کاربر اجازه دهیم تا هر تاریخی را وارد کند، به‌سادگی می‌توانیم طیفی از تاریخ‌هایی که مجاز هستند را درمعرض دیدش قرار داده تا وی یکی از آن‌ها را انتخاب کند. چنین کاری احتمال آن‌که کاربر تاریخی خارج از طیف مدنظر را وارد سازد کاهش داده و همین مسأله منجر به ایجاد تجربهٔ کاربری به‌مراتب بهتری می‌گردد.

علاوه‌بر این، گاهی‌اوقات تنبلی دولوپرها هم منجر به سختی کشیدن بیشتر کاربران درحین استفاده از اپلیکیشن می‌شود. برای روشن‌تر شدن این مسأله، مجدد به مثال فوق بازمی‌گردیم؛ وقتی که کاربران با فیلدی که برای درج تاریخ درمعرض دیدشان قرار می‌گیرند مواجه می‌شوند، ممکن است تاریخ مدنظر خود را به‌صورت مثلاً 14-12-1390 وارد کنند اما این درحالی است که پس از ارسال دیتا برای سرور، صرفاً فرمتی همچون ۱۳۹۰/۱۲/۱۴ قابل‌قبول است و دادهٔ ورودی کاربر غیرقابل‌قبول تلقی می‌گردد.

در چنین شرایطی، دولوپرها ۲ راه‌کار پیش‌رو دارند؛ راه‌کار اول این که انواع فرمت‌هایی که کاربر می‌تواند وارد کند را تفسیر کرده و در دیتابیس ذخیره سازند (مثلاً فرمت‌هایی همچون 14-12-1390 یا ۱۳۹۰/۱۲/۱۴ یا حتی بااستفاده از اسپیس و به‌صورت 14 12 1390) و راه‌کار دوم این که صرفاً یک فرمت را مدنظر قرار داده و اگر کاربری چیزی به غیر از آن‌را وارد ساخت، خیلی ساده یک پیام خطا درمعرض دیدش قرار دهند.

از آنجا که راه‌کار دوم بار کدنویسی کمتری روی دولوپر دارا است، اکثر دولوپرها چنین راه‌کاری را انتخاب می‌کنند غافل از این‌که انتخاب چنین رویکردی باعث سردرگمی بیشتر کاربران می‌شود!

حال اگر هم راه‌کار دوم مدنظر دولوپر باشد، بازهم راه‌کارهایی برای به حداقل رساندن خطاها از طرف کاربران وجود دارد؛ مثلاً به‌سادگی می‌توان لیبل‌هایی حاوی متنی مرتبط با فرمت مدنظر درمعرض دید کاربر قرار داد و یا ۳ فیلد مجزا یکی برای سال، یکی برای ماه و دیگری برای روز با لیبل‌های گویا و مشخص درنظر گرفت تا احتمال خطا را به حداقل رساند.

به‌طورکلی، برخی دولوپرها هستند که دستورالعمل‌هایی برای نحوهٔ تعامل کاربر با اپلیکیشن درنظر می‌گیرند اما این درحالی است که بسیاری از این دستورالعمل‌های توسط کاربران اصلاً خوانده نمی‌شوند چراکه کاربران یا حوصلهٔ مطالعهٔ چنین دستورالعمل‌هایی را ندارند و یا فرض را بر این می‌گذارند که نحوهٔ تعامل با سیستم -باتوجه به تجربیات گذشتهٔ خود در تعامل با سرویس‌هایی مشابه- را بلد هستند.

در همین راستا، توصیه می‌شود که به‌جای استفاده از دستورالعمل‌های نحوهٔ استفاده از یک سرویس، اصطلاحاً Hint در اختیار کاربران قرار گیرد. درواقع، تفاوت Hint (به‌معنی ایما، تذکر و اشاره) با Instruction (دستورالعمل) در این است که دستورالعمل‌ها همواره پیش از تعامل کاربر با سیستم در قالب یک پاپ‌آپ، پیام، باکس و … درمعرض دیدش قرار می‌گیرد اما این درحالی است که هینت‌ها درحین تعامل کاربر با سیستم چیزی را به وی گوشزد می‌کنند و به همین دلیل هم هست که اثربخش‌تر هستند (مثلاً وقتی که در یکی از فیلدهای فرمی کلیک می‌کنیم و پیامی درمعرض دیدمان قرار می‌گیرد، این پیام نوعی Hint است).

راه‌کار دیگری که برای جلوگیری از وقوع ارورها می‌توان اتخاذ کرد این است که مثلاً در فیلدهای یک فرم از مقادیر دیفات (پیش‌فرض) استفاده کرد؛ در همان مثال فیلد مرتبط با تاریخ، می‌توان تاریخ روز را به‌صورت مقدار پیش‌فرض درنظر گرفت و این درحالی است که اگر تاریخ مدنظر کاربر تاریخ همان روز باشد که آن‌را دست‌نخورده باقی می‌گذارد و در غیر این صورت، می‌داند که فرمت مدنظر سیستم چیست و چگونه دیتا را می‌بایست وارد کند.

به‌طورکلی، دولوپرها پیش از هرچیز می‌بایست به این درک برسند که کاربران هدفشان چگونه فکر می‌کنند و بر همین اساس هم سیستم را مطابق به نحوهٔ فکر کردن اکثر کاربران هدف طراحی کنند و همین مسأله منجر به بروز پیام‌های خطای کمتر و درنتیجه تجربهٔ کاربری بهتر از جانب کاربران می‌گردد.






# به چه برنامه‌نویسی حرفه‌ای می‌گویند؟

اصلی‌ترین خصیصهٔ یک برنامه‌نویس حرفه‌ای، مسئولیت‌پذیری است. برنامه‌نویسان حرفه‌ای مسئولیت کاری که انجام می‌دهند، پیش‌بینی‌هایشان، تعهداتشان و اشتباهاتشان را پذیرفته و تحت هیچ عنوان انگشت اتهام به‌سوی دیگر دولوپرها دراز نمی‌کنند.

اگر دوست دارید برچسب حرفه‌ای روی شما بخورد، همواره می‌بایست مسئولیت کاری که انجام می‌دهید را بپذیرید؛ شما در قبال به‌روز بودن در حوزهٔ کاری خود و آخرین تکنولوژی‌های عرضه شده به بازار مسئول هستید. جالب است بدانید بسیار از دولوپرهای تازه‌کار هستند که بر این باورند وظیفهٔ کارفرمای ایشان است که به ایشان آموزش دهد که این تصور کاملاً اشتباه است! هیچ کارفرمایی آن‌قدر وقت و هزینه ندارد که شروع به آموزش و به‌روز کردن تک‌تک اعضای تیم توسعهٔ نرم‌افزار خود کند با علم به این که در آینده‌ای نه‌چندان دور، دولوپر خود را از دست خواهد داد (لازم به‌ذکر است که عمر دولوپرها در شرکت‌های نرم‌افزاری بیش از ۳ الی ۴ سال نیست).

بازهم اگر دوست دارید حرفه‌ای دیده شوید، می‌بایست مسئولیت کدی که می‌زنید را ۱۰۰٪ قبول کنید. هیچ دولوپر حرفه‌ای را سراغ نداریم که پیش از اطمینان حاصل کردن از عملکرد کدش، آن‌را ریلیس کند. درواقع، دولوپرهای حرفه‌ای اصلاً واهمه‌ای از متخصصین QA (این اصطلاح مخفف واژگان Quality Assurance به‌معنی تضمین کیفیت است) ندارند چراکه می‌دانند ایشان هیچ باگی در کدی که ایشان نوشته‌اند نخواهند یافت.

یکی دیگر از خصیصه‌های دولوپرهای حرفه‌ای این است که ایشان در کار تیمی (Team Work) مهارت دارند. ایشان مسئولیت خروجی کار کل تیم را برعهده می‌گیرند و تحت هیچ عنوان از زبان ایشان نمی‌شنویم که «من فقط فلان X رو نوشتم و این کد مال من نیست». دولوپرهای حرفه‌ای به دیگر همکاران خود -به‌خصوص کسانی‌که تازه‌کار هستند- کمک می‌کنند، به یکدیگر یاد می‌دهند، از همدیگر یاد می‌گیرند و در یک کلام، دیگران را ساپورت می‌کنند.

برنامه‌نویسان که تصمیم گرفته‌اند جزو حرفه‌ای‌های صنعت کاری خود باشند، تحت هیچ عنوان لیست طولانی از باگ‌های موجود در نرم‌افزار را تحمل نمی‌کنند و به‌محض مواجه با یک باگ -خواه کوچک و خواه بزرگ- درصدد رفع آن بر‌می‌آیند.

کدنویسی تمیز هم یکی دیگر از خصیصه‌های دولوپرهای حرفه‌ای است. کدی که یک دولوپر حرفه‌ای زده باشد در مقایسه با یک شخص غیرحرفه‌ای، بسیار تمیز با ساختاری قابل‌درک و درعین‌حال قابل‌ خواندن است. دولوپرهای حرفه‌ای همواره از استانداردهای کدنویسی (Best Practices) در حین کدنویسی استفاده می‌کنند و همین مسئله منجر به این خواهد گشت که دیگر دولوپرها در خواندن سورس‌کد ایشان به مشکل برنخواهند خورد.

در یک کلام، حرفه‌ای‌ها جزو آدم‌های مسئول هستند؛ به‌عبارت دیگر، کسانی که مسئولیت کار خود را پذیرفته و سعی می‌کنند کدی بنویسند که بهینه بوده و به بهترین شکل کار کند. دولوپرهای حرفه‌ای زمانی که با کمبود وقت مواجه می‌شوند، هرگز بزن و برویی کد نمی‌زنند و تحت هیچ عنوان استانداردهای سفت و سخت کدنویسی خود را زیر پا نمی‌گذارند تا به ددلاین مدنظر برسند بلکه برعکس، در چنین شرایطی بیشتر به استانداردها پایبند می‌شوند چراکه می‌دانند در شرایط استراس‌زا، احتمال بروز خطا بسیار بالا خواهد بود.






# از ورژن کنترل غافل نشوید!

یکی از نشانه‌های حرفه‌ای بودن در صنعت توسعهٔ نرم‌افزار، استفاده از Version Control است. گرچه درظاهر سوییچ کردن به ورژن کنترل کمی دشوار به‌نظر می‌آید اما پس از آن‌که مزایای چنین کاری بر دولوپرها -اعم از تازه‌کار و باتجربه- آشکار شد، ثابت می‌شود که یادگیری کار در چنین فضایی ارزشش را دارا است.

از جمله پلتفرم‌های ورژن کنترل رایج می‌توان به Git و SVN اشاره کرد(لازم‌ به‌ذکر است که گیت توسط لینوس توروالدز -خالق کِرنِل لینوکس- طراحی شده است و امروزه به‌عنوان معروف‌ترین و محبوب‌ترین سیستم کنترل نسخه شناخته می‌شود).

امروزه وب‌سایت‌های زیادی هم اقدام به ارائهٔ خدمات ورژن کنترل می‌کنند که از معروف‌ترین آن‌ها می‌توان به گیت‌هاب و گیت‌لب اشاره کرد (برای آشنایی بیشتر با نحوهٔ عمل‌کرد ورژن کنترل، می‌توانید به مقالهٔ ورژن کنترل (Version Control) چگونه کار می‌کند؟ مراجعه نمایید).

زمانی که شما به ورژن کنترل مهاجرت می‌کنید، به‌سادگی می‌توانید به تاریخچه‌ای از تغییرات صورت گرفته در پروژه دسترسی یافته و مهم‌تر از آن، ببینید که کدام‌یک از اعضای تیم و در چه زمانی آن تغییرات را ایجاد کرده‌‌اند. باتوجه به این‌که کلیه‌ٔ تغییرات صورت گرفته در سورس‌کد، ریفکتورینگ‌ها، باگ فیکس‌ها و … تحت ورژن کنترل ذخیره می‌شوند، دولوپرها بدون هیچ‌گونه نگرانی و دغدغه‌ای می‌توانند دست به اعمال تغییرات در سورس‌کد پروژ‌هایش بزنند چراکه این اطمینان خاطر را دارند که نسخه‌های پیشین پروژه را ذخیره دارند.

یکی از چیزهایی که در ورژن کنترل اهمیت دارد، تگ‌‌گذاری نسخه‌های مختلف پروژه است چرا که براساس همین تگ‌ها -که توصیه می‌شود براساس تاریخ باشند- در آینده به‌سادگی امکان جستجوی نسخهٔ خاصی از نرم‌افزار امکان‌پذیر می‌گردد.

علاوه‌بر این، در ورژن کنترل مفهومی داریم تحت‌عنوان Branch (برنچ یا شاخه) که بااستفاده از آن می‌توان نسخه‌هایی موازی از پروژه‌ای واحد ایجاد کرد مثلاً یکی تحت‌عنوان Development (توسعه) و یک یا تعدادی برنچ دیگر تحت‌عنوان Maintanance (نگهداری) بدین شکل که کدنویسی پروژه روی برنچ توسعه صورت می‌گیرد و چنانچه پس از اعمال تغییرات و یا افزودن فیچر جدید به پروژه و ریلیس کردن آن نرم‌افزار و برخورد کردن به مشکلی خاص، به‌سادگی و درصورتی‌که نیاز به نسخه‌های قبلی باشد، می‌توان به یکی از برنچ‌های نگهداری مراجعه کرد.

درصورتی‌که ورژن کنترل به‌درستی به‌کار گرفته شود، اصطکاک مابین دولوپرهایی که روی پروژه‌ای یکسان کار می‌کنند نیز به حداقل می‌رسد. درواقع، تغییرات صورت گرفته روی پروژه خیلی راحت به اطلاع تک‌تک دولوپرها رسیده و درصورتی‌که کانفلیکتی به‌وجود آید، به‌سادگی می‌توان آن‌را مرتفع ساخت.

زمانی که قصد دارید پروژه‌ای را روی یک سرویس ورژن کنترل -مثل گیت‌لب که رایگان هم هست- قرار دهید، اصلاً خساست به‌خرج ندهید! به‌عبارت دیگر، تمامی فایل‌های پروژه از سورس‌کد گرفته تا تصاویر، مستندات، اسکمای دیتابیس + دیتای اولیه جهت تست، ابزارها و … را روی ورژن کنترل ارسال کنید (حتی توصیه می‌شود لایبرری‌ها که معمولاً به‌اصطلاح Ignore هستند و به‌صورت اتوماتیک روی سرور ارسال نمی‌شوند را هم آپلود کنید). با اتخاذ چنین رویکردی، این اطمینان حاصل می‌شود که همواره نسخه‌ای کامل از پروژه به‌صورت بکاپ در اختیار خواهیم داشت (فرض کنیم که سیستم‌عامل خود را تغییر می‌دهیم و یا کلاً سیستم‌مان عوض می‌شود که بااستفاده از چنین رویکردی، به‌راحتی می‌توان کل پروژه را از پلتفرم ورژن کنترل مدنظر گرفته و به‌کار خود ادامه داد).

معرفی استراتژی‌های به‌منظور بهره‌وری بیشتر از Version Control
زمانی‌که شما به ورژن کنترل مهاجرت کردید و مزایای آن‌را درک نمودید، یکسری استراتژی‌ها و به‌اصطلاح Best Practice وجود دارد که چنانچه از آن‌ها پیروی کنید، می‌توانید اطمینان حاصل نمایید که از تمام پتانسیل یک سیستم ورژن کنترل استفاده می‌نمایید که عبارتند از:
1 - تغییرات اساسی در نرم‌افزار را در قالب یک Commit (کامیت) مجزا روی سرور بفرستید. چنانچه چند تغییر نامرتبط با یکدیگر را در قالب یک کامیت درنظر بگیرید، در آینده یافتن تاریخچهٔ پروژه کار دشواری خواهد شد.

2 - برای هر کامیت، توضیحاتی واضح و شفاف درنظر بگیرید (اگر هم این کار برایتان دشوار است، حداقل توضیح دهید که چه‌چیزی را تغییر داده‌اید). این دست توضیحات می‌توانند در آینده چنانچه نیاز به نسخه‌های قبلی نرم‌افزار شد، بسیار مؤثر واقع شوند.

3 - تحت هیچ عنوان کدی را قبل از تست کردن کامل و اطمینان حاصل کردن از این‌که نرم‌افزار به‌طور کامل کار می‌کند کامیت نکنید چراکه این‌کار در دراز مدت اعتبار شما در دید دیگر دولوپرهایی که روی پروژه کار می‌کنند را کم خواهد کرد.






# ماوس و کیبورد را کنار بگذارید!

آیا تاکنون برایتان اتفاق افتاده که ساعت‌ها مشغول سروکله زدن با مشکل یا باگی بوده‌اید اما هیچ راه‌کاری به ذهنتان نرسیده، خسته شده و از پشت سیستم‌تان بلند شده تا کمی استراحت کنید یا چیزی بنوشید اما در کمال ناباوری ناگهان راه‌کار مدنظر به ذهنتان رسیده است؟

دلیلی که پشت این قضیه نهفته این است که وقتی شما درحال کدنویسی هستید، بخش منطقی مغز شما (سمت چپ مغز) فعال بوده و بخش احساسی مغز (سمت راست مغز) غیرفعال؛ مادامی‌که بخش منطقی مغز -که از قضا مسئول یافتن راه‌کار یا رفع باگ است- استراحت کافی نداشته باشد، هرگز قادر به کمک برای یافتن راه‌کاری مناسب نیست!

درواقع، همان‌طور که پس از انجام کارهای فیزیکی مثل ورزش کردن و … بدن نیاز به استراحت دارد، پس از کارهای ذهنی مثل کدنویسی هم باید به عضوی از بدنمان که بیشترین درگیری را دارا است (مغز) استراحت دهیم که در غیر این‌ صورت راندمانش به‌طرز قابل‌توجهی کاهش خواهد یافت.

به‌عنوان راه‌کاری عملی، می‌توان گفت که پس از گیر کردن در یافتن یک باگ و یا به‌طورکلی پس از چندین ساعت کدنویسی، کمی استراحت کردن شامل گوش دادن به موسیقی مورد علاقه،‌ نوشیدن چای یا قهوه و کارهایی از این دست می‌تواند انرژی مورد نیاز برای ادامهٔ کارمان را تأ‌مین سازد. به‌عبارت دیگر، گاهی‌اوقات بهترین روش حل مسأله، کنار گذاشتن ماوس و کیبورد است.






# کدخوانی کنید!

اکثر دولوپرها از کدزنی لذت می‌برند اما زمانی‌که پای کدخوانی به میان می‌آید، کمتر کسی را می‌توان یافت که از این کار لذت ببرد! از آنجا که کدزنی به‌مراتب لذت‌بخش‌تر از کدخوانی است و همچنین فرایند کدخوانی کاری سخت، طاقت‌فرسا و گاهی‌اوقات غیرممکن است، دولوپرها معمولاً تمایلی به انجام این کار ندارند مگر آن‌که مجبور شوند!

به‌عنوان یک قانون کلی، معمولاً خواندن کدهایی که توسط دیگر دولوپرها نوشته شده است سخت است البته این بدان معنا نیست که دیگر دولوپرها کار خود را بلد نیستند بلکه این سختی بدین دلیل است که هیچ ۲ دولوپری همچون یکدیگر به یک Problem (مسأله) به شکلی یکسان نگاه نکرده و مشابه یکدیگر آن‌را حل نمی‌کنند.

آیا کدخوانی منجر به بهبود کدنویسی می‌شود؟
وقتی سورس‌کدی را می‌خوانید، همواره این سؤال را از خود بپرسید که آیا این فرایند راحت است یا دشوار؟ اگر پاسخ به چنین سؤالی «دشوار» بود،‌ بایستی بیابید که دلیل اصلی دشواری کدخوانی چیست، آیا فرمت‌ سورس‌کد مناسب نیست یا نامگذاری کلاس‌ها، متدها، متغیرها و … نامناسب است و یا این که زبان برنامه‌نویسی مدنظر به‌طورکلی دارای سینتکسی دشوار است!

در چنین شرایطی می‌توان از اشتباهات دیگر دولوپرها درس گرفت به‌طوری‌که درحین کدنویسی، هرگز آن اشتباهات را مرتکب نشویم تا درنهایت سورس‌کدی که تحویل دیگر دولوپرها می‌دهیم، از دید ایشان سورس‌کدی حرفه‌ای، خوانا و قابل‌فهم باشد.

اگر هم خواندن سورس‌کدی را «راحت» یافتیم، بازهم درس‌هایی می‌توان از آن آموخت. شاید از دیزاین پترنی استفاده شده که تاکنون از آن مطلع نبوده‌اید، شاید فانکشن‌ها کوتاه‌تر به‌همراه نامگذاری بهینه‌تری هستند و چیزهایی از این دست.

به‌طورکلی، پروژه‌های اپن‌سورس فراوانی را در گیت‌هاب و دیگر پلتفرم‌ها می‌توان یافت که نمونه‌های خوبی از کدنویسی حرفه‌ای هستند که با دنبال کردن استراتژی‌های چنین دولوپرهایی، می‌توانیم خود را به یک Role Model برای دیگر دولوپرهای تازه‌کار مبدل سازیم.

جالب است بدانید کدخوانی سورس‌کدهایی که چندین سال پیش نوشته‌ایم نیز می‌تواند درس‌های بسیاری برایمان به‌ ارمغان آورد بدین شکل که متوجه خواهید شد قدیمی‌ترین کدهایی که نوشته‌اید تحت هیچ عنوان مورد پسند شما -با استانداردهای کدنویسی کنونی‌تان- نیستند و گاهی‌اوقات هم اصلاً خوانا و قابل‌فهم نیستند!

مشاهدهٔ چنین سیر پیشرفتی می‌تواند انگیزهٔ شما را دوچندان سازد و اگر هم می‌بینید که همان استانداردهای کدنویسی نامطلوبی که در گذشته استفاده می‌کرده‌اید درحال‌حاضر هم در کدهای شما موجود است، این زنگ خطری است که باید خیلی به آن توجه کنید.

در یک کلام، هرموقع که تمایل داشتید مهارت‌های کدنویسی خود را ارتقاء بخشید، به‌جای شروع به خواندن یک کتاب آموزشی یا مراجعه به یک وب‌سایت آموزشی مرتبط با برنامه‌نویسی، می‌توانید شروع به خواندن سورس‌کد دیگر دولوپرهای حرفه‌ای نمایید.






# تعاملات اجتماعی کلید موفقیت است!

آدم‌ها با کمک دیگر آدم‌ها برای آدم‌های دیگر کدنویسی می‌کنند! شاید چنین جمله‌ای در نگاه اول کمی عجیب به‌نظر برسد، اما واقعیت دارد. درواقع، این جمله تأکیدش برروی ارتباط افراد با یکدیگر و کار گروهی است.

از بشر اول تاکنون، آدم‌ها به این دلیل که بتوانند به بقای خود ادامه دهند، سعی کرده‌اند روی کمک یکدیگر حساب کرده و در گروه‌ها زندگی کنند و این درحالی است که امروزه هم که در عصر فناوری به‌ سر می‌بریم از این قاعده مستثنی نیستیم.

با این حال، برخی از دولوپرها را می‌بینیم که به‌نوعی از جامعه بریده شده و در انزوا کد می‌زنند و این درحالی است که دیگر دولوپرهایی که اجتماعی‌تر بوده،‌ به کار تیمی اعتقاد دارند و قبل از آن‌که برنامه‌نویس باشند، یک «موجود اجتماعی» هستند می‌توانند علاوه‌بر زندگی شخصی، در حرفهٔ برنامه‌نویسی‌شان نیز بیشتر پیشرفت کنند.

به‌طورکلی، دولوپرهایی که در پروژه‌های اپن‌سورس شرکت می‌کنند، در رویدادهای کدنویسی مشارکت دارند و دانسته‌های خود را با دیگر دولوپرهای غالباً تازه‌کار به اشتراک می‌گذارند، وبلاگ‌نویسی می‌کنند و به هر شکلی به تعامل با دیگر افراد می‌پردازند، تأثیر به‌مراتب بیشتری در صنعت نرم‌افزار می‌توانند داشته باشند.

علاوه‌بر این، یک روی دیگر سکه هم کاربرانی است که قرار است از حاصل کدنویسی‌های دولوپرها استفاده کنند. در اینجا هم مجدد نیاز به تعاملات اجتماعی داریم؛ به‌عبارت دیگر، مادامی‌که دولوپرها به تعامل با کاربران هدف نرم‌افزار یا اپلیکیشن نپردازند، ایشان تحت هیچ عنوان نخواهند توانست به رفع باگ‌ها، بهبود نرم‌افزار و درنهایت رقم زدن یک تجربه‌ٔ کاربری عالی بپردازند.

درنتیجه، همواره به‌خاطر داشته باشیم که در صنعت توسعهٔ نرم‌افزار تعملات اجتماعی همچون هر حرفه‌ٔ دیگری دارای اهمیت بسیار بالایی است؛ از تعامل ما مشتریان گرفته تا مدیر پروژه، تستر نرم‌افزار و دیگر دولوپرها، همواره می‌بایست روی مهارت ارتباطات و مذاکره کار کرده و در این حوزه هم علاوه بر مهارت‌های کدنویسی تسلط یابیم.






# تا حد ممکن دست به اختراع مجدد چرخ نزنید!

شاید وقتی پای توسعهٔ نرم‌افزار به میان می‌آید بارهاوبارها شنیده باشید که «تا حد ممکن باید از کدهای موجود استفاده کرد و اختراع مجدد چرخ کار احمقانه‌ای است!» حال ممکن است این سؤال پیش بیاید که چرا در دنیای توسعهٔ نرم‌افزار دوباره‌ کاری این‌قدر بد دیده می‌شود؟ پاسخ به این سؤال و سؤالات دیگری از این دست بسیار ساده است و آن‌ هم چیزی نیست جز این که کدهای موجود کار می‌کنند و در یک کلام، آزمون خود را پس داده‌اند.

اختراع مجدد چرخ صرفاً به این مسأله اشاره نمی‌کند که چگونه کدی بزنیم که نیاز ما را مرتفع سازد بلکه دارای ریزه‌کاری‌های بسیاری است که اگر ساده به این قضیه نگاه کنیم، شاید هیچ‌وقت متوجه آن‌ها نشویم! به‌طور مثال، سیستم‌هایی که پیش از این نوشته شده‌اند به‌طور کامل تست شده و توسط صدها دولوپر مورد استفاده قرار می‌گیرند و این درحالی است که به غیر از این‌ که کد کار می‌کند، در مورد مسائل فنی‌تر همچون پرفورمنس، معماری ساخت، الگوهای طراحی، توسعه‌پذیری و بسیار مسائل دیگر هم روی آن‌ها فکر شده است.

وقتی دولوپری قصد دارد دست به اختراع مجدد چرخ بزند و این درحالی است که در مورد مسائل پیچیدهٔ توسعه‌ٔ نرم‌افزار -همچون مواردی که در بالا بدان‌ها اشاره شد- آگاهی ندارد، نتیجه این شده که نرم‌افزاری تولید می‌شود که کار می‌کند و نیازهای خود دولوپر یا مشتری‌اش را مرتفع می‌سازد اما به احتمال زیاد در آینده زمانی‌که بار زیادی روی نرم‌افزار بیاید، نیاز به توسعه یا ریفکتورینگ آن باشد یا قرار باشد با دیگر نرم‌افزارها ادغام شده و دیگر مسائلی از این دست، به مشکل خواهد خورد.






# تا حد ممکن از Singleton Pattern استفاده نکنید

نیاز به توضیح نیست که Singleton Pattern مشکل‌گشای بسیاری از مشکلات شما در حین کدنویسی است؛ درواقع، زمانی که شما مطمئن باشید که فقط و فقط یک آبجکت از روی کلاس مدنظرتان نیاز خواهید داشت، می‌بایست از این الگو استفاده کنید اما این در حالی است که این تضمین باید وجود داشته باشد تا قبل از آنکه آن آبجکت مورد استفاده قرار گیرد، اصطلاحاً Initialize شده باشد.

اما تجربه نشان داده است که این نوع دیزاین پترن (الگوی طراحی) بیش از آنکه مفید واقع گردد، باعث دردسر خواهد شد چراکه توسعهٔ کد در آینده را دچار مشکل می‌کند!

یکی از دلایلی که دولوپرها به سمت استفاده از این الگوی طراحی می‌روند این است که در ابتدا فکر می‌کنند که مثلاً به کلاس X در کل پروژه صرفاً یک بار نیاز خواهند داشت اما این در حالی است که معمولاً پروژه‌های بزرگ نرم‌افزاری در طول زمان دستخوش تغییرات بسیاری شده و به مرور زمان نیازها دچار تغییر و تحول می‌گردند و چنانچه دولوپری بیش از حد روی این الگو حساب کرده باشد، ممکن است در آینده با مشکلات عدیده‌ای مواجه گردد.

نکتهٔ دیگری که در ارتباط با الگوی طراحی سینگلتون وجود دارد این است که این الگو دیپندنسی‌هایی (Dependency یا وابستگی) میان ماژول‌های مختلف پروژه‌ٔ شما به صورت انتزاعی ایجاد می‌کند و همین مسأله مشکل‌زا خواهد شد چرا که از یک سو این وابستگی‌ها خیلی به‌وضوح قابل مشاهده نیستند و از سوی دیگر بخش‌های مختلف سورس‌کد را به یکدیگر وابسته می‌سازند و همین مسأله منجر به این خواهد گشت که در آینده به‌سادگی نتوانیم از سورس‌کد خود در سایر پروژه‌ها استفاده کنیم.

چنین وابستگی‌هایی همچنین منجر به این خواهند شد که تست کردن نرم‌افزار با Unit Test که نیازمند وابستگی حداقلی مابین اجزای مختلف سورس‌کد است هم با مشکل مواجه شود.






# وابستگی‌های زیاد دشمن ریفکتورینگ هستند!

در اغلب موارد، به‌ منظور دستیابی به پرفورمنس بیشتر، افزودن فیچرهای جدید و یا دیباگ کردن بخشی از نرم‌افزار بایستی کدها را دستکاری (ریفکتور) کرد اما این در حالی است که بخش‌هایی از کد که دارای Dependency (وابستگی‌) زیادی به دیگر بخش‌ها هستند تمام تلاش‌های ما را نقش بر آب خواهند کرد و هرچه این میزان وابستگی گسترده‌تر و ناواضح‌تر باشد، احتمال پی بردن به آن هم به‌ مراتب دشوارتر خواهد شد!

به خاطر داشته باشیم که کدهای کثیف،‌ نامنظم و اسپاگتی هم اوضاع را بیش از پیش وخیم خواهند کرد به‌ طوری که وابستگی‌های زیاد در سورس‌کد به علاوهٔ کدهای اسپاگتی، یک تغییر کوچک که به نظر ۲ الی ۳ ساعت بیشتر زمان نمی‌برد، به یک فرایند دشوار، خسته‌کننده و گاهی‌اوقات غیرممکن چند هفته‌ای مبدل می‌سازد.

برای جلوگیری از مشکلاتی این چنین، می‌بایست در حین طراحی معماری نرم‌افزار تا حد ممکن میزان وابستگی‌ها را به حداقل رساند. گرچه به صفر رساندن میزان وابستگی عملاً غیرممکن است، اما هرچه میزان وابستگی مابین بخش‌های مختلف سورس‌کد کمتر باشد، و یا این وابستگی‌ها حداقل در حوزهٔ یک ماژول باشند و نه بیشتر، ریفکتورینگ کد به مراتب راحت‌تر خواهد شد.






# هرچه تعداد خطوط کد کمتر، بهتر!

یکی از خصیصه‌های دولوپرهای تازه‌کار این است که به محض مواجه با یک مشکل و یا نیاز به افزودن یک فیچر جدید و دیگر کارهایی از این دست، سریعاً شروع به کدنویسی و افزودن بخش‌های جدیدی من‌جمله متغیرهای جدید، فانکشن‌های جدید و در یک کلام خطوط بیشتری به سورس‌کد می‌کنند که چنین خصیصه‌ای در نهایت منجر به حجیم شدن سورس‌کد و بالتبع پیچیدگی بیشتر آن می‌شود!

چنین رویکردی در نهایت منجر به ایجاد سورسی می‌شود که بسیار پیچیده بوده و ریفکتور کردن آن در آینده، خواه توسط خود دولوپر و خواه توسط دیگر دولوپرها، کاری بس طاقت‌فرسا خواهد شد و کسی‌ که از خارج به چنین سورس‌کدی نگاه کند، به سادگی متوجه خواهد شد که توسط دولوپری غیرحرفه‌ای نوشته شده است.

لذا در حین کدنویسی می‌بایست تمام تلاش خود را به کار بست تا حداقل تعداد متغیر، کلاس، فانکشن و در یک کلام، حداقل تعداد خطوط کد را داشت.






# آشنایی با قانون Single Responsibility

یکی از خصیصه‌های معماری نرم‌افزاری خوب این است که «چیزهایی که ماهیت مشابهی داشته، به دلایل یکسانی دستخوش تغییر می‌شوند و در یک کلام، به یک خانواده تعلق دارند را باید در کنار یکدیگر قرار داد و الباقی را مجزا ساخت.»

از دید فنی، به چنین قابلیتی Single Responsibility Principle (اصل تک وظیفه‌ای) یا به طور خلاصه SRP گفته می‌شود. به عبارت دیگر، این اصل حاکی از آن است که یک ماژول، کلاس، فانکشن یا هر چیزی می‌بایست وظیفه‌ای واحد داشته، متمرکز بر یک تسک بوده و صرفاً به یک دلیل تغییر یابند نه اینکه به محض مواجه با یک نیاز در هر بخشی از نرم‌افزار، نیاز داشته باشیم تا آن را دستخوش تغییر سازیم. برای روشن‌تر شدن این مسأله، کلاسی فرضی تحت عنوان Employee که دارای ۳ فانکش مختلف است را در نظر می‌گیریم:
``` C#
public class Employee
{
    public function calculatePayment();
    public function reportHours();
    public function save();
}
```
برخی برنامه‌نویسان بر این باورند از آنجا که این ۳ فانکشن به نوعی مرتبط با یکدیگر هستند، می‌بایست در قالب یک کلاس تعریف شوند اما این در حالی است که طبق قانون SRP، این ۳ فانکشن بنا به دلایلی کاملاً متفاوت ممکن است نیاز به تغییر کردن داشته باشند. برای مثال، فانکشن ()calculatePayment زمانی می‌بایست تغییر یابد که حقوق و مزیا کم‌ و زیاد شوند، فانکشن ()reportHours هم زمانی تغییر خواهد یافت که نحوهٔ گزارش‌دهی به مدیران تغییر کند و فانکشن ()save هم هر موقع که دیتابیس یا اسکمای برخی جداول تغییر یابد باید ریفکتور شود.

می‌بینیم که ۳ دلیل مختلف برای تغییر یافتن فانکشن‌ها پیش‌ روی ما است و این باعث می‌گردد که کلاس Employee بنا به هر دلیلی و به خاطر تغییر در سیاست‌های مرتبط با هر یک از ۳ فانکشن زیرشاخه‌اش دستخوش تغییر قرار گیرد و نکتهٔ مهم‌تر اینکه اگر در دیگر بخش‌های کد وابستگی به این کلاس وجود داشته باشد و کلاس‌های دیگری از این کلاس ارث‌بری کرده باشند، آنها هم دستخوش تغییر خواهند شد!

یک معماری نرم‌افزاری خوب آن است که ما سورس‌کد را به بخش‌های مجزایی تقسیم‌بندی کنیم که بتوان هر یک از آن‌ها را به‌ طور مجزا و بدون وابستگی به سایر بخش‌ها مورد استفاده قرار داد. به عبارت دیگر، اگر ما بخشی را تغییر دادیم، دیگر بخش‌ها نیاز به هیچ‌گونه تغییری نداشته باشند.

اگر بخواهیم مجدد به مثال فوق بازگردیم، چنانچه کلاس Employee توسط دیگر کلاس‌های ماژول‌های مختلف پروژه استفاده شده باشد، بنابراین اعمال هرگونه تغییر در این کلاس، کلاس‌های دیگر را تحت‌الشعاع خود قرار خواهد داد که در بسیاری از مواقع منجر به ایجاد باگ می‌شود. حال اگر بخواهیم کلاس فوق را بر اساس قانون SRP ریفکتور کنیم، خواهیم داشت:
```C#
public class Employee
{
   public function calculatePayment(); 
}

public class EmployeeReporter
{
   public function reportHours(); 
}

public class EmployeeRepository
{
   public function save(); 
}
```
می‌بینیم که در کد فوق دارای ۳ کلاس مجزا از یکدیگر هستیم که هر کدام از آن‌ها متمرکز بر تسکی اختصاصی هستند. به عبارت دیگر، تمامی فانکشن‌های مرتبط با گزارش‌دهی را می‌توان در کلاس EmployeeReporter قرار داد، تمامی فانکشن‌های مرتبط با دیتابیس را در کلاس EmployeeRepository نوشت و هر آنچه که مرتبط با Business Rules (قوانین کاری) است را در کلاس Employee.

پیاده‌سازی اصولی SRP می‌تواند ضامن معماری‌های نرم‌افزاری خوبی باشد که در آن‌ها میزان Dependency (وابستگی) به صورت حداقلی بوده و اعمال یک تغییر در کد، منجر به ایجاد باگ در سایر بخش‌ها نخواهد شد.







# همه‌ چیز با یک آری شروع می‌شود!

از یک دید کلی می‌توان پرسنل فروشگاه‌های را به ۲ گروه مختلف تقسیم‌بندی کرد: گروهی از فروشندگان که نیمهٔ پر لیوان را می‌بینند و گروه مقابل که صرفاً روی نیمهٔ خالی متمرکز هستند! به نظر می‌رسد که برای روشن‌تر شدن این مسأله، باید از یک مثال روزمره کمک گرفت.

وقتی که به یک فروشگاه زنجیره‌ای برای خرید می‌رویم، برخی فروشندگان هستند که وقتی سؤالی عجیب و غریب از ایشان می‌پرسیم، مثلاً نوعی شربت که بسیار کم‌مصرف است و فقط تعدادی فروشگاه خاص آن را عرضه می‌کنند، درخواست ما به عنوان یک مشتری را هرگز رد نکرده و فوراً با گفتن جمله‌ای همچون «خیر. متأسفانه ما این محصول را نداریم!» به قضیه فیصله نمی‌‌دهند بلکه این درخواست در ظاهر عجیب و غریب ما را به عنوان یک فرصت نگاه کرده،‌ اگر هم خودشان در این رابطه اطلاعی نداشته باشند از سایر همکارانشان کمک گرفته تا بلکه ایشان بتوانند راهنمایی کنند و در نهایت هم اگر کمکی از دست هیچ‌کس برنیاید، نام و مشخصات محصول مد نظرتان را گرفته تا برایتان تهیه کنند.

در نقطهٔ مقابل این دست فروشندگان، گروهی دیگر قرار دارند که اصلاً مشتری‌مدار نیستند و صرفاً با گفتن جمله‌ای همچون «خیر. نداریم!» خود را خلاص می‌کنند.

پس از این مقایسه، حال قصد داریم نگاهی به رویکرد دولوپرها در تعامل با دیگر همکارانشان بیندازیم. در واقع، از یک دید کلی هم می‌توان دولوپرها را به گروه‌بندی مشابهی همانند آنچه در فروشگاه‌های زنجیره‌ای وجود دارد تقسیم کرد. برخی دولوپرها هرگونه پیشنهاد، اعمال ویژگی جدید و به طور کلی هر درخواستی را به عنوان دردسر می‌بینند و تمام تلاش خود را به کار می‌بندند تا آن را در نطفه خفه کنند!

در مقابل، برخی دولوپرها رویکردی به مراتب حرفه‌ای‌تر اتخاذ کرده و هرگونه پیشنهاد و درخواستی را به منزلهٔ فرصتی برای بهینه‌تر کردن نرم‌افزار یا اپلیکیشن و بهبود تجربه‌ٔ کاربری‌اش می‌بینند و این همان ویژگی‌ای است که یک دولوپر تمام عیار می‌بایست داشته باشد.

خیلی از اوقات با بله گفتن به درخواست‌هایی که از طرف مدیرعامل، مدیر محصول، مدیر پروژه، مشتری و یا حتی کاربران می‌آیند، اصلاً نیازی به کدزنی قابل‌توجهی نیست بلکه با چند تغییر کوچک، می‌توان به درخواست ارسال شده جامعهٔ عمل پوشید.

حال گاهی‌اوقات ممکن است با درخواست‌هایی مواجه شویم که در تضاد با استراتژی‌های توسعهٔ نرم‌افزار موجود است. اگر شما جزو آن دسته از دولوپرهایی هستید که ابتدا به ساکن کلمهٔ نه از زبانتان بیرون می‌آید، در چنین مواقعی سعی کنید سریع پاسخ ندادن را تمرین کنید و در صورت امکان، در حین فرایند تصمیم‌گیری به غیر از خودتان از دیگر اعضای تیم توسعهٔ نرم‌افزار هم بخواهید تا حضور داشته باشند تا بلکه بتوانند موضع‌گیری شما را تا حدی خنثی کنند و یا پاسخی منطقی در ارتباط با عدم امکان پیاده‌سازی قابلیت‌ مد نظر به طرف مقابل ارائه گردد.






# تا حد ممکن همه‌ چیز را خودکار کنید
اگرچه امروزه ابزارهای اتوماسیون توسعهٔ نرم‌افزار بسیار زیادی در اختیار دولوپرها قرار دارد، اما برخی از ایشان ترجیح می‌دهند که به جای استفاده از این ابزارها، کارها را به صورت دستی انجام دهند که شاید دلیل چنین مقاوتی، یکسری باورهای نادرست در مورد اتوماسیون باشد که مهم‌ترین آنها عبارتند از:

باور نادرست ۱: اتوماسیون صرفاً برای تست است
گرچه Automation (اتوماسیون) بیش از هر جای دیگری در فرایند تست نرم‌افزار صورت می‌گیرد اما این در حالی است که اگر اسکریپتی بنویسیم که بسیاری از کارهای روزمهٔ ما همچون گزارش‌گیری، مستندسازی، کامپایل، دیپلویمنت و … را انجام دهد، به مراتب از کلیک‌های ماوس قابل‌اعتمادتر است.

باور نادرست ۲: اگر از IDE استفاده کنیم، نیاز به اتوماسیون نداریم
IDEها دارای تنظیمات بسیار پیشرفته‌ای هستند که بسیاری از کارهای تکراری دولوپرها را انجام می‌دهند اما این در حالی است که به سختی می‌توان این تضمین را ایجاد کرد که در یک تیم توسعهٔ نرم‌افزار، تک‌تک دولوپرها از تنظیمات (Settings) یکسانی برخوردار باشند اما سیستم‌های اتوماسیون بیلدی همچون Ant (برای زبان برنامه‌نویسی جاوا)، iMacros و یا Selenium، به سادگی چنین امکانی را در اختیار ما قرار می‌دهند.

باور نادرست ۳: برای این کار، باید کار با ابزارهای زیادی را یاد گرفت
شما با استفاده از زبان‌های اسکریپت‌نویسی شل همچون بش یا پاورشل به سادگی می‌توانید دست به نوشتن اسکریپت‌هایی بزنید که کلیهٔ کارهای شما را خیلی سریع انجام دهند.

علاوه بر این، برای اسکریپت‌نویسی شما اصلاً نیازی به یادگیری زیر و بم زبانی همچون Bash و یا ابزارهایی که پیش از این معرفی شدند ندارید. در چنین مواقعی، به محض نیاز به انجام کاری، تکنیک‌های مرتبط با همان کار را با سرچ در وب و مطالعهٔ منابع مختلف یاد بگیرید و اصلاً زمان خود را روی یادگیری از ۰ تا ۱۰۰ ابزار مد نظر نگذارید!






# شنایی با مزایای ابزارهای تحلیل سورس‌کد

در سال‌های اخیر شاهد آن بوده‌ایم که تست نرم‌افزار به بخشی لاینفک از فرایند توسعه مبدل شده است اما در عین حال، تست صرفاً یکی از ابزارهایی است که از آن طریق می‌توان کیفت کد را بهبود بخشید!

از زمانی که زبان برنامه‌نویسی C یک پدیدهٔ تازه بود تا امروز که زبان‌های سطح‌بالای بسیاری وارد صنعت توسعهٔ نرم‌افزار شده‌اند، ابزارهای تحلیل کد روز به روز پیشرفت بیشتری کرده به طوری که امروزه این دست ابزارها قدرت تحلیل به مراتب بیشتری نسبت به نمونه‌های اولیهٔ‌شان دارند.

مثلاً ابزاری همچون Pylint که برای تحلیل کدهای Python به کار می‌رود یا ابزار Splint برای زبان C، این امکان را به دولوپر می‌دهند که تنظیم کند چه نوع هشدارها، ارورها و خطاهایی در معرض دیدش قرار گیرند.

به طور کلی، امروزه در کنار تست نرم‌افزار نیاز به فاز دیگری تحت عنوان تحلیل هم داریم تا این اطمینان را حاصل کنیم که کدها بهینه هستند، مقدار استفاده از منابع سیستمی در بهترین حالت ممکن قرار دارند و در نهایت کدی که نوشته شده است، بهترین کدی است که می‌توانست وجود داشته باشد!






# در تست نرم‌افزار فقط رفتار مورد انتظار را بسنجید

یکی از دام‌هایی که دولوپرها در حین تست نرم‌افزار در آن گرفتار می‌شوند این است که بر این باورند آنچه نرم‌افزار انجام می‌دهد دقیقاً همان تسکی است که قصد تست آن را دارند. گرچه در ظاهر چنین چیزی اصلاً دام تلقی نمی‌شود اما اگر کمی بیشتر این موضوع را بشکافیم، منظور واضح‌تر بیان گردد: یک اشتباه رایج در فرایند تست نرم‌افزار این است که تست را برای خصوصیات جانبی نسخهٔ مد نظر نرم‌افزار نوشت و این در حالی است چنین خصوصیاتی جانبی بوده و خیلی سنخیتی با رفتاری از نرم‌افزار که قصد سنجش آن را داریم ندارند!

در چنین شرایطی، یعنی زمانی‌ که تست‌ها به گونه‌ای نوشته می‌شوند که با برخی خصوصیات جانبی نرم‌افزار هماهنگ شده باشند، اعمال تغییرات روی بخش‌هایی از نرم‌افزار که مرتبط با رفتاری است که قرار آن را تست کنیم، منجر به شکست تست می‌شود. در چنین شرایطی، دولوپرها معمولاً یا دست به ریفکتورینگ کد می‌زنند و یا تست را مجدد می‌نویسند که چنین کاری اوضاع را خراب‌تر می‌کند بلکه توصیه می‌شود مشکل ریشه‌ای حل گردد.

برای روشن‌تر شدن این مسأله مثالی می‌زنیم. اگر تستی بنویسیم که علاوه بر سنجش رفتار نرم‌افزار، مثلاً جایگاه قرارگیری اِلِمان‌های روی صفحه را نیز بسنجد، اگر به هر دلیلی تغییری در رابط کاربری بدهیم و سپس نرم‌افزار را تست کنیم، تست ما با شکست مواجه می‌شود و این در حالی است که مد نظر قرار دادن چنین مسائل جانبی و به نوعی حاشیه‌ای، صرفاً به پیچیده‌تر کردن تست‌ها منجر شده و احتمال بروز شکست آنها را بیشتر خواهد کرد.

با این تفاسیر، توصیه می‌شود که در حین نوشتن Unit Test، صرفاً رفتاری که از نرم‌افزار یا اپلیکیشن انتظار داریم را تست کنیم نه مسائل حاشیه‌ای که عملاً تغییری در رفتار اپلیکیشن ایجاد نمی‌کنند.






# تست‌ها علاوه بر صحیح بودن، می‌بایست دقیق هم باشند
در آموزش قبل گفتیم که در حین فرایند تست نرم‌افزار، ضروری است که عملکرد مورد انتظار از نرم‌افزار را تست کرد تا اینکه خصوصیات جانبی و حاشیه‌ای نرم‌افزار که ربطی هم به عملکردش ندارند مورد ارزیابی قرار گیرند اما این در حالی است که این سوء‌تفاهم نمی‌بایست پیش بیاید که تست‌های نرم‌افزاری می‌توانند کلی و دقیق نباشند! به‌ عنوان یک قانون کلی، یک تست خوب می‌بایست دقت و درستی عملکرد کد را بسنجد.

برای روشن‌تر شدن این مسأله، مثالی از دنیای واقعی برنامه‌نویسی می‌زنیم. الگوریتم سورت کردن یکسری داده (مثلاً از بزرگ به کوچک یا به ترتیب حروف الفبا) چیزی است که معمولاً دولوپرها با آن سروکار دارند. وقتی از دولوپری این سؤال پرسیده شود که هدف از تست چنین الگوریتمی چیست، پاسخی که معمولاً با آن مواجه می‌شویم این است که «داده‌ها باید به درستی یا از بزرگ به کوچک و با بالعکس سورت شوند».

گرچه چنین پاسخی کاملاً درست است، اما تمام ماجرا نیست! در واقع، یک تست دقیق برای سنجش چنین الگوریتمی این‌گونه عمل می‌کند که پس از سورت شدن، طول عناصر آرایهٔ مد نظر می‌بایست با طول آرایه قبل از سورت شدن یکسان باشد. گرچه چنین دیدگاهی درست است،‌ اما باز هم کافی نیست! به عنوان نمونه داریم:
```
3 1 4 1 5 9
```
خروجی زیر مجموعه اعدادی را نشان می‌دهد که هم از نظر طول با آرایهٔ اورجینال برابری می‌کند و هم اعداد از کوچک به بزرگ سورت شده‌اند:
```
3 3 3 3 3 3
```
اما می‌بینیم که تک‌تک المان‌های آرایه در خروجی وجود ندارند. این مثال برگرفته از کدی واقعی است که خوشبختانه پیش از ریلیس، باگ آن رفع شد؛ در واقع،‌ مشکل از اینجا ناشی می‌شد که کل خروجی با اولین عضو آرایه (عدد ۳) پر می‌شد.

پس ما می‌بایست تستی می‌نوشتیم که بسنجد کلیهٔ اعضای آرایه سورت شده، طول آن‌ها برابر با آرایهٔ اصلی باشد و از همه مهم‌تر، اعضا دقیقاً همان اعضای اورجینال باشند.

اگر بخواهیم تستی به معنای واقعی کلمه حرفه‌ای بنویسیم، باز هم شرایط توصیف شدهٔ بالا کفایت نمی‌کنند! در حقیقت، یک تست خوب باید خوانا، قابل‌فهم و در عین حال ساده باشد تا یک تستر به سادگی بتواند متوجه شود که آیا نتیجهٔ آن درست است یا غلط به طوری که یک دولوپر صاحب‌نام به اسم Hoare در این باره می‌گوید:

به‌طورکلی ۲ راه برای طراحی معماری یک نرم‌افزار وجود داره؛ راه اول این‌که آن‌قدر آن‌را ساده طراحی کنی که هیچ نقصی در آن وجود نداشته باشه و راه دوم این‌که آن‌قدر آن‌را پیچیده طراحی کنی که هیچ نقصی آشکارا در آن دیده نشه!

با این تفاسیر، به این نتیجه می‌رسیم که تست نرم‌افزاری در صنعت برنامه‌نویسی که روز به روز شاهد اپلیکیشن‌های پیچیده‌‌تری در آن هستیم الزامی است اما این در حالی است که تست‌ها علاوه بر سنجش صحت نرم‌افزار یا اپلیکیشن، می‌بایست دقیق هم باشند.






# تست نرم‌افزار و سورس‌کد را آخر شب‌ها و آخر هفته‌ها انجام دهید!

یکی از مسائلی که باعث می‌گردد دولوپرها پیش از تست کردن تغییرات خود، اقدام به کامیت آنها روی یک سیستم ورژن کنترل همچون گیت کنند این است که معمولاً تست‌ها زمان قابل‌توجهی برای تکمیل شدن به خود اختصاص می‌دهند. به همین دلیل، توصیه می‌شود که از زمان‌هایی که کار نمی‌کنید، مثل شب‌ها و آخر هفته‌ها، برای کارهای اتوماسیون همچون تست‌های طولانی و زمان‌بر استفاده نمایید و به سادگی صبح روز بعد خواهید توانست نتایج، لاگ‌ها و غیره را مشاهده کنید.

نکته‌ای که در ارتباط با تست نرم‌افزار در زمان‌های فوق‌الذکر وجود دارد این است که شبکه و همچنین سرورها در چنین زمان‌هایی بار و فشار زیادی رویشان نبوده و بالتبع با سرعت‌ بیشتری می‌توانند تسک‌های در نظر گرفته شده را تکمیل کنند.

با انجام کمی محاسبات و برخورداری از دانشی نسبی در مورد اسکریپت‌نویسی، می‌توان به سادگی تعدادی کرون جاب ایجاد کرد تا تست‌های مدنظرمان را در شب‌ها، آخر هفته‌ها و دیگر روزهای تعطیل رسمی تکمیل کنند.






# مقایسه‌ای مابین مهندسین نرم‌افزار و دیگر مهندسان

مهندسانی همچون متخصصین راه و ساختمان، مکانیک‌ها و غیره در طول صدها سال بر اساس قوانین ریاضیات و فیزیک، به یکسری اصول و اصطلاحاً Best Practice دست یافته‌اند که می‌تواند ساخته‌‌های ایشان را ایمن سازد. به طور مثال، وقتی که یک مهندس راه و ساختمان پلی می‌سازد، تست آن پل بدین گونه خواهد بود که ماشینی با بار سنگین از روی آن عبور می‌دهند و چناچه پل بدون هیچ‌گونه لغزش و سستی پابرجا باقی بماند، این بدان معنا است که مهندسی به درستی کارش را انجام داده است.

خوشبختانه یا متأسفانه در مهندسی نرم‌افزار تست محصول بدین گونه نخواهد بود چرا که ماهیت مهندسی نرم‌افزار با گونه‌های دیگر مهندسی کاملاً متفاوت است. وقتی پای اطمینان حاصل کردن از خروجی کار به میان می‌آید، هیچ‌وقت از یک مدیر پروژهٔ راه و ساختمان جمله‌ای همچون «ما زمان کافی برای تست این پل نداریم» نخواهیم شنید اما متأسفانه بسیاری از مدیران پروژه در صنعت توسعهٔ نرم‌افزار به خاطر وجود ددلاین‌های فشرده و گاهی‌اوقات غیرواقعی، اهمیت تست‌ نهایی نرم‌افزار را نادیده گرفته و تمام تمرکزشان روی این موضوع است که پروژه هرچه سریع‌تر به دست مشتری برسد.

در چنین شرایطی، این وظیفهٔ دولوپرها است که تحت هیچ شرایطی زیر بار ریلیس کردن نرم‌افزار بدون تست کامل و جامع آن نروند. در واقع، تست نرم‌افزار نه تنها کافی نیست، بلکه ضروری هم هست و دولوپرهای حرفه‌ای می‌توانند با ابزارهای تستی که امروزه به بازار عرضه شده‌اند و بسیاری از کارهای دولوپرها را به صورت خودکار انجام می‌دهند خود را از دیگر دولوپرهای غیرحرفه‌ای متمایز سازند.






# از نوشتن کدهای اضافی پرهیز کنید

فرض کنیم که در حال طراحی یک فروشگاه آنلاین بوده و درصدد هستیم تا بخش سبد خرید را کدنویسی کنیم. برای این منظور، کلاسی داریم تحت عنوان Order که حاوی متدهای مختلفی است من‌جمله ()isComplete که حاوی کدهای زیر است:
```C
function boolean isComplete()
{
    return isPaid() && hasShipped();
}
```
منطقاً یک سفارش قبل از اینکه پرداخت شود نمی‌تواند به دست مشتری برسد؛ لذا ()hasShipped نمی‌توان True باشد مگر اینکه ()isPaid برابر با True باشد و به خاطر همین مسأله است که بخشی از کد اضافی بوده و کد بالا را می‌توان به صورت زیر تغییر داد:
```C
function boolean isComplete()
{
    return hasShipped();
}
```
در تفسیر کدهای فوق بایستی گفت که به طور کلی، وقتی که در حال کار روی یک Order (سفارش) هستیم، ۳ وضعیت مختلف می‌تواند وجود داشته باشد:
- در جریان: مشتری می‌تواند آیتم‌هایی را به سبد خرید خود اضافه کرده و یا برخی موارد را حذف کند.
- پرداخت شده: مشتری دیگر نمی‌تواند آیتمی را حذف کند.
- ارسال شده: کار به اتمام رسیده است و هیچ‌گونه تغییری رخ نخواهد داد.

در فرایند توسعهٔ نرم‌افزار، بسیاری مواقع پیش می‌آید که شاهد کدهای اضافی هستیم که این مسأله به خاطر عدم توجه به State (وضعیت) قرار گرفته در آن صورت می‌گیرد. به عبارت دیگر، ما می‌بایست ببینیم که در چه وضعیتی قرار داریم، سپس بسته به شرایطی که پیش روی ما است، فرایندها را تعریف کنیم.

یکی از راه‌های خوب برای توجه به این مسأله، استفاده از متدهایی بامعنی، همچون چیزی که در بالا مشاهده کردیم، برای پیاده‌سازی دستوراتی است که مد نظر داریم. در یک کلام، به خاطر داشته باشیم که اگر فرایندی را روی تسکی در State (وضعیت) نادرستی انجام دهیم، کدهای ما منجر به ایجاد باگ‌ خواهد شد.






# اهمیت برنامه‌نویسی دونفره در کدنویسی را هرگز نادیده نگیرید

نیاز به توضیح نیست که کدنویسی نیاز به تفکر عمیقی دارد و تفکر عمیق هم در محیط‌های شلوغ امکان‌پذیر نبوده و نیازمند محیطی آرام و تنها است اما آنچه مسلم است اینکه در دنیای امروز فقط و فقط با تکیه بر داشته‌های خود نمی‌توان در حوزهٔ توسعهٔ نرم‌افزار به موفقیت‌های چندانی دست یافت و آشنایی با مهارت Team Work (کار گروهی) چیزی است که از دولوپرها، خواه فریلنسر باشند و خواه در تیم کد بزنند، انتظار می‌رود.

اما به خاطر داشته باشیم که منظور از کار گروهی این نیست که به سؤالات دیگر دولوپرها پاسخ دهیم، در جلسات شرکت کنیم، ایده بدهیم و کارهایی از این دست بلکه منظور کلی این است که به شکلی کاملاً پویا و فعال به همکاری با دیگر اعضای تیم بپردازیم.

در همین راستا، یکی از راه‌های پیاده‌سازی کار گروهی چیزی است تحت‌ عنوان Pair Programming (برنامه‌نویسی دونفره) که مزایای بسیاری برای هر دو دولوپر دارا است. اگر فرض را بر این بگذاریم که شما از همکارتان حرفه‌ای‌تر باشید، مسلماً با انتقال دانش خود منجر به ارتقاء مهارت‌های تیم توسعه خواهید شد و همچنین به توانایی‌های خود بیشتر واقف می‌گردید؛ اگر هم همکارتان از شما حرفه‌ای‌تر باشد، دیگر نیاز به توضیح نیست که این نوع کدنویسی می‌تواند در بالا بردن سطح مهارت‌های شما مفید واقع گردد.

آنچه مسلم است اینکه نگاه هیچ ۲ دولوپری در حین فرایند توسعهٔ نرم‌افزار ۱۰۰٪ شبیه به یکدیگر نیست و همین مسأله اهمیت برنامه‌نویسی دونفره را دوچندان می‌سازد چرا که دولوپرها می‌توانند از زوایای مختلفی به مسألهٔ پیش‌رویشان نگاه کرده و بهترین راه‌کار را برایش اتخاذ کنند.

حال بایستی از نقطه‌نظر مدیران شرکت‌های نرم‌افزاری هم به این قضیه نگاه کنیم؛ این دست مدیران که عموماً طرفدار مدیریت پروژه به سبک اجایل هستند بر این باورند که گماشتن ۲ دولوپر روی پروژه‌ای که ۱ دولوپر هم به خوبی از عهدهٔ آن برمی‌آید، کاری غیرمنطقی است!

چنین دیدگاهی کاملاً درست و به‌جا است و ما هرگز نمی‌گوییم که «باید» همواره کلیهٔ پروژه‌ها را با گماشتن ۲ دولوپر پیاده‌سازی کرد اما در اینجا بحث بالا بردن کیفیت کار از یک سو و انتقال دانش و ارتقاء مهارت‌های تک‌تک اعضای تیم توسعهٔ نرم‌افزار از سوی دیگر است.

نیاز به توضیح نیست که بازار کار همواره به دنبال بهترین دولوپرها است و اگر شرکت‌های نرم‌افزاری این شانس را داشته باشند که دولوپرهایی از این دست را به استخدام خود درآورده باشند، همواره بایستی این نگرانی را داشته باشند که روزی دولوپرهای درجه ۱ خود را از دست بدهند و این در حالی است که پیروی کردن از سیاست برنامه‌نویسی دونفره می‌تواند دانش، مهارت و تجربیات دولوپرهای حرفه‌ای تیم را تا حد امکان به دولوپرهای مبتدی‌تر انتقال دهد و چنانچه روزی برسد که دولوپر یا دولوپرهای حرفه‌ای تیم بخواهند شرکت را ترک کنند، می‌توان این اطمینان را داشت که بخش قابل‌توجهی از دانش ایشان با سایرین به اشتراک گذاشته شده است.

چه نوع دولوپرهایی می‌بایست با یکدیگر در یک تیم قرار بگیرند؟
اگر به طور مثال شما دولوپری مبتدی هستید، خیلی مهم است که در صورت داشتن امکان برنامه‌نویسی دونفره در شرکت به جای دولوپری مبتدی همچون خودتان، با فردی ماهرتر هم‌ گروه شوید اما بایستی به خاطر داشته باشیم که مهارت‌های فنی برای هم گروه شده صرفاً کافی نیستند بلکه فردی که قرار است هم گروه ما شود، می‌بایست از مهارت‌های برقراری ارتباط با دیگران و مربی‌گری نیز برخوردار باشد که در این صورت بهترین نتیجهٔ ممکن را خواهیم گرفت.






# منفی در مفنی می‌شود مثبت!
دولوپرها به خوبی می‌دانند که سورس‌کد هیچ وقت دروغ نمی‌گوید اما این در حالی است که همین سورس‌کد گاهی اوقات تضادهایی دارا است و برخی از همین تضادها است که منجر به این سؤال می‌گردد «چه‌طور ممکنه با این شرایط نرم‌افزار کار کنه؟»

یکی از دولوپرهای نرم‌افزار آپولو ۱۱ به نام Allan Klumpp در مصاحبه‌ای گفت که در این نرم‌افزار باگی وجود داشت که فرود آپولو را با مشکل مواجه می‌کرد اما این در حالی بود که باگی دیگری منجر به این شد که باگ اول خنثی گشته و این نرم‌افزار بدون هیچ مشکلی کار خود را انجام می‌داد و قبل از اینکه کشف گردد، در نرم‌افزار کنترل کنندهٔ موتورهای آپولو ۱۱ و آپولو ۱۲ مورد استفاده قرار می‌گرفت.

برای روشن‌تر شدن این مسأله، فانکشنی را در نظر بگیرید که این وظیفه را دارا است تا استاتوس (وضعیت) چیزی را برگرداند. گرچه این فانکشن می‌بایست در شرایط خاصی مقدار True را باز گرداند، اما خروجی همواره False است. علاوه بر این، فانکشنی که این فانکشن را صدا زده، هرگز مقداری بازگشتی را چک نمی‌کند! در چنین شرایطی، همه چیز به خوبی کار می‌کند تا اینکه دولوپری به این قضیه پی‌ببرد.

زمانی‌ که در سورس‌کدی ۲ باگ وجود داشته باشد که با همکاری یکدیگر منجر به این خواهند گشت تا نرم‌افزار در ظاهر بدون مشکل کار کند، وقتی یکی از باگ‌ها مرتفع گردد و باگ دیگر بابرجا باقی بماند، نرم‌افزار به مشکل برخواهد خورد. به عبارت دیگر، دولوپری که مسئولیت نگهداری کد را بر عهده دارد، ریپورتی دریافت می‌کند مبنی بر وجود باگی در سیستم؛ وی باگ را یافته و آن را رفع می‌کند اما مشاهده می‌شود که مشکل کماکان پابرجا است چرا که باگ دوم هنوز به قوت خود باقی است. در چنین شرایطی، وی باگ اول را به حالت اولیهٔ خود بازگردانده و کد را بررسی می‌کند تا به باگ دوم دست یابد و آن را فیکس می‌کند اما مشاهده می‌شود که مجدد مشکل نرم‌افزار پابرجا است. بنابراین مشکل دوم نرم‌افزار که ریفکتور شده بود را به حالت قبل بازمی‌گرداند و در چنین شرایطی دولوپر به دنبال یک باگ سومی می‌گردد که چیزی بیش از یک دور باطل نخواهد بود چرا که اصلاً باگ سومی در کار نیست!

در چنین شرایطی، تعامل مابین ۲ باگ که منجر به ایجاد نتایج منتظره‌ای می‌شوند باعث می‌شود تا فرایند دیباگینگ نرم‌افزار بسیار دشوار گردد (جالب است بدانیم که چنین مسأله‌ای ممکن است در مستندات پروژه هم ایجاد گردد به طوری که اروری در کد با همکاری مشکلی در نوشتن مستندات پروژه دست به دست یکدیگر داده تا دولوپرها سردرگم شوند).

در یک کلام، بایستی گفت که هیچ راه‌کار عملی برای موقعیت‌هایی اینچنین وجود ندارد و چنانچه دولوپری در موقعیت‌هایی از این دست قرار گیرد، می‌توان این انتظار را داشت که روزها و شاید هفته‌ها یا ماه‌ها درگیر فرایند دیباگینگ گردد.






# کدنویسی تمیز و اصولی یک باید است

وقتی دولوپری به تنهایی کد می‌زند، وی تفسیری شخصی از مسألهٔ پیش‌رو خواهد داشت و بالتبع هم راه‌کاری که اتخاذ می‌کند کاملاً شخصی خواهد بود. جالب است بدانیم گرچه برخی دیگر دولوپرها در یک تیم کار می‌کنند، اما باز هم ممکن است راه‌کارهایی که به کار می‌گیرند تکی و کاملاً شخصی باشند غافل از اینکه کدی که می‌نویسند، روزی می‌بایست توسط دیگر دولوپرها دیباگ شود، توسعه داده شود و یا نگهداری گردد.

آنچه در مورد توسعهٔ نرم‌افزار امروزه خیلی مورد توجه نمی‌گیرد این است که برخی کدنویسی را صرفاً یک مهارت فنی تلقی می‌کنند اما این در حالی است که توسعهٔ نرم‌افزار ترکیبی از مهارت‌های فنی + مهارت‌های اجتماعی و ارتباطی است!

زمانی که ما در یک تیم نرم‌افزاری کد می‌زنیم، بایستی توجه داشته باشیم که کیفیت کد ما می‌تواند کیفیت کد سایر دولوپرها را نیز تحت تأثیر خود قرار دهد. به عبارت دیگر، اگر یکی از اعضای تیم توسعه به کار با کیفیت اعتقاد نداشته باشد و یا آن‌طور که باید و شاید حرفه‌ای نباشد، این عدم مهارت وی می‌تواند سطح کدنویسی دیگر اعضای تیم را هم پایین بکشاند و این در حالی است که تأثیرات منفی این قضیه کل تیم را تحت‌الشعاع خود قرار خواهد داد.

در واقع، وقتی که ما تمیز کدنویسی کنیم، سورس‌کدی که از ما به دیگر همکارانمان به ارث می‌رسد منجر به این خواهد گشت که ایشان هم با همان فرمان پروژه را ادامه دهند و این بدان معنا است که اگر ما خشت اول را درست بنا نهیم، این فرهنگ در میان تک‌تک اعضای تیم شکل خواهد گرفت که به کار باکیفیت، کدنویسی تمیز و اصولی پایبند باشند (البته عکس این موضوع هم کاملاً صادق است).






#  ابزارهای یونیکسی دوست دولوپرها هستند!

فارغ از اینکه با چه زبانی کد بزنیم، در چه حوزه‌ای به توسعهٔ اپلیکیشن بپردازیم و از چه ابزارهایی برای کدنویسی استفاده کنیم، برای دولوپرها استفاده از ابزارهایی که برای UNIX به بازار عرضه شده‌اند یک باید است.

اگر بخواهیم به عمده‌ترین دلایل استفاده از ابزارهای یونیکسی اشاره کنیم، بایستی بگوییم که به طور مثال IDEها برای زبان‌های برنامه‌نویسی به‌خصوصی طراحی شده‌اند اما این در حالی است که ابزارهای یونیکسی برای هر چیزی کاربرد خواهند داشت. در عصری که سال به سال زبان‌های برنامه‌نویسی جدیدی به بازار عرضه می‌شوند، سرمایه‌گذاری روی ابزارهای جهان‌شمولی همچون «اپلیکیشن‌های یونیکسی» به منزلهٔ سرمایه‌گذاری در صرفه‌جویی زمان و انرژی دولوپر است.

نکتهٔ دیگری که در ارتباط با تفاوت‌های یک IDE با یک UNIX Tool وجود دارد این است که معمولاً محیط‌های توسعهٔ یکپارچه (IDE) از یکسری کامندهای از پیش‌ تعریف شده برخوردارند که دولوپرها با استفاده از آنها به کدنویسی می‌پردازند،؛ اما دولوپرها با استفاده از ابزارهای یونیکسی می‌توانند محیط‌های توسعهٔ نرم‌افزار کاستومایز شدهٔ خود را ایجاد کنند و بسته به تمایلات شخصی خود، دست به ساخت محیطی بزنند که سرعت توسعهٔ ایشان را چند برابر کند.

علاوه بر این، وقتی که ما به عنوان یک دولوپر کار با یک IDE را فرا می‌گیریم، کلیدهای میانبر، کامندها و غیره همگی اختصاصی همان نرم‌افزار هستند و این در حالی است که اگر روزی بخواهیم به نرم‌افزار دیگری مهاجرت کنیم، می‌بایست با یکسری کلید میانبر جدید آشنا شویم اما وقتی که ما با ابزارهای یونیکسی همچون کامندهای cat ،sed ،grep و غیره آشنا شویم، این ابزارها جهان‌شمول بوده و در هر جایی و هر سیستم‌عامل قابل استفاده می‌باشند.

نکته البته به خاطر داشته باشیم که در IDEها به سادگی می‌توان کلیدهای میانبر را شخصی‌سازی کرد و همین مسأله منجر به این خواهد گشت که مهاجرت از یک نرم‌افزار به نرم‌افزاری دیگر خیلی چالش‌برانگیز نباشد.
جالب است بدانیم که ابزارهای UNIX در عصری ابداع شدند که یک سیستم چندکاربره (Multiuser) حافظهٔ رَمی برابر با ۱۲۸ کیلوبایت داشت و طراحان چنین ابزارهایی می‌بایست به بهینه‌ترین شکل ممکن به کدنویسی ابزارهای مد نظرشان می‌پرداختند تا با استفاده از کمترین منابع سیستمی، کار چنین کاربر را راه بیندازند.

علاوه بر این، اگر کامندی را خیلی مفید یافتیم و یا کارمان به شکلی است که بارها و بارها می‌بایست از آن در حین فرایند کاری خود استفاده نماییم، به سادگی می‌توان کامند مد نظر را در قالب یک فایل بَش پکیج نموده و به عنوان یک نرم‌افزار کامندلاینی کوچک از آن استفاده نماییم.

نکتهٔ دیگری که در ارتباط با ابزارهای یونیکسی که در سیستم‌عامل‌های مبتنی بر UNIX همچون لینوکس و مکینتاش وجود دارند این است که اکثر این ابزارها اپن‌سورس و رایگان هستند و همین مسأله میزان محبوبیت آنها را در میان دولوپرها دوچندان کرده است.

در پایان هم بایستی گفت اگر هیچ‌کدام از ابزارهای یونیکسی عرضه شده به بازار نیازهای شما را مرتفع نمی‌سازند، با یادگیری Shell Scripting به سادگی قادر خواهید بود دست به کدنویسی ابزارهای اختصاصی خود بزنید.






# استفادهٔ درست از الگوریتم‌ها و دیتا استراکچرها

زمانی که استفاده از کامپیوترهای تجاری تازه فراگیر شده بودند، بانکی معروف با شعب مختلف که به تازگی استفاده از سیستم‌های کامپیوتری را در دستور کار قرار داده بود، از پرفورمنس سیستم‌هایش به شرکت نرم‌افزار شکایت کرده و تهدید کرده بود که اگر سرعت نرم‌افزاری که منجر به ایجاد صف‌های طولانی مشتریان می‌شد را بهبود نبخشند، قرارداد را فسخ خواهد کرد.

شرکت‌ نرم‌افزاری هم چند متخصص و تحلیلگر به شعبه‌ٔ مرکزی بانک مذکور فرستاد تا ریشهٔ مشکل را بیابند و چیزی نگذشت که دریافتند کدی توسط مدیر آی‌تی خود بانک روی سیستم نوشته شده بود که در بک‌گراند به صورت کامندلاینی اجرا می‌شد و تقریباً می‌شود گفت تمام پتانسیل CPU را استفاده می‌کرد:
```C
for (i=0; i < strlen(s); ++i) {
if (... s[i] ...) ...
}
```
در واقع، در تحلیل کد فوق بایستی گفت که استرینگ s به طور میانگین حاوی هزاران کاراکتر بود و با ایجاد یکسری تغییر در کد، مشکل بانک به سادگی حل شد! به عبارت دیگر، فراخوانی متد ()strlen تک‌تک هزاران کاراکتر موجود در s را شامل می‌شد و این در حالی بود که اگر دولوپر این کد از قبل طول این استرینگ را مشخص می‌کرد، می‌توانست هزاران فراخوانی متد ()strlen و بالتبع میلیون‌ها اجرای لوپ را از سیستم حذف کند. کد فوق به صورت زیر به سادگی بهینه شد:
```C
n = strlen(s);
for (i=0; i < n; ++i) {
if (... s[i] ...) ...
}
```
برخی دولوپرها بر این باورند که استراتژی «اول کدی بنویس که کار کند، سپس آن را بهینه کن» خیلی عالی است اما می‌بینیم که گاهی‌اوقات -همچون مثال فوق- چنین ایده‌ای اصلاً کار نمی‌کند و سیستم را با مشکل مواجه می‌سازد. اینجا است که اهمیت استفاده از یک الگوریتم مناسب دوچندان می‌گردد.

علاوه بر به‌کارگیری الگوریتم درست، دیتا استراکچر مناسب نیز می‌تواند پرفورمنس سیستم را به طرز قابل‌توجهی افزایش دهد. برای روشن‌تر شدن این مسأله مثالی می‌زنیم. فرض کنیم که قصد داریم اطلاعات کاربران خود شامل نام و نام خانوادگی، سن، جنسیت، شهر محل سکونت، تحصیلات و غیره را ذخیره ساخته تا در مواقع مختلف بر اساس معیارهای خاصی همچون سن، جنسیت، محل سکونت و غیره نوتیفیکیشن‌هایی را برای ایشان ارسال کنیم.

مسلماً در چنین شرایطی استفاده از دیتا استراکچر مناسب نتیجهٔ بسیار مطلوبی برایمان در بر خواهد شد. به عبارت دیگر، استفاده از جدولی که در آن داده‌های مرتبط با کاربران به صورت اصطلاحاً Serialized شده ذخیره گردد اصلاً بهینه نبوده بلکه در عوض نیاز به جدولی خواهیم داشت که ستون‌های مورد نیاز به خوبی در آن ایندکس شده باشند.

برخی بر این باروند که مهم‌ترین استراتژی در کدنویسی استفاده از کدهایی است که قبلاً نوشته شده است اما نکتهٔ مهم اینجا است که ما به عنوان یک دولوپر حرفه‌ای می‌بایست بدانیم که چه چیزی را چگونه و در چه زمانی استفاده کنیم (شاید مدیر آی‌تی بانک مذکور کد فوق را از داخل پروژه‌ای دیگر برداشته باشد که قرار بوده صرفاً تعداد کاراکتر معدودی به فانکشن ()strlen پاس داده شود که مسلماً در چنین شرایطی کد به خوبی کار می‌کرده است).






# با لاگ‌گیری Verbose دچار دردسر خواهید شد!
لاگ گیری (Logging) به منزلهٔ بخشی مهم در فرایند توسعهٔ نرم‌افزار است. در واقع، این لاگ‌ها هستند که وقتی چیزی به درستی کار نمی‌کند، در فرایند مانیتورینگ نرم‌افزار چراغ راه دولوپر خواهند شد و تا حد ممکن وی را به سرچشمهٔ مشکل راهنمایی می‌کنند. در عین حال، در نظر داشته باشیم که همان‌قدر که نبود لاگ‌ها می‌توانند دولوپرها را فرایند دیباگینگ به دردسر بیاندازد، لاگ‌های غیرضروری و زیادی -اصطلاحاً Verbose- هم‌ می‌توانند آزاردهنده باشند!

نکته به طور کلی، منظور از Verbose Loggin نوعی از لاگ‌گیری است که در آن اطلاعاتی بیش از آنچه لازم است ذخیره خواهیم ساخت (Verbose در لغت به معنای «استفاده از واژگان بیش از حد» است). در واقع، Verbose Loggin زمان به کار می‌آید که نیاز به موشکافی دقیق یک سیستم نرم‌افزاری داشته باشیم و بخواهیم آن را دیباگ کنیم و در حالت عادی غیرفعال می‌گردد چرا که منجر به ایجاد لاگ فایل‌های بسیار حجیم خواهد شد.
برای درک بهتر این مسأله، بایستی فرایند لاگ‌گیری نرم‌افزار را به علائم بیماری تشبیه کنیم. در حقیقت، ورم زیاد در ناحیهٔ شکم یک نوع علامت است و سرفه کردن هم‌ نوع دیگری از علائم بیماری. مسلماً کمتر کسی را می‌توان یافت که ورم ناحیهٔ شکم را جدی نگیرد و به آن بی‌توجهی کند چرا که از یک مشکل ساده در معده تا خدای ناکرده وجود یک غدهٔ سرطانی را می‌تواند شامل گردد اما این در حالی است که در بسیاری از مواقع، سرفه کردن صرفاً نشان از یک سرماخوردگی ساده دارد (البته همواره استثناء‌هایی وجود دارد).

البته در نظر داشته باشیم که فرایند لاگ‌گیری به همین سادگی‌ها نیست. به طور مثال، سرویس‌هایی که در آنها از چندین زبان‌ برنامه‌نویسی مختلف،‌ لایبرری و فریمورک استفاده شده است،‌ فرایند لاگ‌گیری بسیار پیچیده و دشوار خواهد بود و در چنین شرایطی حتماً می‌بایست این نکته را هم مد نظر داشته باشیم که گاهی‌اوقات ارور ایجاد شده کاملاً خارج از حیطهٔ اختیارات ما است (مثلاً زمانی که از API یک وب‌سایت دیگر استفاده می‌کنیم،‌ در صورت بروز مشکل در سرورهای آن وب‌سایت، مسلماً سرویس ما هم تحت‌الشعاع قرار خواهد گرفت).

برای این منظور، می‌توان ستونی تحت‌عنوان مثلاًً log_level در جدول مخصوص ذخیره‌سازی لاگ‌ها در نظر گرفته که سطح و نوع ارورهایی که سیستم با آنها دست و پنجه نرم‌ می‌کند را مشخص سازیم. به عبارت دیگر، سطوح پایین‌تر مثل سطح یک یا دو را به ارورهای قابل چشم‌پوشی و سطوح بالاتر از دو را به ارورهای جدی اختصاص داد و اینجا است که به سادگی فردی که مسئول مانیتور کردن سیستم است خواهد توانست مشکلات را در اسرع وقت رصد کند.






# درک تفاوت مفاهیم DRY و WET در کدنویسی بهینه

در کدنویسی مفهومی داریم تحت عنوان DRY که مخفف واژگان Don't Repeat Yourself و به طور خلاصه این مفهوم حاکی از آن است که در کدنویسی هیچ‌گاه نمی‌بایست فانکشنی -یا به طور کلی کدی- که کار یکسانی انجام می‌دهد را دو بار بنویسیم. به عبارت دیگر،‌ در کدنویسی سیستم مد نظر، دوباره‌کاری ممنوع است.

نقطهٔ مقابل DRY،‌ مفهوم دیگری است تحت عنوان WET که مخفف واژگان Write Every Time است. به عبارت دیگر، وقتی برای کار واحد یا یکسانی بیش از یک بار فانکشنی -یا به طور کلی کدی- را بنویسیم، سورس‌کد ما اصطلاحاً WET شده است.

وقتی پای پرفورمنس (عملکرد) به میان می‌آید، تفاوت فاحشی مابین سورس‌کدهای به اصطلاح DRY و WET به میان می‌آید. برای روشن‌تر شدن این مسأله، مثالی می‌زنیم.

فرض کنیم در سیستم خود فیچری داریم تحت عنوان X که مصرف CPU زیادی را به خود اختصاص می‌دهد و چیزی بیش از ۳۰٪ توان هستهٔ سیستم را مصرف می‌کند. حال مجدد فرض کنیم که این فیچر بیش از ۱۰ بار در جای‌جای نرم‌افزار به کار گرفته شده است که به طور میانگین، هر بار فراخوانی این فیچر ۳٪ از توان CPU را استفاده می‌کند. اینجا است که دولوپری که قصد دیباگ کردن چنین سیستمی را داشته باشد گمراه خواهد شد چرا که در نگاه اول ۳٪ کاملاً قابل‌ چشم‌پوشی است.

اما اگر فرض کنیم که متوجه شدیم که مشکل از همین X می‌باشد، اینجا است که اگر از رویکرد WET استفاده کرده باشیم، از این پس بایستی به دنبال هر ده جایی که X در آن استفاده شده گشته و مشکل آنها تک به تک رفع کنیم اما این در حالی است که اگر از رویکرد DRY در کدنویسی پروژه استفاده کرده باشیم، صرفاً در یک جا کد را می‌بایست ریفکتور کرده و به یک‌باره ۳۰٪ بهبود پرفورمنس را مشاهده خواهیم کرد.

به طور کلی، مزیت DRY نسبت به WET علاوه بر پرفورمنس بالاتر و سورس‌کد تمیزتر، امکان دیباگ کردن سریع‌تر سورس‌کد خواهد بود که این مسأله در پروژه‌های بزرگ بسیار حیاتی است.






# تعامل مابین دولوپرها و تسترها

اگر بتوان در تیم‌های توسعهٔ نرم‌افزار فضایی ایجاد کرد که دولوپرها و تسترها به تعامل سازنده‌ای با یکدیگر بپردازند، این کار مزایای بسیاری در بر خواهد داشت که از جملهٔ مهم‌ترین آن‌ها می‌توان به این نکته اشاره کرد که به راحتی تفاوت مابین یک باگ و فیچر در ذهن دولوپرها و تسترها مشخص می‌شود، نیازی به استفاده از نرم‌افزارهای پیشرفتهٔ دیباگینگ وجود نخواهد داشت چرا که یک تستر واقعی نرم‌افزار را تست کرده است و مهم‌تر از همه اینکه محصول نهایی که به دست مشتریان می‌رسد، اصطلاحاً Bug Free (بدون باگ) خواهد بود.

گاهی‌اوقات می‌شود پا را از این هم فراتر گذاشت و به عنوان یک تستر، حتی قبل از شروع کدنویسی یک فیچر جدید توسط دولوپرها، اقدام ارائهٔ روش‌های تست نرم‌افزار کرد به ایشان کرد (مثلاً اینکه نرم‌افزار به چه شکلی تست می‌شود) تا بر آن اساس، دولوپرها شروع به کدنویسی کنند و دغدغه‌های تسترها را در حین کدنویسی مد نظر داشته باشند.

آنچه مسلم است اینکه دولوپرها و تسترها هرگز نباید یکدیگر را «دشمن» تلقی کنند بدین صورت که مثلاً تسترها تمام تلاش خود را به کار بندند تا اپلیکیشنی که توسط همکارانشان کدنویسی شده را هک کنند تا به ایشان ثابت کنند که کار خود را بلد نیستند؛ بلکه هدف ارتقاء کیفیت کار است.

در واقع، از آنجا که هدف اصلی چیزی نیست جز ارائهٔ یک اپلیکیشن باکیفیت به مشتری، این تعامل مابین تک‌تک اعضای تیم به هرچه عملی‌تر شدن این پروسه کمک بیشتری خواهد کرد.






# طوری کد بزنید که گویی قرار است تا آخر عمر سورس‌کدتان را ساپورت کنید!

۹۶ چیزی که در این دورهٔ آموزشی مطرح شده یک طرف، پیاده‌سازی آنچه در ادامه می‌بینید طرف دیگر:

طوری کد بزنید که گویی قرار است تا آخر عمر سورس‌کدتان را ساپورت کنید!

در واقع، اگر بتوانیم در حین کد زدن چنین چیزی را رعایت کنیم، اتفاقات بسیار خوبی در انتظار ما خواهد بود. برای روشن‌تر شدن اهمیت این مسأله، اجازه دهید شرایط زیر را مد نظر قرار دهیم.

فرض کنیم وقتی که با یک شرکت نرم‌افزاری به عنوان دولوپر قرارداد می‌بندیم، کارفرمای ما این اجازه را خواهد داشت که تا ۱۰ سال آینده، در هر ساعت از شبانه‌روز -مثلاً ۳ نیمه‌شب- با ما تماس گرفته و پشتیبانی طلب کند.

صرفاً در چنین شرایطی است که ما در انتخاب نام کلاس‌ها، متدها و متغیرها تمام دقت را به خرج خواهیم داد تا نام‌هایی بامسمی انتخاب کنیم، فانکشن‌هایی نخواهیم نوشت که طول آنها صدها خط باشد، از دیزاین پترن‌ها به بهترین شکل ممکن استفاده خواهیم کرد،‌ کامنت‌گذاری اصولی خواهیم داشت و چیزهایی از این دست.

به خاطر داشته باشیم کدی که ما به عنوان دولوپر می‌نویسیم، به نوعی جزو رزومهٔ ما محسوب می‌گردد و دیگر دولوپرهایی که با کدهای ما کار خواهند کرد، از روی نحوهٔ کدنویسی ما به میزان حرفه‌ای بودن ما نیز پی خواهند برد و در دراز مدت ایماژی مثبت یا منفی نسبت به ما شکل خواهد گرفت.






# تا حد ممکن فانکشن‌های کوچک بنویسید

وقتی که صحبت از اندازهٔ (Size) یک فانکشن یا تابع به میان می‌آید، منظور هم می‌تواند تعداد خطوطی که داخل فانکشن مد نظر نوشته شده باشد و هم تعداد تَسک‌هایی که آن فانکشن قرار است انجام دهد.

گرچه هر دو موضوع از اهمیت بسزایی برخوردارند، اما تخصصی بودن فانکشن از اهمیت به مراتب بیشتری برخوردار است. در واقع، هرچه ما فانکشن‌هایی که می‌نویسیم تخصصی‌تر باشند، مدیریت سورس‌کد در آینده، خواندن کدها توسط دیگر دولوپرها و به حداقل رساندن وابستگی‌ها در سورس‌کد پروژه‌ٔ خود بیشتر و بیشتر می‌شود.

به عبارت دیگر، هر فانکشن نباید بیش از یک تَسک (کار) را انجام دهد که در چنین حالتی می‌گوییم فانکشن مد نظر دارای قابلیت Single Responsibility است.






# برای دولوپرها تست بنویسید نه برای ماشین‌ها!
اگر شما جزو دولوپرهایی هستید که در حین پیاده‌سازی پروژه‌های نرم‌افزاری اقدام به نوشتن Automated Test می‌کنید،‌ بایستی بدانید که این کار بسیار روند توسعهٔ نرم‌افزار شما را اثربخش می‌سازد و اگر هم جزو آن دسته از دولوپرهایی هستید که قبل از نوشتن کدهای اصلی، ابتدا به ساکن اقدام به نوشتن تست می‌کنید، بایستی به شما تبریک گفت؛ اما در عین حال سؤال اینجا است که آیا تست‌هایی که می‌نویسید خوب هستند؟

برای یافتن پاسخ به این سؤال، بایستی از خود بپرسید که «تست‌های نرم‌افزاری برای چه کسی نوشته می‌شوند؟» و چنانچه پاسخ به این سؤال چیزهایی همچون «برای خود دولوپر» یا «برای کامپایلر» باشد، این حاکی از آن است که تست‌های خوبی ننوشته‌اید!

در حقیقت، یک تست نرم‌افزاری خوب تستی است که به منزلهٔ مستندات پروژه تلقی می‌گردد و حاکی از آنند که سورس‌کد چگونه کار می‌کند. در واقع تست‌ها:
- نقطهٔ شروع اپلیکیشن را به هر دولوپری نشان می‌دهند.
- کاربرد نرم‌افزار را برای هر دولوپری تشریح می‌کنند.
- نتایج قابل انتظار را به هر دولوپری نشان می‌دهند.

بسته به نوع کاربرد، ما نیاز داریم تا تست‌های مختلفی بنویسیم. همچنین دولوپر دیگری که قرار است روی سورس‌کد ما کار کند، بایستی با مد نظر داشتن سه نکتهٔ فوق،‌ بتواند دقیقاً پی به نوع عملکرد نرم‌افزار ببرد. از سوی دیگر، هر تست نرم‌افزاری باید به وضوح رابطهٔ علت-معلولی مابین این سه بخش را شرح دهد.

در حین طراحی تست‌های نرم‌افزاری، حتماً اسم‌هایی بامسمی‌ برای آنها در نظر بگیرید؛ از سوی دیگر، کاربرد هر تستی بایستی کاملاً مشخص باشد تا دیگر دولوپرها به منظور درک ماهیت تست، مجبور به مهندسی معکوس کردن نباشند.

تست کردن تست‌ها
یک راه‌کار خوب برای اطمینان حاصل کردن از این که هم سورس‌کد اصلی و هم تست‌ها به خوبی کار می‌کنند، تست کردن تست‌ها است بدین صورت که از عمد باگ‌هایی در سورس‌کد اصلی پروژه ایجاد کرده و تست‌ها را اجرا کنید تا اطمینان حاصل کنید که باگ‌ها خیلی سریع توسط تست‌ها یافت می‌شوند.

همچنین اطمینان حاصل کنید که اکسپشن‌ها و ارورهای معناداری در معرض دید دولوپر قرار می‌گیرد و دولوپر به سادگی با نگاه کردن به ارور، متوجهٔ ریشهٔ باگ خواهد شد.






# مراقب سورس‌کد باشید!

بعید به نظر می‌رسد دولوپری را بتوان یافت که دوست نداشته باشد برچسب حرفه‌ای رویش بخورد. به طور کلی، به دولوپری می‌توان لقب حرفه‌ای داد که کدهای حرفه‌ای هم بنویسید؛ اگر هم بخواهیم کدی حرفه‌ای به نظر برسد، باید به نحوهٔ نوشتن آن توجه قابل‌توجهی کرد.

کدنویسی حرفه‌ای و اصولی اصلاً ربطی به دانش فنی دولوپر ندارد. بسیار کسانی هستند که می‌توانند الگوریتم‌های بسیار پیچیده‌ای طراحی کنند اما زمانی که پای کدنویسی به میان می‌آید، کدهای بسیار زشتی می‌نویسند. به عبارت دیگر، درک، استفاده و ریفکتور کردن کدهای ایشان بسیار دشوار است. در مقابل، دولوپرهای تازه‌کار و حد متوسطی را هم می‌توان یافت که دانش فنی ایشان اصلاً به پای گروه فوق‌الذکر نمی‌رسد، اما کدهای ایشان در یک کلام عالی است.

به نوعی می‌توان گفت که یکی از وجوه تمایز دولوپرهای عالی با سایر دولوپرها،‌ نگرش ایشان به کار است. این گروه از دولوپرها به خوبی با ضرب‌العجل (ددلاین) تحویل پروژه، محدودیت‌های فنی و غیره آشنایی دارند، اما در عین حال تمام تلاش خود را می‌کنند تا بهترین کدی که می‌شود را بنویسند. به طور کلی، اگر قصد دارید حرفه‌ای به نظر برسید، بایستی کدهای حرفه‌ای بنویسید و برای نوشتن کدهای حرفه‌ای هم می‌توانید استراتژی‌های زیر را مد نظر قرار دهید:

- تحت هر شرایطی، صرفاً به کار کردن کد تحت شرایط عادی رضایت ندهید؛ بلکه تمام تلاش خود را به کار گیرید تا تمامی جوانب کار را بسنجید. در واقع، از سالم بودن کد (قابل اجرا بودن کد تحت هر شرایطی) اطمینان حاصل کنید.

- کدی بنویسید که از یک سو هر دولوپر دیگری بتواند از آن سر در بیاورد و از سوی دیگر، قابل پشتیبانی و گسترش باشد.

- امروزه کمتر دولوپر موفقی را می‌توان یافت که به تنهایی کار کند؛‌ اکثراً یا در شرکت‌های نرم‌افزاری مشغول به کار هستند و یا اگر هم در منزل روی پروژه‌های اپن‌سورس کار می‌کند، با دیگر دولوپرهای سراسر دنیا در تعامل هستند. در همین راستا، روی مهارت‌های ارتباطی خود با دیگر همکاران فنی/غیرفنی نیز کار کنید.

- هر موقعی که با کدی برخورد کردید، تمام تلاش خود را به کار گیرید تا حتی اگر شده اندکی آن را بهبود بخشید (اگر توانستید که ساختار را بهبود بخشید و اگر امکان‌پذیر نبود، حداقل با کامنت‌گذاری درک آن را بهبود بخشید).

- گرچه دولوپرها همواره در معرض تکنولوژی‌های جدیدی هستند اما این هرگز بدان معنا نیست که در هر پروژه‌ای باید از جدیدترین تکنولوژی‌ها استفاده کنید بلکه بایستی نیاز پروژه را درک کرده و بسته به ماهیت، نیازها و زیرساخت پروژه اقدام به استفاده از زبان‌ برنامه‌نویسی، لایبرری، فریمورک و یا ابزار مناسب کنید.






# منظور مشتریان شما چیزی نیست که می گویند!

تجربه نشان داده است که مشتریان پروژه‌های نرم‌افزاری هرگز نمی‌دانند که چه می‌خواهند! گرچه گاهی‌اوقات ایشان اصلاً نمی‌دانند که چه می‌خواهند، اما در بیشتر مواقع ایشان می‌دانند که چه چیزی مد نظرشان است اما نمی‌توانند آن را به زبانی که برای دولوپر جماعت قابل‌فهم باشد بیان کنند.

در واقع، همین که مشتریان جزئیات قابل‌توجهی را در حین مذاکرات با تیم توسعهٔ نرم‌افزار از قلم می‌اندازند، صدمات جبران‌ناپذیری به روند اجرای پروژه می‌زند. به طور مثال، ایشان فرض را بر این می‌گذارند که دولوپر/دولوپرها با ماهیت کاری ایشان، شرکت، نیازها، مخاطبین و چیزهایی از این دست آشنایی دارند.

نکتهٔ دیگری که در این رابطه وجود دارد این است که اکثر مشتریان پروژه‌های نرم‌افزاری ابتدا به ساکن نمی‌دانند که چه کاربردهایی از نرم‌افزار مد نظرشان انتظار دارند و به مرور زمان ایده‌های جدیدی به ذهن ایشان می‌رسد. به عبارت دیگر، ایشان به خوبی Big Picture (تصویر کلی) از اپلیکیشنی که می‌خواهند را مد نظر دارند اما وقتی که پای جزئیات به میان می‌آید، هرگز دید روشنی از آنچه می‌خواهند ندارند.

در نقطهٔ مقابل این دست مشتریان، گروهی دیگر از کارفرمایان هستند که می‌دانند چه چیزی نمی‌خواهند! در چنین شرایطی، یک دولوپر چگونه می‌تواند پی به واقعیت ماجرا ببرد تا در نهایت هم مشتری از چگونگی پیاده‌سازی پروژه راضی باشد و هم دولوپر احساس موفقیت پیدا کند؟

در یک کلام، بایستی گفت که تعامل بیشتر با یکدیگر منجر به این خواهد شد تا جزئیات بیشتری مابین کارفرما (مشتری) و مجری (دولوپر) رد و بدل گردد.

وقتی پای مذاکره با مشتریان به میان می‌آید، همواره این نکته را مد نظر داشته باشید که ممکن است برخی از ایشان اصطلاحاً Technophobia (ترس از تکنولوژی) داشته باشند؛ لذا هرگز از Jargon (اصلاحات فنی) در مکالمه با ایشان استفاده نکنید و سعی کنید به ساده‌ترین شکل ممکن به صحبت با ایشان بپردازید.

علاوه بر این، همواره این نکته را مد نظر داشته باشید که آنچه مشتری بر زبان می‌آورد، هرگز بدان معنا نیست که دقیقاً همان چیزی است که مد نظرش است! در همین راستا، هرآنچه بر زبان مشتری می‌آید را یک بار با استفاده از واژگان متفاوتی برایش بازگو کنید تا عکس‌العمل وی را جویا شوید.

همچنین در صورت امکان و چنانچه قرار است برای مجموعه‌ای نرم‌افزار تولید کنید که بزرگ است، سعی کنید مسئله و نیاز آنها را از زبان چند شخص مختلف بشنوید تا از یکسان بودن دیدگاه‌ها و بالتبع پیدا کردن درک صحیحی از نیازهای ایشان اطمینان حاصل کنید (چنانچه چیزی که از زبان چند نفر می‌شنوید با یکدیگر در تضاد بود، شانس این را خواهید داشت تا ایشان را به قول معروف به جان یکدیگر بیندازید تا در نهایت مشخص شود که منظور کدام یک صحیح است).

علاوه بر این، همواره مد نظر داشته باشید که برای برقراری ارتباطی مؤثر، می‌توانید در طول نشست از وایت‌بورد، نمودار، چارپ و غیره برای نشان دادن بهتر خروجی طرح استفاده کنید.

تمامی این موارد به کنار، پس از عقد قرارداد دائماً مشتریان را در جریان روند پیشرفت پروژه قرار داده و در صورت امکان خروجی کار را در معرض دید ایشان قرار دهید تا چناچه علیرغم در نظر گرفتن نکات فوق کماکان سوء‌تفاهمی در انتقال نیازها صورت گرفته بود، بتوان قبل از این که خیلی دیر شود، تغییرات مد نظر را اعمال کرد.






