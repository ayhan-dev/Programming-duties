# Technical Debt

It often comes down to choosing between "doing a project properly" and "doing a project quickly," with speeding up the design process of a project seeming more attractive initially, arguing that later on, you can always go back to the code and fix any problems! However, experience has shown that when the word "later" arrives, it brings along with it numerous bugs and issues that the programmer must focus more on, leaving behind past - albeit minor - problems.

This policy in programming is known as Technical Debt, which can be literally translated as "Technical Debt" (be sure to note that the letter "b" is not pronounced in the English word "Debt"!). Technical debt is not a good thing at all and sometimes leads to disasters in software development. To clarify this issue, let's provide an example. Technical debt is like taking a loan that gets our work going in the short term but unaware that in the future, we'll have to pay back our loan with an interest rate - say 30% more - (by the way, they say in some non-Muslim countries the interest rate is around one or two percent, while in our Islamic Iran, it sometimes reaches fifty percent. Are they Muslims or are we? Let's move on!)

In programming, the situation is exactly the same. Although sometimes we can use solutions to speed up our coding, this makes adding new features to the project difficult in the future, and in other words, we can't easily refactor our code. Interestingly, as time passes and these problems accumulate, finding solutions for them becomes even more difficult. But if we're behind schedule on our project and forced to prioritize speed over quality, what then? Our recommendation is never to sacrifice the quality of work for the sake of speeding it up, but if you really have to, then do it, but always remember that you've created technical debt for yourself, which you must pay off at the earliest opportunity. Also, make sure to mention this issue in the project documentation so that it doesn't get forgotten, as otherwise, you may end up paying a hefty price for it.



# Functional Programming

Functional programming has gained many fans in the last few years. This paradigm is the way in which the logic used in the program is considered as mathematical functions. A correct understanding of this type of paradigm will significantly help to improve the quality of the code that is written, and if you - as a programmer - use the principles of functional programming, the quality of the program that you write will double, which will eventually increase with the number of Fewer lines of code will get you the result you need.

When we use functions in our projects, specific responsibilities can be assigned to each function, and functions can provide different outputs to other parts of the program using the arguments they receive. Programs in which functions are used correctly are easier to debug than traditional programming methods. Functional programming has worked well in object-oriented programming, but this paradigm cannot be used in all situations.

# Simple is beautiful

There is a sentence of Plato with the theme that "harmony, external beauty, elegance and balance all depend on simplicity." And if this sentence is used by programmers, it will have many benefits for them, including more readability of codes, easier maintenance of scripts, increased coding speed, and finally higher quality of written codes. All these things - and even more things - are not possible except by applying this view of Plato, that is, simplicity.

Now we have to answer the question of what kind of code the beautiful adjective refers to. This question is very abstract because the concept of beauty is something completely relative. Artists' understanding of beauty is far different from that of engineers or programmers. Therefore, it is necessary to solve the problem of beauty in programming a little!

To understand this better, it is better to visit GitHub and see some scripts written by programmers from different parts of the world. By comparing different codes, you will notice that there are some programmers who follow a set of rules well, and this issue leads to the code written by them looking more beautiful. It is interesting to know that the simpler the code, the more beautiful it looks. Although there are some programs that are very complex and do strange things that make people wonder, but if we divide these programs into smaller parts, we will see that if the programmer of that program was a professional and Simplicity has faith in coding, the small parts of the program are completely simple and understandable, each module has a specific task, different parts such as classes, methods and variables are well named so that if other programmers look at the source code , they will easily understand the task of each part of the code. In short, beautiful code is code that is simple. Different parts of the software should have simple relationships with other parts and be easy to understand.

# What is the user's need?

All those who program think that the users of the program or application they develop think like them and they believe that other users will have the same relationship that they have with their program, which is a very wrong idea. Such a belief is called False Consensus Bias from the point of view of psychology. It is interesting to know that when users interact with the program written by us in a way that is contrary to our expectations, we label them "a non-professional user"! But this is if we are non-professional programmers who have not identified the needs of our target community very well!

What is certain is that users never think like programmers because, unlike developers, they sit at the computer for less time, they are not very familiar with how systems work, they lack the problem solving skills that most programmers have. They are not familiar with the patterns that programmers use to design and code, etc. In other words, the relationship that an End User has with a program or application is like the relationship that a programmer has with a car. It is true that the programmer knows how to get into the car, fasten his seat belt, etc., but the programmer never knows how the system of this car works.

To solve this problem, we should ask a normal user to interact with our program, site or application and carefully examine how he communicates with the software. In fact, we should see what the needs of this user are, where he encounters problems, in which parts he gets confused, etc. We will give an example to clarify this issue. When a programmer, for example, codes a site, when he encounters a problem in the user area, he knows for sure how to fix that problem, but this issue does not apply to normal users, and they may As soon as they encounter the smallest problem, they give up their goal. Another thing we should always keep in mind is that most of the time there is a gap between what users really need and what they say. In other words, according to the words of the late Steve Jobs, it is not the users who say what they want, but it is you as a designer who should understand the needs of the users and present them to them in the best way.

To solve this problem, instead of listening to the users, we should look at their interaction with the site, software or application and assess their needs based on their behavior with our program. In a word, if we look at the behavior of a user with our application for a few minutes, it will be much more productive than conducting a few hours of interview with several potential audience about their needs.
